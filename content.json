{"meta":{"title":"Blog","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"","slug":"MES","date":"2023-12-14T06:39:31.334Z","updated":"2023-12-14T06:39:31.334Z","comments":true,"path":"2023/12/14/MES/","permalink":"http://example.com/2023/12/14/MES/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"javaNote","slug":"javaNote","date":"2023-11-06T08:03:11.000Z","updated":"2023-12-25T13:57:00.988Z","comments":true,"path":"2023/11/06/javaNote/","permalink":"http://example.com/2023/11/06/javaNote/","excerpt":"","text":"CoreJavaDay01java是一门高级编程语言：人与机器沟通交流的工具 Java特性 1.简单性 ：与C++相比非常简单 2.面向对象 ：面向对象编程思想 ​ JDK8后 函数式编程 3.安全性与可靠性 4.跨平台 ​ 编程语言编写的代码—–&gt;OS系统下可运行的程序 5.开源性 ：源代码公开 Java的运行机制（如何做到跨平台）1.编译型 ​ 源代码—&gt;编译器编译—&gt;平台相关的可运行程序（硬件+OS） 2.解释性 ​ 源代码—&gt;解释器—&gt;逐行解释执行 3.先编译后解释 ​ 源代码—&gt;编译器编译—&gt; .class(字节码)—&gt;解释器—&gt;逐行解释执行 Java的运行环境1.JVM（java虚拟机）：用来屏蔽底层环境差异的软件 2.JRE（java运行环境）:JVM+解释器 3.JDK（java开发工具包）:JRE+编译器+工具+类库 编写Java程序1.源文件名必须以 .java结尾 2.使用文本工具打开这个文件，编写符合java语法要求的代码 3.java程序的最小编程 单位是类（class） 4.java中任何一个类可以有一个main函数，是程序的入口 CoreJavaDay02注释​ 作用：注解释义，用来对代码进行描述解释的文字，可以提高代码可读性；不是代码，编译后不会生成到 .class文件中 1.单行注释：注释范围是一行，以 &#x2F;&#x2F; 开头 2.多行注释：注释多行文字，以 &#x2F;* 开头，以 *&#x2F; 结尾 3.文档注释 ​ 作用：注释多行文字，可以生成帮助文档，仅限公开（public）的组件 ​ 1 在源代码中添加注释 &#x2F;** *&#x2F; ​ 2 使用jdk内置的文档工具抽取文档注释形成文档 package​ 作用：用来对java源文件编译后生成的 .class文件自动生成到指定目录（文件夹），便于分类管理，使目录更加整洁 ​ 语法：在源文件的首行（必须是首行），添加package包名 ​ 规范：公司或者组织的域名倒置+模块名 标识符​ 程序的各个组成部分的名字 ​ 语法要求： ​ 1.没有长度限制 ​ 2.大小写敏感，区分大小写 ​ 3.字母，下划线，数字，$，￥组成，数字不能开头 ​ 4.不能和关键字，保留字冲突 ​ 约定成俗 ​ 包名：全小写 ​ 类名：单词首字母都大写 ​ 变量名和方法名：首单词小写，其余单词首字母大写 ​ 常量：全大写，多个单词之间使用 _ 来连接 eg : MAX_SIZE 变量​ 概念：内存中的一块存储空间，用来保存程序运行时的数据 Java是一种强类型的语言，特点：定义变量必须明确变量的类型，为变量赋值时，赋的值也必须和变量类型匹配 不同类型的差异，体现在分配空间大小不同，存储的数据内容和范围不同 数据类型​ 规定一个变量将占用的空间大小 ​ 语法： 数据类型 变量； 基本数据类型：变量内部保存的就是数据本身 引用数据类型：变量内部存放的是地址 引用数据类型 变量 &#x3D; 对象； 数字和进制数字：统计计量 进制：方便统计记录超大规模的数值 原码 反码 补码 ​ 正数的原码，反码，补码都相同 ​ 负数的反码 &#x3D; 数据位取反 ​ 负数的补码 &#x3D; 反码+1 整数：二进制中为了表示整数和负数，字节空间的首位不再作为数据位，作为符号位 1 - ,0 + CoveJavaDay03数据转换 自动类型转换 ​ 大类型变量 &#x3D; 小类型变量； ​ byte&lt;short&lt;int&lt;long&lt;float&lt;double 强制类型转换 ​ 小类型变量 &#x3D; (小类型) 大类型变量； ​ 3. 自动类型提升 ​ String：字符串可以拼接上任意类型数据，拼接后的数据肯定都是字符串String 运算符 数学运算符 +, - , * , &#x2F; , % 赋值运算符 ​ &#x3D; , +&#x3D; , -&#x3D; , *&#x3D; , &#x2F;&#x3D; , %&#x3D; +&#x3D; , -&#x3D; , *&#x3D; , &#x2F;&#x3D; , %&#x3D; 虽然过程中会发生数学运算，但是不会自动类型提升 自增 自减 运算符 ​ i++ ++i i– –i 三目运算符：根据布尔值决定从2个值中取哪个值作为结果 ​ boolean值 ？值1：值2 真取前假取后 位运算符(了解)：二进制运算 &amp;, | , ~ , ^ , &lt;&lt;, &gt;&gt; , &gt;&gt;&gt; 运算符的优先级 Scanner：​ 允许我们的程序读取黑窗口中用户输入的数据 使用步骤： ​ 1.创建出Scanner扫描器 ​ java.util.Scanner sc &#x3D; new java.util.Scanner(System.in); ​ 2.调用它内置的方法完成数据的读取 ​ &#x2F;&#x2F;读取整数 ​ int i&#x3D; sc.nextInt(); ​ &#x2F;&#x2F;读取浮点数 ​ double d &#x3D; sc.nextDouble(); ​ &#x2F;&#x2F;读取字符串 ​ String s1 &#x3D; sc.next(); ​ String s2 &#x3D; sc.nextLine(); ​ &#x2F;&#x2F;读取一个字符 ​ sc.next().chartAT(0);&#x2F;&#x2F;先读取一个字符串，然后返回字符串的第一个字符 局部变量​ 定义在方法(函数)内部的变量 1. 必须先赋值后使用 2. 作用范围：从定义处起到所在代码块结束，即一个&#123; &#125; 3. 作用范围内变量不能重名 CoreJavaDay04流程控制if分支结构基本if分支结构​ 语法：if（布尔表达式）{ ​ &#x2F;&#x2F;当布尔表达式位true时，执行 ​ } ​ 布尔表达式：结果为boolean 类型的表达式、变量或值 ​ 执行流程： ​ 1.首先获取布尔表达式的结果 ​ 2.如果布尔表达式的值为true就执行语句体 ​ 3.如果布尔表达式的值为false就不执行语句体 ​ 4.继续执行后面的语句内容 if-else分支结构12345语法：if( 布尔表达式 )&#123; //当布尔表达式为true时执行&#125;else&#123; //当布尔表达式为false时执行 &#125; ​ 执行流程： ​ 1.首先获取布尔表达式的结果 ​ 2.如果布尔表达式的值为true就执行if代码块 ​ 3.如果布尔表达式的值为false就执行else代码块 ​ 4.继续执行后面的语句内容 switch语句123456语法：switch(变量)&#123;case 值1： 匹配后，要执行的代码；break;case 值2： 匹配后，要执行的代码；break;...default: 所有case不匹配输出；break;&#125; break关键字:用于switch语句的流程控制，当程序遇到break关键字时立即跳出switch语句执行后续的代码。 循环结构 while 1234567语法：while(条件)&#123;//条件就是boolean值 &#125;执行流程：1.判断循环条件2.执行循环体中的代码1~2反复执行，循环条件为 false 跳出循环结构 ​ 循环三要素： ​ 1.定义循环变量：设置循环起点 ​ 2.设置循环条件：设置循环终点 ​ 3.改变循环变量的值：控制循环步长 do while 123456语法：do&#123;&#125;while(条件)；while：先判断条件，满足条件再执行循环体 判断n+1 循环体n次do while：先执行循环体，再判断条件 循环体n次 判断n次，前n-1次为true for循环 123语法：for(条件初始语句；条件终止语句；条件更新语句)&#123; //循环体&#125; 死循环 while 123while(true)&#123; &#125;; do while 123do&#123; &#125;while(true); ​ for 123for(;;)&#123;&#125; 流程控制语句break ​ 作用：提前终止循环 例: 12345for( int i=1; i&lt;=10; i++ )&#123; System.out.println( i ); if( i == 5 ) break;//跳出循环 &#125;输出结果：1/2/3/4/5 continue ​ 作用：提前结束本次循环，但不能终止循环 例： 12345for( int i = 1; i&lt;=10; i++)&#123; if( i== 5 ) continue;//跳过本次循环，继续下次循环 System.out.println( i );&#125;输出结果：1/2/3/4/6/7/8/9/10 嵌套循环​ 执行流程：外层循环执行一次，内层循环执行n次 1234567891011121314151617181920212223for(int i=1; i&lt;=3; i++)&#123; System.out.println(&quot;外层循环：&quot;+i); for(int j=1; j&lt;=5; j++)&#123; System.out.println(&quot;\\t内层循环：&quot;+j); &#125; &#125;/*输出结果：外层循环：1 内层循环：1 内层循环：2 内层循环：3 内层循环：4 内层循环：5外层循环：2 内层循环：1 内层循环：2 内层循环：3 内层循环：4 内层循环：5.... */ 应用场景：一个循环的循环体 的一部分又是一个重复的过程。 CoreJavaDay05函数​ 表示提供了一个特定功能的代码段 1. 函数就是一段代码 2. 这段代码一定拥有一个特定的功能 作用：当程序中需要一个特定的功能，就可以定义出一个函数，在需要使用这个功能的地方，可以调用这个函数，复用特定功能的代码，减少代码的冗余 1.函数的定义​ 函数组成分为2部分：函数的声明和函数的实现(函数体) 1234567891011121314public static 返回值类型 函数名(形参列表)&#123; 函数的实现(函数体)：就是函数抽取的功能代码段&#125;函数声明三要素： 函数名：给函数起个名字，合法标识 形参列表：定义在函数名后的局部变量，用来接收调用者调用函数的数据 返回值类型：用来声明这个函数执行结束之后，返回一个什么类型的数据 一旦定义了返回值类型后，就需要在函数中使用return返回结果. 语法：return 结果(常量字面值|有值的变量|有值的式子); 函数一旦执行return语句，整个函数调用就会立刻结束 注意：函数返回值为void时，仍可使用return，return后不跟任何结果 return; 2.函数的调用123456函数名(值1，值2，...) 调用时()里的值，构成了实参列表 实参列表和形参列表必须要匹配：数量匹配，类型匹配，顺序匹配 执行流程：在main函数中自上而下的执行代码，遇到函数调用语句时，程序的流程将跳出主函数进入了函数定义处，然后自上而下的执行自定义函数，函数执行完毕程序流程返回到main的函数调用处，并继续向下执行， 嵌套函数调用中，最外层的函数最先执行；最内层的函数最先执行完。 1234栈数据结构： 1.可以存储多块数据 2.存储的时侯，最后存储的数据在最上方；最先存储的数据在最下方 3.FILO : first input last output 递归​ 定义：一个函数中调用自己 12345678public static void m()&#123;...m();//递归调用&#125;递归的使用前提：当前这个问题的解决方案和问题的规模没有关系 12345678910pbulic static 返回值类型 f(int n)&#123; if(最小规模的判断)return 值； return f(比n小)+额外的处理；&#125;递归要素： 1.问题必须前提：问题的求解方式与规模无关 2.大规模问题拆分成小规模 3.回归条件 CoreDay07数组​ 数组：用于一次性的定义多个相同类型的变量，在内存中是连续的存储空间 ​ 1.有需求需要一下子定义多个变量，数组用来简化多个变量的定义过程 ​ 2.数组的多个变量在空间上时连续的 数组的定义声明 语法： 12345数据类型[] 数组名;数据类型 []数组名; 数据类型 数组名[]; 手动为数组分配空间： ​ 数组是由多个内存空间构成， 必须根据需求手动分配空间数量，无法自动分配 1数组名 = new 数据类型[ 长度 ]; 使用下标操作数组 —将数据保存到数组中 1数组名[下标] = 数据; 获取数组长度 12数组长度：表示数组的空间数量，数组的容量数组名.length 遍历数组 1234for(int i=0; i&lt;数组名.length; i++)&#123; //使用i变量作为数组下标 数组名[i];&#125; 创建数组的其他方式 1234561.数据类型[] 数组名 = new 数据类型[ 长度 ];2.数据类型[] 数组名;数组名 = new 数据类型[]&#123;元素1, 元素2, 元素3....&#125;;3.数据类型[] 数组名 = &#123;元素1, 元素2, 元素3....&#125;; 数组的特性​ 数组元素的默认值 123456789int[] is = new int[5];System.out.println( is[0] );//默认值：0 double[] ds = new double[5];System.out.println( ds[0] );//默认值：0.0 String[] str = new String[5];System.out.println( str[0] );//默认值：null 数组扩容​ 数组在定义后长度就会确定，随着不断的使用，数组元素使用完毕，就需要扩容数组 123456789101112131415161718192021222324252627数组扩容步骤： 1.新建一个更大的数组 2.将旧数组中的元素逐一复制到新数组中 3.丢弃旧数组，使用新数组 方式1： //1.数组扩容 //新建一个更大的数组 int[] arr2 = new int[arr1.length*2]; for (int i = 0; i &lt; arr1.length ; i++) &#123; arr2[i] = arr1[i];//将旧数组中的元素赋值给新数组 &#125; arr1 = arr2;//丢弃旧数组，使用新数组 System.out.println(arr2.length); 方式2： //新建一个更大的数组 int[] arr3 = new int[arr1.length*2]; System.arraycopy(arr1,0,arr3,0,arr1.length); //参数1：旧数组，参数2：旧数组赋值元素的起始下标 // 参数3：新数组，参数4：新数组接收旧数组元素值的起始下标 //参数5：复制的元素个数 arr1 = arr3;//丢弃旧数组，使用新数组 方式3： //参数1：旧数组，参数2：新数组长度 arr1 = java.util.Arrays.copyOf(arr1,arr1.length*2); System.out.println(arr1.length); CoreJavaDay08可变长参数​ 作用：JDK5.0特性多个相同类型数据作为参数时可自动封装为数组，一定程度上替换数组类型参数 ​ 作用：JDK5.0特性多个相同类型数据作为参数时可自动封装为数组，一定程度上替换数组类型参数 123456789101112int[] a = &#123;1,2,3,4,5&#125;;m1(a);m1(10,20,30);//自动封装为数组m1();public static void m1(int... a)&#123; //在m1函数中 使用a 等同于使用数组 for(int i=0; i&lt;a.length; i++)&#123; System.out.println(a[i]); &#125;&#125; 注意： 121. 一个方法只允许有一个可变长参数，反例：m1(int... a, int... b)2. 可变长参数必须为方法的最后一个参数，反例：m1(int... b,int c) 数组排序​ 根据元素大小，将数组中的元素按照一定顺序重新排序 ​ 冒泡排序，选择排序，插入排序，希尔排序，归并排序，快速排序 冒泡排序： ​ 排序规则：数组两个相邻的元素依次比较，每次将最大的数值放到最后的位置 123456789101112131415161718192021一共进行 a.length轮class Test1&#123; public static void main(String[] args) &#123; int[] a = &#123;1,3,5,7,9,2,4,6,8,10&#125;; //冒泡 // i = 0: i&lt;a.length-1,j&lt;a.length-1-i // i = 1: i&lt;a.length,j&lt;a.length-i for (int i = 1; i &lt; a.length; i++) &#123;//控制比较轮数 for (int j = 0; j &lt; a.length-i; j++) &#123;//控制比较次数 if (a[j]&gt;a[j+1])&#123; int temp = a[j+1]; a[j+1] = a[j]; a[j] = temp; &#125; &#125; &#125; for (int i = 0; i &lt; a.length; i++) &#123; System.out.print(a[i]+&quot;\\t&quot;); &#125; &#125;&#125; 选择排序 ​ 排序规则：每一次从无序区元素中选出最小的一个元素，存放在无序区的起始位置，直到全部待排序的元素排完 代码实现： 12345678910for(int i=0; i&lt;a.length-1; i++)&#123;//控制比较轮数 for(int j=i+1; j&lt;a.length; j++)&#123;//控制比较次数 if(a[i]&gt;a[j])&#123; //交换位置 int temp = a[i]; a[i] = a[j]; a[j] = temp; &#125; &#125;&#125; 优化实现（减少交换次数） 12345678910111213141516int[] a = &#123;9,8,6,1,4&#125;;for(int i =0; i&lt; a.length; i++)&#123; int min = i;//记录最小元素的下标 for(int j=i; j&lt;a.length; j++)&#123;//找到最小元素的位置 if(a[j]&lt;a[min])&#123; min = j; &#125; &#125; //完成交换 int temp = a[i]; a[i] = a[min]; a[min] = temp;&#125;System.out.println(Arrays.toString(a)); JDK提供的快速排序 ​ 方法：java.util.Arrays.sort(） ​ 特点：由JDK实现的快速排序 ​ 使用方法： 1234int[] a = &#123;19,8,6,1,4&#125;;java.util.Arrays.sort( a );//排序完成//打印输出System.out.println( java.util.Arrays.toString( a ) );//1 4 6 8 19 CoreJavaDay09面向对象​ 一种编程思想，解题模式 ​ 面向过程的编程思想：自顶向下，逐步求精，复杂的问题，尝试拆解成多个小问题，习惯性的将复杂问题拆分成多步，按照顺序考虑清楚每一步怎么做，适用于小型复杂问题 面向对象的编程思想是一种解决复杂问题的编程方式 ​ 不同编程思想看待问题，解决问题的切入点不同 ​ 不同编程思想并不是互斥的，可以结合使用 对象​ 一切客观存在的事物 ​ 对象的组成成分：任何的对象都会有其特征（有什么，即对象的属性）和行为（做什么，即对象的方法）。 面向对象的思想： 找解决问题所需要的对象 使用对象（可能使用的是特征，也可是行为，可能是一个对象也可能是多个）完成需求 什么是类：12341.类是对象的模板，用来描述对象具备的属性和方法。2.JVM通过类中的信息创建对象（类的实例）3.类是从多个相同类型对象抽取出的共性和特征，保留所关注的部分。类是对象的模版，对象是类的实例 类的组成部分1.属性&#x2F;成员变量&#x2F;实例变量 ​ 局部变量：方法内 最多就是当前方法 ​ 实例变量：类内方法外 整个类内部 ​ 局部变量与实例变量可以同名，同名时局部变量优先 例：学生类 1234567class Student&#123; //属性 String name; //姓名 int age; //年龄 boolean sex; //性别 double score; //成绩 &#125; 2.方法&#x2F;成员方法&#x2F;实例方法 ​ 方法&#x2F;成员方法&#x2F;实例方法 语法： 123修饰符 返回值类型 方法名(参数表) 抛出的异常&#123; //方法体&#125; 注意：主函数与Student类无关，不要把主函数写在Student类中，如果需要主函数，我们会将主函数写到另外一个类中 创建对象与使用对象1.创建对象 ​ 语法： 12345new 类名();1.内存中分配对象的存储空间 主要由实例变量构成2.为属性赋默认值3，再为属性赋初始值（如果有）4.执行构造方法中的代码 2.为引用赋值 ​ 在Java中每定义一个类，就多了一种自定义的数据类型，可以将对象保存在同类型引用中 123Student stu1 = new Student();//创建Student对象并为 stu1引用赋值Student stu2 = new Student();//创建Student对象并为 stu2引用赋值Teacher t1 = new Teacher();//创建Teacher对象并为 t1 引用赋值 3.对象是独立的 ​ 模板只有一个，通过模板可以创建多个对象，每个对象都拥有自己独立的内存空间 调用对象中的方法​ 语法： 1对象名.方法名( 实参 ); 方法重载​ 在一个类中可以定义多个方法名相同，但形参列表必须不同 12345678注意事项： 尽量在同类操作有不同的参数时，使用重载 ，对返回值类型没有要求，相同与否不影响重载， 参数列表不同指的是数量不同，类型不同，顺序不同，但是形参名不同不算调用时的匹配过程： 1.会根据实参的类型，匹配相同类型形参列表的方法 2.如果上一步匹配不到，不会立刻报错，而是采用就近向上匹配原则 3.如果经过就近匹配原则后还不能找到对应形参列表的方法，则会报错 注意：就近向上匹配过程中，可能会出现多个方法都能就近匹配的情况，此时编译器无法抉择，也会报错 构造方法​ 作用：通常用于在创建对象的同时对对象进行一些初始化工作，比如为属性赋值 ​ 构造方法也支持方法重载 12345678特殊之处： 1.构造方法名固定位类名 2.没有返回值类型 3.不能手动调用（调用方式和普通方法不同） 普通方法：对象名.方法名( 实参 ) 构造方法：只能和 new 结合使用，在创建对象的过程中调用执行 A a = new A();//在创建对象的过程中调用 CoreJavaDay10数据传递规则121. 基本类型传值，两者之间任何一方更改，不影响另一方。2. 引用类型（对象、数组）传地址（形参和实参会指向同一对象），两者之间任何一方更改，影响另一方 注意：打印引用，可以获得对象所在内存地址，必须通过引用获取地址中存储的数据 this 关键字​ 运行时由JVM自动创建的变量，表示当前对象引用 this的两种用法： ​ this.属性名 区分同名的的局部变量 ​ this(…) 用在构造方法中嵌套调用其它的构造方法 例： 123456789101112class MyClass&#123; public void method()&#123; System.out.println(&quot;MyClass method &quot;+ this ); &#125;&#125;MyClass mc1 = new MyClass();mc1.method();//mc1调用method, this就是mc1MyClass mc2 = new MyClass();mc2.method();//mc2调用method, this就是mc2 使用this.访问属性或方法语法： 12访问属性：this.属性名;访问方法：this.方法名(实参); 可用于区分局部变量与实例变量 12345678class MyClass&#123; int a ; public void method(int a)&#123; System.out.println( a );//打印局部变量 a System.out.println( this.a );//打印属性 a &#125;&#125; 使用this( )调用本类其他构造方法​ 语法： 123必须在构造方法的第一行this( );//调用本类无参构造this( 实参 );//调用本类有参构造 作用：提高构造方法的重用性 1234567891011public class MyClass &#123; String name; int age; public MyClass()&#123; this(&quot;李四&quot;,30);;//无参构造里嵌套调用有参构造 &#125; public MyClass(String name,int age)&#123; this.name = name; this.age = age; &#125;&#125; 注意：this() 只能定义在构造方法的第一行 封装概念： 121.封装（Encapsulation）2.尽可能隐藏对象的内部实现细节，控制用户对对象的修改和访问权限，保障内部属性的安全。 private修饰符​ 修饰符：修饰程序中的各个组件，被修饰的组件拥有不同的特点与权限 priavte修饰符的特点:\\ 121. private表示私有的，可以修饰属性、方法。2. 被修饰的组件只能在本类中使用，对外不可见。 例： 12345678910111213141516class MyClass&#123; int a; private int b;//被private修饰，只能在本类中使用 public void ma()&#123;&#125; private void mb()&#123;&#125;//被private修饰，只能在本类中使用&#125;class TestMyClass&#123; public static void main(String[] args)&#123; MyClass mc = new MyClass(); mc.a = 10; mc.b = 20;//编译错误，无权访问 mc.ma(); mc.mb();//编译错误，无权访问 &#125;&#125; 私有化属性、方法使用private修饰属性，将属性或方法私有化，控制访问权限 提供访问或修改私有成员的途径（get&#x2F;set方法）语法： 12345678910111213get方法public 返回值类型 get属性名()&#123; return 属性;&#125;//返回值类型与属性类型一致//方法名中的属性名首字母大写set方法:public void set属性名(形参类型 形参名)&#123; this.属性名 = 形参名;&#125;//形参类型与属性类型一致//形参名与属性名一致//方法名中的属性名首字母大写 ​ 封装的意义：尽可能隐藏对象的内部实现细节，控制用户对对象的修改和访问权限，保障内部属性的安全 封装的实现方式： 121. 属性私有2. 根据需要提供公开的get或set方法，无特殊情况两个方法都要提供。 CoreJavaDay11继承​ 子类（派生类）——继承于—–&gt; 父类（超类） ​ 在面向对象的开发设计中，如果发现两个类满足 is a关系，这两个类就应该体现继承关系 123456789101112131415class Animal&#123; String name; public void eat()&#123; System.out.println(&quot;Animal eat()...&quot;); &#125; public void sleep()&#123; System.out.println(&quot;Animal sleep()...&quot;); &#125;&#125;//子类继承了父类中的属性和方法class Dog extends Animal&#123; int age; &#125;&#125; 访问权限修饰符​ 作用：控制组件可见（可用）范围 修饰符 本类 同包 其他包子类 任意位置 private √ (default) √ √ protected √ √ √ public √ √ √ √ ​ 当组件前没有访问权限修饰符时，默认为（default）修饰 private ：严格受到边界的保护，只能在对象边界()类内部才能访问 public：不再受边界的保护 ，任意位置访问到，一定能被子类继承 (不加任何修饰符) default：同包下的类可以访问，同包下的类可以继承，不同包的子类不能继承 protected：受保护，同包下任意类以及不同包子类中，一定能被继承到 额外注意：默认的类只能在同包下定义子类，公开类可以在任意位置定义子类 方法的覆盖（方法重写）使用场景： 12当父类的方法不再适用于子类或无法满足子类需求时，可以覆盖掉父类的方法再对其进行调用时，会调用覆盖后的方法 语法： 12返回值类型、方法名、参数表相同，修饰符相同或更宽默认---&gt; protected ---&gt; public 例： 12345678910111213141516171819public class TestOverride&#123; public static void main(String[]args)&#123; Sub sub = new Sub(); sub.m1();//调用子类覆盖后的m1方法 打印 m1 in sub &#125;&#125;class Super&#123; public void m1()&#123; System.out.println(&quot;m1 in super&quot;); &#125;&#125;class Sub extends Super&#123; //覆盖：访问权限修饰符相同或更宽 返回值类型、方法名、参数表相同 public void m1()&#123; System.out.println(&quot;m1 in sub&quot;); &#125;&#125; 方法覆盖和方法重载的区别： 121. 方法覆盖发生在父子类之间，语法要求：访问权限修饰符相同或更宽 返回值类型、方法名、参数表相同。2. 方法重载可以在本类中，也可以在父子类间进行重载，语法要求：方法名相同、参数表不同，其他无要求。 注意：覆盖的基础是要继承到父类的方法，如果父类的方法是私有的，就不是覆盖，构造方法不能被继承，自然也不能被覆盖。 对象创建的过程没继承 为对象的实例变量分配空间 赋值：默认值或者初始值 执行本类构造方法的代码 有继承 ​ 循先父后子的顺序，如果父类还有父类，那么就要先初始化父类的父类以此类推.. 为对象的实例变量（子类和父类）分配空间 为父类属性赋值：默认值或者初始值 执行父类的构造方法 为子类的属性赋值：默认值或者初始值 执行子类构造方法的代码 super关键字​ 含义：super表示父类对象的引用 ​ 用法： 123451.super.属性 ，super.方法(...) 明确在子类中要使用的是父类的属性或方法使用前提：属性和方法能被当前子类继承到2.super(...) 用在子类构造方法中，指明对象创建过程中调用哪个父类的哪个构造方法，有继承关系的对象创建流程：沿着 ​ 访问属性 12345678910111213class Super&#123; int a=10;//父类属性&#125;class Sub extends Super&#123; int a=20;//子类属性，属性遮盖 public void m1()&#123; int a = 30;//局部变量 System.out.println( a ); //打印局部变量a System.out.println( this.a ); //打印本类属性a System.out.println( super.a ); //打印父类属性a &#125;&#125; 访问被覆盖的方法 1234567891011class Super&#123; public void m1()&#123; System.out.println(&quot;m1 in super&quot;); &#125;&#125;class Sub extends Super&#123; public void m1()&#123;//覆盖父类的方法 super.m1();//调用父类中的m2方法 System.out.println(&quot;m1 in sub&quot;); &#125;&#125; ​ 使用super() 明确自动创建父类对象时，所使用的构造方法，默认使用父类的无参构造方法 12345678910111213141516class Animal&#123; String name; int age; public Animal()&#123;&#125; public Animal(String name, int age)&#123; this.name = name; this.age = age; &#125;&#125;class Dog()&#123; public Dog(String name,int age)&#123; //使用父类有参构造为属性赋值 super(name,age); &#125;&#125; 注意： 1231. super()只能定义在构造方法的第一行2. 每个构造方法第一行代码隐式包含super() 表示创建对象时默认使用父类的无参构造方法3. 定义类时通常会为该类添加两个构造方法，有参构造方法为属性赋值，无参构造方法用于子类创建对象时使用，这是一种约定俗成的编程习惯 CoreJavaDay12多态​ 前提是继承，必须出现父子继承关系的代码，继承关系必须合理 多态：3句话3个体现 ​ 1.子类对象可以看做父类对象，因此 Animal a &#x3D; new Dog(); ​ 2.通过父类引用只能调用父类声明的方法，不能调用子类独有的方法 ​ 3.调用的方法实际执行效果只看子类类型（对象实际类型），执行重写后的实现 概念： 12多态（Polymorphism）使用父类引用指向不同的子类对象，不同的子类对象最终会呈现不同的”形态特点” 多态的体现（语法）：使用父类引用存储子类对象 12345678class Animal&#123;&#125;class Dog extends Animal&#123;&#125;//Dog is a Animalclass Cat extends Animal&#123;&#125;//Cat is a Animal//父类引用指向子类对象，子类对象不会改变Animal a1 = new Dog();//多态的体现，父类引用指向子类对象Animal a2 = new Cat();//多态的体现，对象的实际类型不会改变System.out.println(dog.getClass());//Dog类型System.out.println(a1.getClass());//Dog类型 特点 1.子类对象类型始终不变 例： 1234567891011class Animal&#123;&#125;class Pet extends Animal&#123;&#125;class Dog extends Animal&#123;&#125;Dog d = new Dog();//Pet p = d;//将Dog对象存储到Pet引用中Animal a = d;//将Dog对象存储到Animal引用中System.out.println( d );//System.out.println( p );System.out.println( a ); 2.编译时，只能调用引用类型中声明的方法 ​ 由于多态的存在，只有在程序运行时才能知道父类中存储的对象是什么类型，而编译器无法得知，编译器只能确定引用中存储的对象是子类，而子类一定会具备父类中的方法，因此只能调用引用类型（父类）中声明的方法 1 3.运行时，如果子类覆盖了父类中的方法，则执行子类中覆盖的方法 ​ 调用方法时，调用的是对象中的方法 1234567891011121314151617181920Animal a1 = new Dog();a1.eat(); //运行时，调用子类覆盖后的方法a1.sleep(); //运行结果：狗啃骨头// Animal sleepclass Animal&#123; public void eat()&#123; System.out.println(&quot;Animal eat&quot;); &#125; public void sleep()&#123; System.out.println(&quot;Animal sleep&quot;); &#125;&#125;class Dog extends Animal&#123; public void eat()&#123; System.out.println(&quot;狗啃骨头~~&quot;); &#125;&#125; instanceof关键字​ 作用：判断引用中所存储的对象是否与某种类型兼容 语法： 1ref instanceof cls r ef为某个对象的引用，cls为类名，如果引用中所存储的对象与cls兼容则结果为true，反之为false 应用场景：用于 查找某种类型的对象 或 向下转型时使用instanceof进行判断，避免出现类型转换异常 例： 12345678Animal a = ....;//判断a引用中存储的对象是否为Dog类型if( a instanceof Dog )&#123; System.out.println( &quot;Dog in a&quot; ); Dog d = (Dog)a;//强制类型转换 d.shout();//调用Dog类中的方法&#125; 多态的好处： ​ 使用多态屏蔽子类之间的差异，使程序更加灵活 应用场景： 12341.形参上：形参定义的是父类类型形参，以后传参可以是父类及其子类对象的地址 返回值类型上：意味着方法的返回值是父类类型，方法执行后可以返回父类类型对象和子类类型的对象2.数组上：定义一个父类类型的数组，数组的每一个元素就是一个引用，可以指向不同的子类对象 CoreJavaDay13关键词abstract概念： 1234abstract （抽象的）可以修饰类、方法，使程序设计的更加合理抽象类的作用：1.可以更合理的表现面向对象 2.强制多态 可以声明方法指向子类对象 抽象类概念：被abstract修饰的类称为抽象类、 特点：抽象类只能声明引用不能创建对象 抽象方法概念：被abstract修饰的方法，称之为抽象方法 特点： ​ 1.抽象方法只能有声明，不能有实现 例： 12345public abstract void m1();//抽象方法public abstract void m2();//抽象方法public void m3()&#123;//非抽象方法 //方法的实现&#125; ​ 2.抽象方法只能定义在抽象类中 例： 123abstract class MyClass&#123;//抽象类 public abstract void m1();//抽象方法&#125; ​ 3.当父类存在抽象方法时，子类必须覆盖父类的抽象方法，否则子类还是抽象类 1234567891011121314151617例：子类没有覆盖父类的抽象方法abstract class Super&#123;//抽象类 public abstract void m1();//抽象方法&#125;abstract class Sub extends Super&#123;//因为没有覆盖MyClass中的抽象方法，所以子类必须也是抽象类&#125;例：子类覆盖父类的抽象方法 abstract class Super&#123;//抽象类 public abstract void m1();//抽象方法&#125;class Sub extends Super&#123; public void m1()&#123;//覆盖父类中的抽象方法 添加实现&#123; &#125; &#125;&#125; ​ 子类覆盖父类的抽象方法，并添加方法的实现{ }，这种特殊的覆盖语法称之为实现 注意：由于继承关系可以多级继承，当继承到多个抽象方法时，子类如果不想成为抽象类，必须都予以实现 关键词static概念： 123static（静态）可以修饰类、属性、方法、动态初始化代码块、import被static修饰的方法叫静态方法，没有被static修饰的方法叫实例方法 静态属性（类变量）概念：被static修饰的属性，称之为静态属性或类变量 特点：静态属性与对象无关，有独立的存储区域，可以通过类名直接访问，可以被所有对象共享 例 1234567891011121314class MyClass&#123; int a;//一般属性 static int b;//静态属性&#125;//为静态属性赋值MyClass.a = 10;//静态属性被所有对象共享MyClass mc1 = new MyClass()System.out.println( mc1.a );//10MyClass mc2 = new MyClass();System.out.println( mc2.a );//10 注意： 静态属性虽然可以通过引用名.的方式使用，但是极度不推荐，容易与一般属性造成混淆 静态方法 概念：被static修饰的方法称为静态方法 特点： ​ 1.静态方法与对象无关，可以使用类名直接调用 12345678910class Super&#123; //静态方法 public static void m1()&#123; &#125;&#125;//调用Super类中的静态方法Super.m1(); ​ 2.静态方法与对象无关，因此不能使用非静态的成员（成员变量、成员方法），因为它们需要创建对象后才能使用 例： 123456789class Super&#123; int a; //一般属性 public void m1()&#123; &#125;//一般方法 public static void m2()&#123;//静态方法 System.out.println( a );//错误：静态方法中不能访问非静态成员 m1();//错误：静态方法中不能访问非静态成员 &#125;&#125; ​ 3.静态方法可以被继承 例： 12345678910class Super&#123; public static void m1()&#123; &#125;&#125;class Sub extends Super&#123; &#125;//调用父类中的m1方法Sub.m1();//可以从父类中继承静态方法m1(); ​ 4.静态方法只能被静态方法所覆盖 例： 123456789101112131415class Super&#123; public static void m1()&#123; &#125;&#125;class Sub extends Super&#123; //覆盖父类中的静态方法 public static void m1()&#123; &#125;&#125;Sub.m1();//调用覆盖后的m1方法 ​ 5.静态方法在使用时没有多态 例： 12345678class Super&#123; public static void m1()&#123;&#125;&#125;class Sub extends Super&#123; public static void m1()&#123;&#125;&#125;Super sup = new Sub();//多态语法sup.m1();//编译后----&gt;Super.m1();引用名替换为引用类型 小结 12static 修饰属性：静态属性，所有此类对象共享，可以直接通过类名访问static 修饰方法：静态方法，可以直接通过类名方法，静态方法与对象无关，不能使用非静态属性或方法，也不可使用 this 或 super 关键字 类加载概念：JVM将硬盘中的.class文件加载到内存中的一种行为 类加载的时机与过程 12341. 当虚拟机第一次遇到某个类时（new对象、调用静态成员、使用子类）某个类时，需要通过CLASSPATH查找该类的 .class 文件。2. 将.class文件中保存的类的描述信息（属性、方法..等等）加载到内存中进行保存。3. 加载时会初始化该类的必要信息，初始化静态属性、静态方法，调用静态初始化代码块等。4. 类加载只会执行一次。 例：加载时机 1234567891011121314151617181920class MyClass&#123; static int a = 10; //静态初始化代码块，类加载时执行 static&#123; System.out.println(&quot;类加载...&quot;); &#125;&#125;class Sub extends MyClass&#123; &#125;//加载时机 1：访问静态成员MyClass.a; //加载时机 2：创建对象MyClass mc = new MyClass();//加载时机 3：创建子类对象或加载子类时Sub.a;Sub s = new Sub(); 注意：只声明引用，不会进行类加载。 静态初始化代码块概念：使用static修饰的动态初始化代码块*，称为静态初始化代码块 特点：在类加载时执行一次 作用：用于初始化静态属性，执行在整个系统中只需要运行一次的代码（加载资源、构建容器等） 例： 123456class MyClass&#123; static int a; static&#123;//静态初始化代码块 a = 10; &#125;&#125; 类加载的过程过程 1231. 如果有需要先加载父类2. 初始化静态属性3. 按照顺序初始化静态属性，或执行静态代码块 验证例： 123456789101112131415161718class Super&#123; static&#123; System.out.println(&quot;static in Super&quot;); &#125; public Super()&#123; System.out.println(&quot;init Super&quot;); &#125;&#125;class Sub extends Super&#123; static&#123; System.out.println(&quot;static in Sub&quot;); &#125; public Sub()&#123; System.out.println(&quot;init Sub&quot;); &#125;&#125; 第一次创建子类对象时输出： 1234static in Superstatic in Subinit Superinit Sub 静态引入使用import static 引入类中的静态资源 例：引入java.lang.System中的静态属性out 123456789//静态引入import static java.lang.System.out;public class Test &#123; public static void main(String[] args) &#123; //使用System.out进行输出时，不必再加入类名 out.print(&quot;Hello&quot;); &#125;&#125; static小结12341. static 修饰的属性为`静态属性`（类变量）每个对象共用一份，可以使用 类名.属性名的方式直接访问2. static 修饰的方法为`静态方法`（类方法）每个对象共用一份，可以使用 类名.属性名的方式直接访问3. static 修饰的初始化代码框为`静态初始化代码框`，主要用于在类加载时对静态变量进行初始化工作4. import static 称为`静态引入`可以`引入静态资源，使用时不必明确类名 关键词final概念： 12final （最终的）可以修饰 变量（局部变量、属性）、方法、类 常量概念：被final修饰的变量称为常量 修饰局部变量特点：只能赋值一次，不可修改 例： 123456final int a = 10;//只能赋值一次a = 10;//编译错误final int[] as = new int[5];//只能赋值一次as = new int[10];//编译错误 修饰局部变量特点：只能赋值一次，不可修改 例： 123class MyClass&#123; final int a;//编译错误&#125; 初始化方式 ​ 1.直接初始化 ​ 例： 123class MyClass&#123; final int a = 10;&#125; ​ 由于被final修饰的属性不可变，所以为了避免内存空间的浪费，该属性还应该被static修饰 ​ 2.初始化代码块| 静态块初始化代码块 ​ 例： 123456class MyClass&#123; final int a; &#123; a = 10; &#125;&#125; ​ 3.构造方法赋值 例： 12345678910class MyClass&#123; final int a; public MyClass()&#123; a = 10; &#125; public MyClass(int a)&#123; this.a = a; &#125;&#125; 注意：由于final修饰的属性必须保证能够被初始化，所以每个构造方法都要为属性初始化 最终方法概念：被final修饰的方法，称为最终方法 特点：此方法不能被子类覆盖，可以被子类继承 例： 123456789101112class Super&#123; public final void m1()&#123; &#125;&#125;class Sub extends Super&#123; //编译错误：父类final修饰的方法不能被覆盖 public void m1()&#123; &#125;&#125; 最终类概念：被final修饰的类，称为最终类 特点：不能被继承 例： 1234567final class Super&#123;&#125;//编译错误：父类为最终类，不能继承class Sub extends Super&#123;&#125; 修饰符组合规则： 12341. static、final与abstract不能连用，因为abstract为抽象的，修饰类必须由子类继承才能使用，修饰方法必须由子类覆盖才能使用，不能调用abstract修饰的方法等特点，与static final 意义冲突。2. private 与 abstract不能一起修饰方法，否则该方法将无法被覆盖3. static与final可以连用，意义不冲突4. 在定义常量时通常使用public static final 进行声明，称为公开静态常量 CoreJavaDay14接口概念：接口是特殊的抽象类,约束一个类所具备的额外能力，降低程序间的耦合 接口的独有语法： 12345678910111.接口中的方法默认是公开抽象方法2.接口中定义的属性必须是公开静态常量3.接口中没有构造方法，抽象父类可以有4.接口与接口之间可以多继承，类和类之间只有单继承 接口会从父接口中继承到抽象方法，那么在实现子接口的时候就需要将所有的抽象方法都实现，否则实现类就需要成为抽象类5.一个类只能继承一个类，但能同时实现多个接口 一个类继承父类的同时可以实现多个接口，注意继承在前实现在后 语法 语法： 1234567interface 接口名&#123;&#125;例： interface IA&#123;//接口名 &#125; 不能创建对象 例： 123456interface IA&#123;&#125;IA ia;ia = new IA();//编译错误 3.接口中的属性 特点：接口中的属性均为公开静态常量，隐式使用 public static final 修饰 1234567interface IA&#123; public static final int A = 10; int B = 20;//隐式包含 public static final &#125;IA.A//可以直接访问AIA.B//可以直接访问B 4.接口中的方法 特点：接口中的方法默认为公开抽象方法，隐式使用 public abstract 修饰 例： 1234interface IA&#123; public abstract void m1(); void m2();//隐式包含 public abstract&#125; 5.接口中的非抽象方法与静态方法 特点：JDK8或以上接口中可以定义非抽象方法与静态方法，非抽象方法需要使用default修饰符修饰 例： 123456789interface IA&#123; public static void m1()&#123; //静态方法 &#125; public default void m2()&#123; //一般方法（非抽象方法） &#125;&#125; 注意：接口中不能定义构造方法 关系1.接口与接口之间多继承 例： 1234interface IA&#123; &#125;interface IB&#123;&#125;interface IC&#123;&#125;interface ID extends IA,IB,IC&#123; &#125;//同时继承IA、IB、IC接口 父接口中定义的属性或方法也会向下传递 2.接口与接口之间多实现 子类可以通过“实现“的方式继承接口 语法： 123class 类名 implements 接口1 , 接口2...&#123;&#125; 例： 1234interface IA&#123;&#125;interface IB&#123;&#125;//实现IA,IB两个接口class MyClass implements IA,IB&#123; &#125; 实现接口就要实现接口中所有的抽象方法，否则子类应为抽象类 例： 123456789101112131415161718interface IA&#123; void m1();&#125;interface IB&#123; void m2();&#125;//实现类class MyClass1 implements IA,IB&#123; public void m1()&#123;&#125;//实现IA接口中的m1方法 public void m2()&#123;&#125;//实现IB接口中的m2方法&#125;//由于没有实现IB接口中的m2方法，因此MyClass2应为抽象类abstract MyClass2 implements IA,IB&#123; public void m1()&#123;&#125;//实现IA接口中的m1方法&#125; 注意：实现接口中的方法，访问权限修饰符必须为public ,因为接口中的抽象方法默认被public 修饰 ​ 可以继承一个类并实现多个接口，接口也属于该类的一种“父类型”， 支持多态 例： 1234567891011121314151617181920class Super&#123;&#125;//父类interface IA&#123;&#125;//IA接口interface IB&#123;&#125;//IB接口//Sub继承Super类，实现IA，IB两个接口class Sub extends Super implements IA,IB&#123;&#125;//可以用父类型引用存储子类对象Super sup = new Sub();IA ia = new Sub();IB ib = new Sub();//可以使用instanceof判断类型是否兼容Super sup = new Sub();System.out.println( sup instanceof Sub );//trueSystem.out.println( sup instanceof Super);//trueSystem.out.println( sup instanceof IA);//trueSystem.out.println( sup instanceof IB);//true ​ 访问接口中被覆盖的default方法 123456789101112interface Super&#123; void m1()&#123;&#125;//抽象方法 default void m2()&#123;&#125;//非抽象方法&#125;class Sub implements Super&#123; @Override public void m1() &#123; &#125; public void m2() &#123; Super.super.m2();//访问父接口中的m2方法 System.out.println(&quot;Sub.m2&quot;); &#125;&#125; 与抽象类的异相同点：可以作为引用，不能创建对象；可以使用多态 不同点： 特点 抽象类 接口 关键字 abstract class interface 属性 无要求 默认为公开静态常量隐式使用 public static final 方法 无要求 默认为公开抽象方法隐式使用 public abstractdefault方法 与 static 方法 构造方法 有 无 继承关系 单继承 接口之间多继承，类与接口多实现 父类的作用： ​ 1.抽取共性代码组成，提高代码复用性 ​ 2.配合多态 接口的作用： 1.抽取不同类型共性大的方法声明 2.配合多态 ​ 通过接口引用能接受的对象类型范围比父类引用能接受的类型范围要广泛的多 接口的应用使用接口标识一个类所具备的额外能力 概念：父类决定了子类应具备的特征，接口扩充额外功能 例：找出所有会跑的动物 使用接口标识每种能力 1234567891011//每个接口都标识一种而外能力interface Runnable&#123;//所有会跑的动物实现此接口 public void run();&#125;interface Swimmable&#123;//所有会游泳的动物实现此接口 public void swim();&#125;interface Flyable&#123;//所有会飞的动物实现此接口 public void fly();&#125; 找出所有动物中具备run（跑）能力（方法）的动物 12345678910111213141516public static void main(String[]args)&#123; //动物数组 Animal[] as = &#123; new Dog(),new Cat(), new Fish(),new Bird(),new Cat(), new Dog(),new Fish() &#125;; //遍历动物数组 for(int i=0; i&lt;as.length; i++)&#123; Animal a = as[i]; //找出每一种会跑的对象，会跑的对象应实现Runnable接口 if( a instanceof Runnable )&#123; Runnable r= (Runnable) a; r.run(); &#125; &#125;&#125; 每种动物实现具有标识额外能力的接口 1234567891011121314151617181920212223242526272829abstract class Animal&#123; public abstract void eat(); public abstract void sleep();&#125;//Dog 继承Animal 实现两种标识能力的接口Runanble,Swimmableclass Dog extends Animal implements Runnable,Swimmable&#123; public void eat()&#123;&#125; public void sleep()&#123;&#125; public void run()&#123;&#125; public void swim()&#123;&#125;&#125;//Cat继承Animal 实现两种标识能力的接口Runanbleclass Cat extends Animal implements Runnable&#123; public void eat()&#123;&#125; public void sleep()&#123;&#125; public void run()&#123;&#125;&#125;//Fish继承Animal 实现两种标识能力的接口Swimmableclass Fish extends Animal implements Swimmable&#123; public void eat()&#123;&#125; public void sleep()&#123;&#125; public void swim()&#123;&#125;&#125;//Bird继承Animal 实现两种标识能力的接口Flyableclass Bird extends Animal implements Flyable&#123; public void eat()&#123;&#125; public void sleep()&#123;&#125; public void fly()&#123;&#125;&#125; 优点：可以更自然的使用多态，找到符合能力的对象而不是只限定类型 管理常量 ​ 由于接口中的属性都是默认为公开静态常量，使用接口更好的管理常量 例： 123456//使用接口标识颜色，统一颜色的校验方式interface Color&#123; int RED = 1; int YELLO = 2; int GREEN = 3;&#125; 降低程序间耦合 例：Computer（电脑）与USB外设 例Computer 12345678910111213class Computer&#123;//电脑类 USB usb; //接入设备 public void setUSB(USB usb)&#123; this.usb = usb; &#125; //开机方法 public void on()&#123; System.out.println(&quot;--开机--&quot;); if(usb!=null) usb.service(); &#125;&#125; 测试类组装Computer与USB外设 123456789USB mou = new Mouse(&quot;罗技&quot;);USB kb = new Keyboard(&quot;雷柏&quot;);USB f = new Fan();Computer com = new Computer();//将鼠标接入到电脑中com.setUSB(f);//开机 com.on(); 只要实现了USB接口的外设，都能够接入电脑 USB接口 123interface USB&#123; public void service();&#125; 接口实现类 1234567891011121314151617181920212223242526272829//USB鼠标类class Mouse implements USB&#123; String name; public Mouse(String name)&#123; this.name = name; &#125; public void service()&#123; System.out.println(&quot;控制指针&quot;); &#125;&#125;//USB键盘类class Keyboard implements USB&#123; String name; public Keyboard(String name)&#123; this.name = name; &#125; public void service()&#123; System.out.println(&quot;录入信息&quot;); &#125; &#125;//USB风扇类class Fan implements USB&#123; public void service()&#123; System.out.println(&quot;吹风~~~~~~&quot;); &#125;&#125; 接口回调 概念：开发时定义好接口后，先有接口的使用者，后有接口的实现者 体现：使用接口作为参数，使用接口作为属性 例：Computer类 1234567891011121314class Computer&#123;//电脑类 USB usb; //接入设备 public void setUSB(USB usb)&#123; this.usb = usb; &#125; //开机方法 public void on()&#123; System.out.println(&quot;--开机--&quot;); if(usb!=null) usb.service(); &#125;&#125; ​ 该类在设计过程中不需要关心将来由谁实现USB接口，不会与具体的对象产生耦合，设计Computer不用关心其他外设对象 例：使用JDK提供的java.util.Arrays.sort( ) 完成对象数组的排序 Student类，实现Comparable接口 实现规则： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253541. Student类实现Comparable接口则在&lt;&gt;中写Student，Worker类实现Comparable接口则在&lt;&gt;中写Worker2. &lt;&gt;为泛型，后续章节讲解3. 实现caompareTo方法时，参数类型与&lt;&gt;中的类型一致4. 该方法返回一个整数，升序排列规则如下： 参与比较的两个对象分别是this与参数other 以age排序为例： 如果this.age &gt; other.age 返回 正数 (实际应用时可省略this.) 如果this.age &lt; other.age 返回 负数 (实际应用时可省略this.) 相等返回0，或对下一个属性进行大小验证，则age相等时参照其他属性进行排序 基本数据类型使用 &gt;、&lt;、== 验证大小，对象类型直接使用 属性名.compareTo( other.属性名 ) 即可 例如:参照name属性进行排序 name.compareTo( other.name ) 前提：对象所属类已实现Comparable接口 //Student实现Comparable接口，实现comparaTo方法class Student implements Comparable&lt;Student&gt; &#123; String name; int age; double score; public Student()&#123;&#125; public Student(String name, int age , double score)&#123; this.name = name; this.age = age; this.score = score; &#125; //按照分数进行升序排列 public int compareTo(Student other) &#123; return (int)(score - other.score); &#125;&#125;//测试类public class TestStudent&#123; public static void main(String[] args) &#123; //创建若干学生对象，将对象保存到stus数组中 Student[] stus = &#123; new Student(&quot;wangyx&quot;,16,99.0), new Student(&quot;yangdd&quot;,36,59.9), new Student(&quot;zhangmj&quot;,13,72.2), new Student(&quot;yangyl&quot;,18,100.0), new Student(&quot;wangmj&quot;,19,92.0) &#125;; //使用java.util.Arrays.sort帮助完成排序 java.util.Arrays.sort( stus ); //遍历数组 for(int i=0; i&lt;stus.length; i++)&#123; Student stu = stus[i]; System.out.println(stu.name+&quot;\\t&quot;+stu.age+&quot;\\t&quot;+stu.score); &#125; &#125;&#125; 接口的好处： 123451. 设计与实现完全分离2. 更自然的使用多态3. 更容易搭建程序框架4. 更容易更换实现5. 程序的耦合度降低（各个模块相对独立，彼此间没有必然联按照程序需要，使用时通过组合完成任务）。 补充 ​ 多继承存在的问题 由于一个类可以实现（继承）多个接口，所以可能出现以下问题 123456789101112interface IA&#123; String method();&#125;interface IB&#123; int method();&#125;//子类如果实现IA接口中的method方法，就无法实现IB接口中的method方法class MyClass implements IA,IB&#123; //编译错误&#125; ​ 如果是静态方法，也可能出现此类问题，因此JDK8中规定，实现类无法从父接口中继承静态方法 例如： 12345678910111213141516interface IA&#123; static void method()&#123; &#125;&#125;interface IB&#123; static void method()&#123; &#125;&#125;//如果MyClass能够继承静态方法，那么使用子类调用method方法时，编译器就分不清使用哪个method方法了class MyClass implements IA,IB&#123; &#125; CoreJavaDay15内部类 成员内部类1.定义位置 类以内，方法以外 例： 12345class OuterClass&#123;//外部类 class InnerClass&#123;//成员内部类 &#125;&#125; 2.创建对象 特点：：创建内部类对象需要依赖外部类 步骤： 123456781. 先创建外部类对象2. 通过外部类对象 创建成员内部类对象语法：外部类类名.内部类类名 变量名 = 外部类引用.new 内部类类名();例：OuterClass oc = new OuterClass();//创建外部类对象OuterClass.InnerClass oci = oc.new InnerClass();//创建内部类对象时依赖外部类对象 注意：成员内部类不允许定义静态组件 3.内部类访问外部类成员 语法：在内部类中 12外部类类名.this.成员变量外部类类名.this.成员方法 例： 12345678910class OuterClass&#123; int a = 10;//外部类成员变量 class InnerClass&#123; public void m1()&#123; int a = 20;//内部类局部变量 System.out.println( a );//打印局部变量 System.out.println( OuterClass.this.a );//访问外部类成员变量 &#125; &#125; &#125; 静态内部类1.定义位置：类以内方法以外，定义时使用 static 修饰内部类 例： 12345class OuterClass&#123; static class InnerClass&#123;//静态内部类 &#125;&#125; 2.创建对象 特点：直接可以创建对象，不依赖外部类 语法： 1234外部类类名.内部类类名 变量名 = new 外部类类名.内部类类名();例：//创建静态内部类对象OuterClass.InnerClass oci = new OuterClass.InnerClass(); 3.访问静态内部类 语法： 123外部类.内部类.静态成员例：OuterClass.InnerClass.a;//访问内部类静态成员 注意： 静态内部类只能访问外部的静态成员 直接访问内部静态成员不会加载外部静态成员 局部内部类1.定义位置：定义在方法的内部 例： 123456public static void main(String[] args)&#123; class InnerClass&#123;//局部内部类 &#125;&#125; 2.创建对象 特点：创建对象与作用范围仅在该方法中，与局部变量一致 语法： 1234567891011内部类类名 变量名 = new 内部类类名();例：public static void main(String[]args)&#123; class InnerClass&#123;//局部内部类 &#125; //创建局部内部类对象 InnerClass ic = new InnerClass(); &#125; 3.局部内部类访问外部方法的局部变量 特点：被访问的局部变量必须声明为final常量 例： 123456789101112public static void main(String[]args)&#123; final int value = 10;//外部方法的局部变量 class InnerClass&#123;//局部内部类 public void method()&#123; System.out.println( value );//访问外部方法的局部变量，该局部变量必须被final修饰 &#125; &#125; //创建局部内部类对象 InnerClass ic = new InnerClass(); &#125; 注意：JDK8或以上局部内部类访问外部方法中的局部变量，编译器会隐式使用final修饰外部变量 4.使用场景 ​ 当需要提供某个接口实现类对象，该类只对内部使用且对象只用一次时，可以使用局部内部类实现接口 匿名内部类面向对象编程的弊端： 1234面向对象编程无论完成什么功能，都需要依赖对象，需要对象就要定义类再通过类创建对象，最终需要将创建的对象交给使用者才能使用有些情况作为对象的使用者并不关注对象所属类型，只关注对象所具备的方法，所以至于该类叫什么，并不重要。作为接口的实现者，只需要按照对方的需要，提供对应类型的实现类对象即可，而构建对象的语法过于繁琐（先定义类，再创建对象），甚至于有些情况定义实现类的代码比方法中完成功能的代码还要多，而通过大量的编程中也可以发现，实现类与实现类之间的区别仅在于方法实现的不同，因此遭到很多程序员的吐槽。 特点：匿名内部类是特殊的局部内部类，只用于实现一个接口或继承一个类，定义类与创建对象同时进行，简化构建实现类（子类）的代码 语法： 12345类名/接口名 变量名 = new 类名/接口名()&#123; //匿名内部类，该类为子类/实现类 &#125;; 例：使用局部内部类继承抽象类，实现接口 1234567891011121314151617181920212223242526272829abstract class Super&#123; public abstract void m1();&#125;interface SuperInterface&#123; void m2();&#125;//测试类class Test&#123; public static void main(String[]args)&#123; //使用匿名内部类创建Super类的子类对象 Super sup = new Super()&#123;//&#123; &#125; 为无名子类 public void m1()&#123;//子类覆盖父类的抽象方法 &#125; &#125;; //使用匿名内部类创建SuperInterface接口的实现类对象 SuperInterface sup = new SuperInterface()&#123;//&#123; &#125; 为无名子类 public void m2()&#123;//子类实现接口中的抽象方法 &#125; &#125;; &#125;&#125; 局部内部类与匿名内部类，以实现USB接口并创建对象为例 因为定义类与创建对象的代码整合在一起，所以匿名内部类一生只有一个对象 使用案例1：Computer与USB设备 12345678910111213141516171819202122232425public static void main(String[] args) &#123; //USB台灯：局部内部类实现方式 class Lamp implements USB&#123; public void service()&#123; System.out.println(&quot;台灯发光&quot;); &#125; &#125; //创建USB台灯对象 USB usb = new Lamp(); //USB台灯：匿名内部类实现方式 Usb usb1 = new USB()&#123; public void service()&#123; System.out.println(&quot;台灯发光&quot;); &#125; &#125;; //创建Computer对象 Computer com = new Computer(); com.setUSB( usb1 );//接入usb设备 com.on();//开机 &#125; 使用案例2：实现Comparator接口完成排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class TestClassLoader &#123; public static void main(String[] args) &#123; Student[] stus = &#123; new Student(&quot;wangyx&quot;,16,99.0), new Student(&quot;yangdd&quot;,36,59.9), new Student(&quot;zhangmj&quot;,13,72.2), new Student(&quot;yangyl&quot;,18,100.0), new Student(&quot;wangmj&quot;,19,92.0) &#125;; //局部内部类实现 class StudentComparator implements Comparator&lt;Student&gt; &#123; //实现compare方法 //o1，o2是参与比较过程的两个对象 //实现原则与Comparable一致 public int compare(Student o1, Student o2) &#123; return (int)(o1.score - o2.score); &#125; &#125; //创建自定义比较器 Comparator com = new StudentComparator(); //匿名内部类实现 Comparator&lt;Student&gt; com1 = new Comparator&lt;Sutndet&gt;&#123; public int compare(Student o1, Student o2) &#123; return (int)(o1.score - o2.score); &#125; &#125; //使用Arrays.sort进行排序，传入对象数组与比较器 Arrays.sort( stus , com1 ); //遍历数组 for(int i=0; i&lt;stus.length; i++)&#123; Student stu = stus[i]; System.out.println(stu.name+&quot;\\t&quot;+stu.age+&quot;\\t&quot;+stu.score); &#125; &#125;&#125; Lambda 表达式概念： 12341. Lambda表达式是JDK8加入的一种新的编程方式，试图屏蔽纯面向对象编程的弊端，引入像python、js等语言的函数式编程（面向过程）特点，让接口的实现者只关注方法的实现，简化定义类、实现接口、创建对象的过程。2. Lambda表达式是匿名内部类的再简化，只保留函数的主要部分3. Lambda只能用来实现只有一个抽象方法的接口，这样的接口我们也称之为函数式接口（Function Interface） 作用：与匿名内部类一致，实现接口并创建对象，简化开发 函数描述符：用于描述一个函数或者方法 完整语法： 1(数据类型1 形参1，数据类型 形参2)-&gt;&#123;方法实现&#125; 例： 123456789101112131415161718192021222324252627282930interface IA&#123; void m1();&#125;interface IB&#123; int m2(int a);&#125;interface IC&#123; int m3(int a, int b);&#125;public class TestLambda &#123; public static void main(String[] args) &#123; //创建IA接口实现类对象 IA ia = ()-&gt; System.out.println(&quot;Hello&quot;); //创建IB接口实现类对象 IB ib1 = (int a)-&gt;&#123; return a+10;&#125;; IB ib2 = a-&gt;a+10;//简写形式 //创建IC接口实现类对象 IC ic1 = (int a,int b)-&gt;&#123;return a+b;&#125;; IC ic2 = (a,b)-&gt;a+b; &#125;&#125; 简写形式与规则 12345678910111. 方法实现只有一行语句且不是return语句时，可以省略&#123; &#125;2. 方法实现需要返回结果，但只有一行代码时，可以省略return与&#123;&#125; 简写语法：(形参1，形参2)-&gt;方法实现 例1：(a,b)-&gt;System.out.println(a+b) 例2：(a,b)-&gt;a+b //返回a+b的结果 3. 方法实现只有一个的形参时，可以省略() 简写语法：形参1-&gt;方法实现 例：a-&gt;System.out.println(a)总结：是否需要&#123; &#125;取决于代码行数与是否有return语句，是否需要()取决于参数个数 注意：return 语句不可视为单句实现所以需要加大括号 案例1：Computer与USB设备 12345678910111213141516171819public static void main(String[] args) &#123; //USB台灯：匿名内部类实现方式 Usb usb1 = new USB()&#123; public void service()&#123; System.out.println(&quot;台灯发光&quot;); &#125;&#125;; //USB台灯：Lambda表达式实现方式 USB usb2 = ()-&gt;System.out.println(&quot;台灯发光&quot;); //创建Computer对象 Computer com = new Computer(); com.setUSB( usb2 );//接入usb设备 com.on();//开机 &#125; 案例2：实现Comparator接口完成排序 123456789101112131415public static void main(String[] args) &#123; //匿名内部类方式实现 Comparator&lt;Student&gt; stuCom1 = new Comparator&lt;Student&gt;()&#123; public int compare(Student o1, Student o2) &#123; return o1.age-o2.age; &#125; &#125;; //Lambda表达式方式实现 Comparator&lt;Student&gt; stuCom2 = (o1,o2)-&gt;o1.age-o2.age; //排序 java.util.Arrays.sort( stus ,stuComp2)&#125; Lambda表达式只是简化了编写实现类、实现方法、构建对象的语法，程序编译后依然会转换为内部类的形式 CoreJavaDay16API概念：应用程序编程接口，JDK提供的一套为开发人员使用的通用类与工具，帮助程序员解决日常开发时的种种需求 Object类特点： 1231. Object（对象），万物皆对象，所以Object类为所有类的父类2. Object中所有方法都是子类所具备的方法3. Object作为引用可以存储任何对象，作为参数可以接收任何对象，作为返回值类型可以返回任何对象 Object类常用方法 getClass方法声明： 1public final Class&lt;?&gt; getClass() 作用：返回引用中所存储的对象实际类型，可用于类型判断 例：比较引用中存储的对象类型是否一致（完全相同） 123456Object o1 = new Animal();Object o2 = new Dog();System.out.println( o2 instanceof Animal ); //o2为Dog类型，Dog is a Ainmal 所以为 trueSystem.out.println( o2.getClass() == o1.getClass() );//o1为Animal类型，o2为Dog类型，false 两者类型不一致 toString方法声明： 1public String toString() 作用：返回一段可以描述当前对象的字符串（对象的字符串体现形式） Object默认的实现： 1234public String toString() &#123; //返回 类名+@+基于内存生成的hash码并转换为16进制 return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());&#125; 缺点：不能体现对象与对象之间的所有差异，例如属性的差异 子类应该覆盖toString，提供更好的实现 例：Student类覆盖toString 123456789101112class Student&#123; String name; int age; double score; public Student(String name, int age, double score) &#123; this.name = name; this.age = age; this.score = score; &#125;&#125;Student stu = new Student(&quot;wangyx&quot;,16,59);System.out.println( stu.toString() );//打印结果为地址 覆盖规则：在toString方法中 1return &quot;类名[属性名=&quot;+属性值+&quot; , 属性名=&quot;+属性值....+&quot; ]&quot;; 覆盖案例： 123456789101112131415161718class Student&#123; String name; int age; double score; public Student(String name, int age, double score) &#123; this.name = name; this.age = age; this.score = score; &#125; //覆盖父类中的toString方法，返回由各个属性构成的字符串 public String toString()&#123; return &quot;Student [name=&quot;+name+&quot; , age=&quot;+age+&quot; , socre=&quot;+score+&quot; ]&quot;; &#125;&#125;Student stu = new Student(&quot;wangyx&quot;,16,100D);System.out.println( stu.toString() );//打印结果：Student [name=wangyx , age=16 , socre=100 ] System.out打印语句在打印对象时，会自动调用对象的toString方法，打印返回值 123Student stu = new Student(&quot;wangyx&quot;,16,100D);System.out.println( stu.toString() );System.out.println( stu );//自动调用stu.toString() ,打印结果，所以同上 equals方法声明： 1public boolean equals(Object obj) 作用：比较两个对象是否“相同” Object中默认的实现： 1234public boolean equals(Object obj) &#123; //使用==进行比较，只比较地址是否相同 return (this == obj);&#125; 缺点：所谓“相同”的对象不仅是地址的验证，如果地址不同各个属性相同，我们也认为两个对象是相同的对象 12345Student stu1 = new Student(&quot;wangyx&quot;,16,100D);Student stu2 = new Student(&quot;wangyx&quot;,16,100D);System.out.println( stu1==stu2 );//结果为false，但是两个对象属性相同System.out.println( stu1.equals( stu2 ) );//结果同上 ​ 子类应该覆盖equals方法，提供更好的实现，让其具备能够鉴定属性是否相同的能力 覆盖规则： 12345678910111213141516public boolean equals(Object o)&#123; //1.如果地址相同对象一定相同 if(this==o) return true; //2.如果o为null则没有判断的必要性，如果两者类型不一样也没有判断的必要性 if(o==null || getClass()!=o.getClass() ) return false; //向下转型 本类类名 other = (本类类名) o; //验证各个属性是否相同 if(Objects.equals( 属性1 , other.属性1) &amp;&amp; Objects.equals(属性2 , other.属性2)... ) return true;//相同返回true return false;//如果没有true，则返回false&#125; ​ Objects是JDK1.7提供的工具类，其内部的equals方法可以帮我们完成两个参数是否相同的验证； 基本数据类型也可以使用&#x3D;&#x3D;判断 覆盖案例： 12345678910111213141516171819202122class Student&#123; String name; int age; double score; //覆盖equals方法 public boolean equals(Object o)&#123; //1.如果地址相同对象一定相同 if(this==o) return true; //2.如果o为null则没有判断的必要性，如果两者类型不一样也没有判断的必要性 if(o==null || getClass()!=o.getClass() ) return false; //3.向下转型 Student other = (Student)o; //4.验证内容（各个属性）是否相同 if( Objects.equals(name,other.name) &amp;&amp; Objects.equals(age,other.age) &amp;&amp; Objects.equals( score,other.score ) ) return true; return false; &#125; &#125; finalize方法声明： 1protected void finalize() throws Throwable 作用：当对象被垃圾回收器（Garbage Collection) 准备回收前调用 相关概念： 1231. 垃圾对象：在JVM生命周期中会创建无数个对象，每个对象都会占用一块内存空间，如果每个对象都无限期存活在内存中，那么很快就会把内存消耗光引发内存不足的问题，JVM提供了一个系统级的垃圾回收器（gc )，自动回收无用对象所占用的内存空间。2. 垃圾对象的认定算法：零引用算法，没有引用指向该对象时，认定为垃圾对象3. 垃圾对象的回收时机：基于内存大小采用延迟回收策略 ​ GC相关方法：使用System.gc() 或 Runtime.gc() 提示gc尽快执行垃圾回收操作。但不保证立即执行。 CoreJavaDay17包装类概念：包装类即每种基本数据类型所对应的对象类型，由JDK5提供，真正实现万物皆对象，包装基本数据类型值为对象的类，包装类就是给基本数据类型提供一个对象的外衣 类型对照 基本数据类型 包装类 byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 常用方法valueOf方法方法声明： 1public static Integer valueOf​(int i)throws NumberFormatException 作用：将 基本数据类型 或 字符串 转换为 包装类型 例：基本数据类型转换为包装类 12345int a = 10;byte b = 20;Integer oi = Integer.valueOf( a );Byte ob = Byte.valueOf( b ); 例：字符串转换为包装类型 12Integer oi = Integer.valueOf(&quot;12&quot;);Double od = Double.valueOf(&quot;12.5&quot;); 注意：如果 字符串 不符合 字面值形式 ，转换时会出现数字格式化异常（java.lang.NumberFormatException: For input string: “错误的字符串”） xxValue方法xx为基本数据类型，例如byteValue、intValue、doubleValue等等 方法声明： 1public byte xxValue() 作用：将 包装类型 转换为 基本数据类型 例： 1234567Integer i = new Integer(10);Byte b = new Byte(20);Double d = new Double(30D);int a = i.intValue();//将i转换为基本数据类型byte b2 = b.byteValue();//将b转换为基本数据类型double d2 = d.doubleValue();//将d转换为基本数据类型 parseXx 方法Xx为基本数据类型，注意首字母大写；例如：parseByte、parseInt、parseDouble等等 方法声明： 1public static int parseInt​(String s) 作用：将 字符串 转换为基本数据类型 例： 123byte b3 = Byte.parseByte(&quot;12&quot;);//将字符串转换为byteint i3 = Integer.parseInt(&quot;1234&quot;);//将字符串转换为intdouble d3 = Double.parseDouble(&quot;12.5&quot;);//将字符串转换为double 自动封箱&amp;&amp;自定拆箱概念：JDK5提供的一种类型转换机制，基本数据类型可以自动转换为包装类型，反之亦可 自动封箱：自动将 基本数据类型 转换为 包装类型 例： 12Integer i = 10;Double d = 12.5; 转换时会自动调用valueOf方法进行转换 自动拆箱：自动将 包装类型 转换为 基本数据类型 例： 12345Integer i = 10;int in = i;Double d = 20;double dn = d;//自动将包装类型，转换为基本数据类型 转换时会自动调用 xxValue 方法进行转换 包装类的优势1.Object可以统一所有数据类型 例: 1234Object o1 = new Student();Object o2 = 1;//自动封箱Object o3 = 12.5;//自动封箱 2.可以区分null值与0值 1234class Student&#123; String name; Double score;//可以区分null（没考试） 或 0（考0分）&#125; 3.内部支持缓存区 缓存区大小 1B，缓存数值：-128~127 例： 123456789101112131415//使用valueOf方法进行转换时，如果缓存区中存在能表示该数值的对象，则从缓存中获取Integer i1 = Integer.valueOf(120);Integer i2 = Integer.valueOf(120);System.out.println( i1 == i2 );//true ：相同的对象，地址相同//如果使用构造方法，则每次创建的对象是都新对象Integer i3 = new Integer( 120 );Integer i4 = new Integer( 120 );System.out.println( i3 == i4 );//false：不同的对象，地址不同//当然如果数值过大，依然要重新创建对象Integer i5 = Integer.valueOf(130);Integer i6 = Integer.valueOf(130);System.out.println( i5 == i6 );//false：不同的对象，地址不同 注意：包装类需要使用equals方法验证是否相等 CoreJavaDay18String类作用：Java中最常用的字符串类 特点： 123String类属于final类无法被继承String内部使用一个final char[] data 来存储每个字符String对象是不可变的 例：String对象的内部存储 串池作用：JVM为String分配的一块内存空间，用于缓存在程序中使用的字符串 缓存时机：每次创建新的字符串时，将该字符串添加到串池中（以空间换时间） 例：比较两个字符串地址是否相同 123String str1 = &quot;wangyx&quot;;//将wangyx添加到串池中String str2 = &quot;wangyx&quot;;//不再新建，直接使用串池中的wangyxSystem.out.println( str1 == str2 );//结果为true String的不变性​ 由于Stirng内部是由一个final char[] 存储每个字符，而数组的长度一旦确定不可更改，被final修饰又不能进行扩容，所以String对象一旦创建将不可改变，只能再构建新的字符串对象，这种特点与数组是一样的 ​ 除了final char[]能够限制String对象不变s以外，还通过底层限制了String内容的不变性 例： 12345String str1 =&quot;A&quot;;String str2 =&quot;B&quot;;String str3 =&quot;C&quot;;str1 + str2 +str3//会产生多个String对象 创建String对象1.第一种方式使用 “ “ 号直接构建 12String str1 = &quot;Hello&quot;;String str2 = &quot;World&quot;; 2.使用new 语句构建 12String str1 = new String(&quot;Hello&quot;);String str2 = new String(&quot;World&quot;); 双引号 与new语句构建String对象的区别1.双引号 与new语句构建String对象的区别 例: 2.使用双等号进行判断时 123String str1 = new String(&quot;Hello&quot;);String str2 = new String(&quot;Hello&quot;);System.out.println( str1 == str2 );//地址不同结果为：false 注意：验证两个字符串是否相同，请使用equals方法 常用方法 方法名 作用 toCharArray() 将字符串转换为字符数组 equalsIgnoreCase() 忽略大小写验证 indexOf(String ch) 查找字符第一次出现的位置（下标） indexOf(String ch,int formIndex) 从formIndex位置开始向后查找字符位置（下标） lastIndexOf(String ch) 查找ch最后一次出现的位置 length( ) 返回字符串的长度 toUpperCase() 将字符串转换为大写字符 toLowerCase() 将字符串转换为小写字符 trim() 去掉字符串两边的空格 replace(String a,String b) 将字符串中的 字符串a 替换为 字符串b String[] split(String regex ) 以 regex 为分割条件 将字符串分割成多部分并返回 substring(int beginIndex, int endIndex) 截取字符串 从beginIndex开始 到endIndex-1结束 StringBuffer&#x2F;StringBuilder作用：StringBuffer与StringBuilder为可变长字符串，允许字符串在原有基础上进行修改 区别： 121. StringBuffer：JDK1.0，操作速度慢，线程安全2. StringBuilder：JDK5.0，操作速度快，线程不安全 创建对象： 12StringBuilder sb1 = new StringBuilder();//创建StringBuilder对象StringBuffer sb2 = new StringBuffer(); //创建StringBuffer对象 常用方法： 方法名 作用 append(Object obj) 将任意类型的数据转换字符串拼接到结尾 charAt(int index) 返回index位置的字符 deleteCharAt(int index) 删除index位置的字符 insert(int offset , Object obj ) 将任意类型的数据转换为字符串插入到offset位置 toString() 将StringBuilder转换为String 效率比较案例 1234567891011121314151617181920long t1 = System.currentTimeMillis();//获取当前时间的毫秒形式String str = &quot;&quot;;for(int i=1; i&lt;=30000; i++)&#123; str+=i;//将i拼接到字符串中&#125;long t2 = System.currentTimeMillis();System.out.println(t2 - t1);//计算消耗时间long t3 = System.currentTimeMillis();//创建StringBuilderStringBuilder sb = new StringBuilder();for(int i=1; i&lt;=30000; i++)&#123; sb.append( i );//将i拼接到StringBuilder中&#125;long t4 = System.currentTimeMillis();System.out.println( t4 - t3 ); CoreJavaDay19异常概念：程序在运行过程时出现的特殊情况，非语法导致的编译错误 程序运行过程中遇到不正常的情况，有2种选择： ​ 1.一旦出现异常，上抛异常信息，然后终止程序运行（后续代码不再执行） ​ 2.直接忽略，硬着头皮继续向下执行 ​ JVM对于异常的默认态度是一旦出现异常就必须上抛异常，然后终止后续的程序，避免更大的错误。 ​ 在程序开发过程中，有时候需要主动的使用异常来避免更大的问题 总结： 1.异常表示的是程序运行过程中不正常的情况 2.JVM一旦发现异常，默认就会终止程序后续的运行，避免更大的问题 异常的作用：遇到不正常的情况，代替return抛出异常信息，终止后续代码执行 1234如何代替return的语法执行： return正常结果：终止方法的后续执行 throw异常结果：类似于return，可以终止后续方法的执行 异常的分类 12341. Throwable：所有异常类的父类2. Error或子类：表示错误;例如JVM、硬件、执行逻辑错误，不能通过代码避免，不能通过代码进行处理，无需关注3. Exception或直接子类：称为已检查异常 或 编译时异常，已知的程序隐患，不能通过代码避免，必须通过代码进行处理，否则编译错误4. RuntimeException或子类：称为未检查异常 或 运行时异常，可以通过代码避免，可以通过代码处理也可不处理，编译器不干预，建议优先避免 CoreJavaDay20集合：特殊的对象 123 对象：集合还是对象，可以调用方法（不同的方法有不同的作用） 特殊：特殊在它的作用，用来保存多个 其它类型的对象 的 对象新技术用来解决旧技术的不足或不能 作用：存储对象的容器，代替数组，使用更加便捷 体系结构： Collection接口特点：内部的每个元素都是一个对象 常用方法： 方法名 作用 add( Object o ) 将o添加到集合中 contains( Object o ) 判断集合中是否有与o相同的元素 remove( Object o ) 将o从集合中移除 clear() 清空集合 isEmpty() 判断集合中是否存在有效元素 true 不存在 size() 返回有效元素个数 List 接口特点：Collection接口的子接口，有序、有下标、元素可以重复 常用方法： 方法名 作用 add(int index , Object o) 将o保存到集合中index位置（不会覆盖原有元素） Object remove(int index) 移除index位置的元素（其他元素向前位移）返回被移除的对象 Object get(int index) 获取index位置的元素 Object set(int index,Object o) 将index位置的元素替换为o并返回被替代的元素（index位置必须有元素） List subList(int a, int b) 截取集合中的一部分元素，从a开始到b-1结束 List接口实现类1234567List是接口，定义了这类集合的操作方法和特性 集合特点：有序，有下标，内容可以重复，增强版本的数组 操作方法：增删改查需要由实现类实现 1.ArrayList JDK1.2 由数组实现 查询快，增减慢 线程不安全 2.LinkedList JKD1.2 链表实现，查询慢，增删快，线程不安全 3.Vector JDK1.0 由数组实现 查询快 ，增删慢 线程安全 集合常见使用方法以ArrayList为例： 12345678910111213141516171819//创建集合对象List list = new ArrayList();//存储元素list.add( e );//存储自定义类型对象1list.add(new Student(&quot;张三&quot;,18) );//存储自定义类型对象2Student stu1 = new Student(&quot;李四&quot;,20);list.add(stu1);//移除元素list.remove( 1 );//修改元素list.set( 0 , &quot;ABC&quot;); 遍历集合for循环遍历​ 特点：使用for循环中的循环变量充当下标，获取集合中的每个元素，只能遍历List接口下的集合 规范： 12345678for(int i=0; i&lt;集合名.size(); i++)&#123; Object o = 集合名.get(i);//根据下标获取元素&#125;例： //遍历for(int i=0; i&lt;list.size(); i++)&#123; Object o = list.get(i);//根据下标获取元素&#125; 迭代器（iterator）遍历​ 特点：内部使用cursor（游标）遍历，无需使用下标，可以遍历Collection并保证遍历完整 规范： 12345Iterator it = 集合名.iterator();while(it.hasNext())&#123;//指针下移 Object o = it.next();//取出游标经过的一个对象 &#125; 迭代器常用方法： 方法声明 作用 boolean hasNext() 如果下一行有元素返回true E next() 返回下一个元素 void remove() 移除当前元素 for-each遍历JDK5提供的一种特殊的遍历方式，统一所有容器的遍历形式 实现原理：内部使用迭代器进行遍历 语法： 123for(定义一个与元素类型相同的变量 : 集合（数组）引用 )&#123; //每次循环从数组或集合中取出一个元素 为 变量赋值&#125; 例： 123456789101112131415161718192021222324252627//遍历数组int[] a = &#123;9,8,233,12,4,2&#125;;for(int i : a )&#123;//每次循环从a数组中取出一个元素 为变量i赋值 System.out.print(i+&quot;\\t&quot;);&#125;//遍历集合List&lt;String&gt; list = new ArrayList&lt;String&gt;();list.add(&quot;小叶&quot;);list.add(&quot;峰槐&quot;);list.add(&quot;锦哲&quot;); for(String o : list )&#123;//每次循环从list集合中取出一个元素为o变量赋值 System.out.println( o );&#125;//遍历存储了自定义类型对象的集合 List list2 = new ArrayList();list2.add( new Worker(&quot;wangyx&quot;,18,59D) );list2.add( new Worker(&quot;yangdd&quot;,22,10000D) ); for(Object obj: list2)&#123; Worker w1 = (Worker)obj;//向下转型 //打印worker对象的每个属性 System.out.println(w1.getName()+&quot;\\t&quot;+w1.getAge()+&quot;\\t&quot;+w1.getSalary());&#125; forEach方法遍历JDK8提供的一种遍历方式，可以配合Lambda表达式一起使用 实现原理：内部使用迭代器进行遍历 实现原理：内部使用迭代器进行遍历 1void forEach(Consumer action) Comsumer接口： 123interface Consumer&#123; void accept(T t)&#125; ​ 实现Consumer接口，实现accept方法，参数为集合中的元素，forEach方法遍历时，会自动向该方法传入实参 例：匿名内部类实现 12345678910Consumer con = new Consumer() &#123; //实现accept方法 public void accept(Object o) &#123; System.out.println( o ); //打印元素 &#125;&#125;;//调用forEach方法，传入Consumer实现类对象list.forEach( con ); 例：Lambda表达式实现 1list.forEach( o -&gt; System.out.prsintln(a) ); 泛型​ 用于表示代码定义时无法进行确定的类型 123456泛型的使用： 1.声明泛型 &lt;泛型名&gt; 如：&lt;R&gt; &lt;T&gt; &lt;E&gt; 2.在程序不能确定类型的地方，使用泛型表示（占位） 3.使用泛型时，要为泛型赋上确切的类型名泛型和集合配合使用，可以对集合元素类型进行约束注意：如果集合类型没有明确泛型，那么等同于明确了Object，一行代码前后两处泛型必须相同，这这里没有多态!!! CoreJavaDay21set集合特点：Collection接口的子接口，无序、无下标、元素不可重复 常用方法：Set接口的方法均继承自Collection 使用Set集合存储元素 例： 1234567891011121314151617//创建Set集合对象Set&lt;String&gt; set = new HashSet&lt;String&gt;();//使用add方法添加元素set.add(new String(&quot;wangyx&quot;));set.add(new String(&quot;yangdd&quot;));set.add(new String(&quot;huxz&quot;));set.add(new String(&quot;luxw&quot;));set.add(new String(&quot;wangyx&quot;)); set.remove(new String(&quot;wangyx&quot;));//删除内容一样的对象 //set集合没有单独获取元素的方法//只能遍历for(String str : set )&#123; System.out.println( str );&#125; Set接口实现类HashSet特点：由数组+链表进行存储，高效存取，内部的元素称为entry HashSet存储结构示意： 每个相同的对象拥有相同的hashCode，而不同的对象尽量拥有不同的hashCode Object提供的的hashCode方法 12//native方法底层使用c++实现，并未在java代码中予以实现public native int hashCode(); 测试hashCode方法 例： 123456789101112131415//创建若干Student对象Student stu1 = new Student( &quot;wangyx&quot;,16,100D );Student stu2 = new Student( &quot;yangdd&quot;,42,59.9 );Student stu3 = new Student( &quot;huxz&quot;,72,101D );Student stu4 = new Student( &quot;luxw&quot;,18,100D );//与stu1内容相同的对象Student stu5 = new Student( &quot;wangyx&quot;,16,100D );//对每个对象调用Object中的hashCode方法，打印结果System.out.println( stu1.hashCode() );//93122545System.out.println( stu2.hashCode() );//2083562754System.out.println( stu3.hashCode() );//1239731077System.out.println( stu4.hashCode() );//557041912System.out.println( stu5.hashCode() );//1134712904 ​ 可以看出，内容相同的对象使用Object中的hashCode方法并不能返回相同的hashCode 因此当内容相同的对象添加到HashSet中，HashSet也会认为这是“不同”的对象，因此无法按照我们的意愿区分重复对象 例： 1234567891011121314151617//创建若干Student对象Student stu1 = new Student( &quot;wangyx&quot;,16,100D );Student stu2 = new Student( &quot;yangdd&quot;,42,59.9 );Student stu3 = new Student( &quot;huxz&quot;,72,101D );Student stu4 = new Student( &quot;luxw&quot;,18,100D );//与stu1内容相同的对象Student stu5 = new Student( &quot;wangyx&quot;,16,100D );Set&lt;Student&gt; set = new HashSet&lt;&gt;();set.add( stu1 );set.add( stu2 );set.add( stu3 );set.add( stu4 );set.add( stu5 );//打印set集合元素个数System.out.println( set.size() );// 5 覆盖Object类中的hashCode方法，根据属性生成HashCode 覆盖规范如下： 123public int hashCode()&#123; return Objects.hash( 属性1，属性2,属性3....);&#125; Objects（JDK7）中提供的hash方法会根据属性的值，生成符合规则的哈希码 例：为Student类覆盖hashCode方法 1234567891011121314151617181920212223242526class Student&#123; String name; Integer age; Double score; //构造方法略... public int hashCode() &#123; return Objects.hash( name, age, score ); &#125;&#125;测试： //创建若干Student对象Student stu1 = new Student( &quot;wangyx&quot;,16,100D );Student stu2 = new Student( &quot;yangdd&quot;,42,59.9 );Student stu3 = new Student( &quot;huxz&quot;,72,101D );Student stu4 = new Student( &quot;luxw&quot;,18,100D );//与stu1内容相同的对象Student stu5 = new Student( &quot;wangyx&quot;,16,100D );//对每个对象调用Object中的hashCode方法，打印结果System.out.println( stu1.hashCode() );//93122545System.out.println( stu2.hashCode() );//2083562754System.out.println( stu3.hashCode() );//1239731077System.out.println( stu4.hashCode() );//557041912System.out.println( stu5.hashCode() );//93122545 stu5与stu1对象的内容一致，所以hashCode相同 再次尝试向HashSet中添加元素，发现依然不能去除重复对象 例： 1234567891011121314151617//创建若干Student对象Student stu1 = new Student( &quot;wangyx&quot;,16,100D );Student stu2 = new Student( &quot;yangdd&quot;,42,59.9 );Student stu3 = new Student( &quot;huxz&quot;,72,101D );Student stu4 = new Student( &quot;luxw&quot;,18,100D );//与stu1内容相同的对象Student stu5 = new Student( &quot;wangyx&quot;,16,100D );Set&lt;Student&gt; set = new HashSet&lt;&gt;();set.add( stu1 );set.add( stu2 );set.add( stu3 );set.add( stu4 );set.add( stu5 );//打印set集合元素个数System.out.println( set.size() );// 5 原因：hashCode是一个整数，并不能保证绝对的唯一，有可能出现对象不同而hashCode相同的情况 例： 12345Student stu1 = new Student(&quot;柳柴&quot;,16,100D);Student stu2 = new Student(&quot;柴柕&quot;,16,100D);System.out.println( stu1.hashCode() );//1897947248System.out.println( stu2.hashCode() );//1897947248 ​ 因此HashSet当发现hashCode相同时，为了避免出现上述情况，还会再次调用equals方法进行验证，而Object提供的equals方法并不能针对属性验证内容是否一致，所以还需要再覆盖Object中的equals方法。 例：为Student类提供equals方法 12345678910111213141516171819class Student&#123; String name; Integer age; Double score; //构造方法略... //覆盖Object类中的equals方法 public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; return Objects.equals(name, student.name) &amp;&amp; Objects.equals(age, student.age) &amp;&amp; Objects.equals(score, student.score); &#125; //覆盖Object类中的hashCode方法 public int hashCode() &#123; return Objects.hash(name, age, score); &#125;&#125; 再次测试，去重成功 1234567891011121314151617//创建若干Student对象Student stu1 = new Student( &quot;wangyx&quot;,16,100D );Student stu2 = new Student( &quot;yangdd&quot;,42,59.9 );Student stu3 = new Student( &quot;huxz&quot;,72,101D );Student stu4 = new Student( &quot;luxw&quot;,18,100D );//与stu1内容相同的对象Student stu5 = new Student( &quot;wangyx&quot;,16,100D );Set&lt;Student&gt; set = new HashSet&lt;&gt;();set.add( stu1 );set.add( stu2 );set.add( stu3 );set.add( stu4 );set.add( stu5 );//遍历set集合set.forEach( o-&gt;System.out.println(o) ); 总结： 12向HashSet集合中添加元素时，HashSet先调用元素中的hashCode方法，如果hashCode与其中的某个元素相同，则会再次调用equals方法验证两元素是否真正相同。为了确保HashSet能够正确去重，请为元素覆盖hashCode与equals两个方法 为什么不直接使用equals方法验证两个对象是否重复？ 1因为equals方法验证严谨，步骤较多，所以效率比较低，而hashCode是一个整数，比较时效率高很多 HashSet去重过程 HashSet去重 121.内容相同的对象有相同的hashCode()返回值2.要通过equal方法对比内容，那么自定义类型使用HashSet保存时，就需要重写equals LinkedHashSet特点：去重机制与HashSet相同，但可以维护元素插入顺序 例： 12345678910111213141516171819202122//创建若干Student对象Student stu1 = new Student( &quot;wangyx&quot;,16,100D );Student stu2 = new Student( &quot;yangdd&quot;,42,59.9 );Student stu3 = new Student( &quot;huxz&quot;,72,101D );Student stu4 = new Student( &quot;luxw&quot;,18,100D );//与stu1内容相同的对象Student stu5 = new Student( &quot;wangyx&quot;,16,100D );Set&lt;Student&gt; set = new LinkedHashSet&lt;&gt;();set.add( stu1 );set.add( stu2 );set.add( stu3 );set.add( stu4 );set.add( stu5 );//遍历set集合set.forEach( o -&gt; System.out.println( o.name ) );//输出结果：//wangyx//yangdd//huxz//luxw TreeSet​ 特点：可以自动对集合中的元素进行排序，元素必须实现Comparable接口 ​ 去重机制：根据Comparable接口中compareTo方法的返回值进行去重，如果返回值为0表示相同的对象 ​ compareTo方法实现规范：遵循同异原则，当equals方法返回为true时，compareTo方法返回0，当equals方法返回为false时，compareTo方法返回非0 例：Student实现Comparable接口 123456789101112131415class Student implements Comparable&lt;Student&gt;&#123; String name; Integer age; Double score; //构造方法略 //实现compareTo方法，如果name相同，验证age，如果age相同，验证score，排序规则亦是如此 public int compareTo(Student stu) &#123; int result =name.compareTo(stu.name); if(result==0) result = age.compareTo(stu.age); if(result==0) result = score.compareTo(stu.score); return result; &#125;&#125; set实现类 1231.HashSet JDK1.2 使用（数组+链表+下标计算算法）散列表 实现 线程不安全2.LinkedHashSet JDK1.2 保证遍历顺序和添加顺序相同 散列表+链表 线程不安全3.TreeSet SortSet的实现类 JDK1.2 红黑树 线程不安全 Map集合 Map接口特点：一个元素由两个对象构成，分别作为Key与Value，无序，无下标，键不可重复，值可以重复，通过键访问值 Map接口的特点与字典相同 常用方法 方法名 作用 put(Object key,Object value) 向集合中添加一组键值对，如果键已存在则覆盖 get(Object key) 根据key返回value，如果key不存在 返回null remove(Object key) 根据key移除一组键值对 containsKey(Object key) 判断key是否存在 containsValue(Object value) 判断value是否存在 size() 返回键值对数量 keySet() 返回所有的key values() 返回所有的value entrySet() 返回所有的entry（键值对） 使用方式例：创建一个Map集合，存储整数与对应的字符 12345678910111213141516171819202122232425//创建map集合Map&lt;Integer,String&gt; map = new HashMap&lt;&gt;();//添加键值对map.put(65, &quot;A&quot;);map.put(66, &quot;B&quot;);map.put(67, &quot;C&quot;);map.put(68, &quot;D&quot;);//根据key获取valueString value1 = map.get(65);String value2 = map.get(80);//如果key不存在返回null//根据key删除一组键值对map.remove( 65 ); //获取map集合键值对数量int size = map.size();//3//判断key是否存在boolean b1 = map.containsKey( 65 );System.out.println( b1 );//false //判断value是否存在boolean b2 = map.containsValue(&quot;A&quot;);System.out.println( b2 );//true 遍历Map集合键遍历​ 特点：通过Map中的keySet方法，返回一个存储着所有key的Set集合，遍历该集合获取所有key 123456Set&lt;Integer&gt; keys = map.keySet();//返回Map集合中所有的key for(String key : keys)&#123; System.out.print(key+&quot; &quot;);//打印key 不换行 String value = map.get(key);//通过key获取value System.out.println(value);&#125; 值遍历​ 特点：通过Map中的values方法，返回一个存储着所有value的Collection集合，遍历该集合获取所有的value 123456Collection&lt;String&gt; values = map.values();//返回map集合中所有的valuefor(String value : values)&#123;//遍历集合中所有的value System.out.println(value); &#125; 键值遍历​ 特点：通过Map中的entrySet方法，返回一个存储着所有Entry（键值对）的Set集合，遍历该集合获取所有的键值对 Map.Entry是Map接口的内部接口，表示键值对 例：Map.Entry示意 12345678Set&lt;Map.Entry&lt;Integer,String&gt;&gt; set = map.entrySet();//返回Map集合中所有的Map.Entry对象（一个Map.Entry对象代表一个键值对）for( Map.Entry&lt;Integer, String&gt; entry:set)&#123;//遍历Map集合中的键值对（Entry&lt;键类型,值类型&gt;) String key = entry.getKey();//获取key String value= entry.getValue();//获取value System.out.println(key+&quot; &quot;+value); &#125; forEach方法遍历​ 该方法需要一个BiComsumer接口的实现类，需要实现该接口的accept方法 accept方法中的两个参数分别表示Map集合中的某个key与value 例：使用匿名内部类实现，打印所有键值对 12345map.forEach(new BiConsumer&lt;K,V&gt;()&#123; public void accept(K key, V value)&#123; System.out.println( key+&quot;\\t&quot;+value); &#125; &#125;); 例：使用Lambda表达式实现，打印所有键值对 1map.forEach( (k,v)-&gt;System.out.println(k+&quot;\\t&quot;+v) ); Map接口实现类 123451.HashMap JDK1.2 线程不安全 允许k-v为null2.LinkedHashMap JDK1.2 线程不安全 允许k-v为null 可以保证添加顺序和存储顺序一致3.Hashtable JDK1.0 线程安全 不允许k-v为null4.Properties JDK1.0 其内部保存的key和value，都是字符串类型 CoreJavaDay22I O流​ 作用：将程序中的数据发送到外部，或将外部的数据读入到程序的内部，使用IO流可以在不同的程序或容器间交换数据 ​ 位置：java.io包 相关概念： 1231. I（Input）输入：站在程序（代码）的角度上，将外部的数据读入到程序内部，称之为输入，例如Scanenr2. O（Output）输出：站在程序（代码）的角度上，将内部的数据输送到程序外部，称之为输出，例如System.out.println3. 流：用来传输数据的管道（对象），与生活中的网线、电线、水管、作用相似 计算机数据的两大存储媒介 121. 硬盘：硬盘是电脑中用来存放文件的数据存储设备，特点是存储容量大，不受断电影响，可以持久化存储数据，但数据传送速度慢。2. 内存：内存是计算机中硬盘数据和CPU数据交换的中转站，存储程序中需要经常运算或修改的数据，特点是存储容量小，电子读写，断电后内存中的数据就会被清除，只能存储临时数据，数据传输速度快，是硬盘速度的几倍乃至几十倍有余。 ​ IO操作通常用于内存与硬盘之间交互数据，将内存中的数据输送到硬盘某个文件中持久化存储（存档），也可以将硬盘中某个文件读取到程序中进行处理（读档） 流的分类按照方向区分输入流：用以将程序外部的数据读入到程序内部，例如Scanner 输出流：用以将程序内部的数据输送到程序外部，例如System.out.println 按照处理数据的单位区分字节流：以字节为处理单位，可以处理所有类型的数据或文件，例如图片文件，视频文件等 字符流：以字符为单位处理数据，只可以处理文本类型的数据或文件，例如 记事本文件 按照流的功能区分：节点流：负责读写数据的流 过滤流：在节点流的基础上增加额外功能，需要依赖节点流 121.节点流：有实际传输能力的流，如FileInputStream，FileOutputStream2.过滤流：没有实际传输能力，不能直接用其完成数据的传输。用来给节点流增加额外功能的。 字节流​ 特点：以字节为单位处理数据，可以处理所有类型的数据或文件，例如图片文件、视频文件等 OutputStream特点：字节输出流父类（抽象类），可以将程序中的数据，输出到程序外部 常用方法： 方法 作用 void write(int b) 写出一个字节的数据 void write(byte[] bs) 写出多个字节的数据 void close() 释放资源，关闭流 例：向a.dat文件中写一个字符A 123456//向程序外部写一个字节数据//FileOutputStreamOutputStream os = new FileOutputStream(&quot;a.dat&quot;);//目标位置os.write(&#x27;A&#x27;);//将一个字节的数据输出到执行位置（指定文件中）os.close();//关闭流 例：向a.dat中写多个字节数据 123456OutputStream os = new FileOutputStream(&quot;a.dat&quot;);//目标位置//写一组数据String str = &quot;ABCDEFG~Z&quot;byte[] bs = str.getBytes();//将字符串转换为字节数组out.write(bs);//写数据out.close();//关闭流 InputStream特点：字节输入流父类（抽象类），可以将外部的数据读入到程序内部 常用方法： 方法 作用 since int read() 读取一个字节的数据并返回，如果数据已读完则返回 -1 — byte[] readNBytes(int len) 读取指定len个字节并返回，如果数据已读完则返回空数组 11 byte[] readAllBytes() 读取剩余的所有字节，上限为Integer.MAX_VALUE 9 long transferTo(OutputStream) 将读取到的字节交给os并写出，返回读到的字节数 9 void close() 释放资源，关闭流 — transferTo方法内部支持缓存，默认为8192字节 例：从a.dat中读取一个字节的数据 123456//从a.dat中读取一个字节的数据//FileInputStreamInputStream is = new FileInputStream(&quot;a.dat&quot;);int b = is.read();//读取一个字节的数据System.out.println((char)b);is.close();//关闭流 例：从a.dat中读取3个字节数据 1234567InputStream is = new FileInputStream(&quot;a.dat&quot;);byte[] bs = is.readNBytes(3);//读取3个字节的数据//遍历输出结果for (byte b : bs) &#123; System.out.print((char)b);&#125;is.close(); l例：将a.dat 文件中的内容拷贝到b.dat 123456InputStream is = new FileInputStream(&quot;a.dat&quot;);//创建输入流，读取文件OutputStream os = new FileOutputStream(&quot;a.dat&quot;);//创建输出流，写文件long r = is.transferTo( os );//将is中的内容写到os中is.close();//关闭流，释放资源os.close();//关闭流，释放资源 字节流节点流FileOutputStream作用：如果系统允许，可以将数据写到系统中的某个文件中 常用构造方法： 方法 作用 FileOutputStream(String** name)** 创建一个与name所述相同的文件，如果文件已存在，则被覆盖 FileOutputStream(String** name,boolean append)** 创建一个与name所述相同的文件，如果append为true文件已存在时直接在原文件中追加内容，反之会创建新文件，覆盖原文件 FileInputStream作用：读取某个文件中的内容 常用构造方法： 方法 作用 FileInputStream(String** name)** 从name所述的文件中读取数据，如果文件不存在或是目录则抛出FileNotFoundException 字节流过滤流ObjectOutputStream​ 作用：如果系统允许，可以将数据写到系统中的某个文件中，支持8种基本类型数据与对象类型数据 常用构造方法： 方法 作用 ObjectOutputStream(OutputStream** **out) 构建Object过滤流对象，需要（依赖）传入OutputStream节点流对象将数据写到目标位置 常用方法： 方法 作用 void writerShort(int val) 将一个short类型的数据写到目标位置 void writeInt(int val) 将一个int类型的数据写到目标位置 void writeFloat(float val) 将一个float类型的数据写到目标位置 void writeDouble(double val) 将一个double类型的数据写到目标位置 void writeBoolean(boolean val) 将一个boolean类型的数据写到目标位置 void writeObject(Object val) 将任意类型的对象写到目标位置 例：在a.dat文件中写出多种类型数据 12345678910111213141516171819//1.创建节点流OutputStream os = new FileOutputStream(&quot;a.dat&quot;);//2.封装过滤流ObjectOutputStream oos = new ObjectOutputStream( os ); //3.读写数据oos.writeInt( 100 );//向外输出一个int类型数据oos.writeDouble( 200.5);//向外输出一个double类型数据oos.writeBoolean( true );//向外输出一个boolean类型数据 List&lt;String&gt; list = new ArrayList&lt;&gt;();//创建list集合对象list.add(&quot;yangdd&quot;);//在集合中添加数据list.add(&quot;wangyx&quot;);oos.writeObject( list );//向外输出一个list对象类型数据//4.关闭流oos.close(); ObjectInputStream​ 作用：读取某个文件中的数据，支持8种基本数据类型与对象类型数据 ​ 构造方法： 方法 作用 ObjectInputStream(InputStream is) 构建Object过滤流对象，需要（依赖）传入InputStream节点流对象，读取目标文件中的数据 常用方法： 方法 作用 short readShort() 读取一个short类型数据并返回 int readInt( ) 读取一个int类型数据并返回 float readFloat() 读取一个float类型数据并返回 double readDouble() 读取一个double类型数据并返回 boolean readBoolean() 读取一个boolean类型数据并返回 Object readObject() 读取任意对象类型的数据并返回 例：从a.dat文件中读取多种类型的数据 123456789101112131415161718192021222324//1.创建节点流InputStream is = new FileInputStream(&quot;a.dat&quot;);//2.封装过滤流ObjectInputStream ois = new ObjectInputStream( is );//3.读写数据int i = ois.readInt();//读取一个int类型的数据System.out.println(&quot;i = &quot; + i);double d = ois.readDouble();//读取一个double类型的数据System.out.println(&quot;d = &quot; + d);boolean b = ois.readBoolean();//读取一个boolean类型的数据System.out.println(&quot;b = &quot; + b);List li = (List)ois.readObject();//读取一个List类型的数据System.out.println(&quot;li = &quot; + li);//4.关闭流ois.close();//输出结果i = 100d = 200.5b = trueli = [yangdd, wangyx] 注意：如果文件中的数据已读完，再次进行读取操作时会抛出EOFException表示已达到结尾 I O异常处理传统处理方式例如：在a.dat中读写数据并处理异常 12345678910111213141516171819202122232425262728ObjectOutputStream oos = null;//由于需要在finally中使用oos关闭资源，所以要声明在try框外面ObjectInputStream ois = null;//由于需要在finally中使用ois关闭资源，所以要声明在try框外面try &#123; //1.创建节点流 OutputStream os = new FileOutputStream(&quot;a.dat&quot;); //2.封装过滤流 oos = new ObjectOutputStream(os); //3.读写数据 oos.writeInt(100);//向外输出一个int类型数据 //4.关闭流 oos.close(); //1.创建节点流 InputStream is = new FileInputStream(&quot;a.dat&quot;); //2.封装过滤流 ois = new ObjectInputStream(is); //3.读写数据 int i = ois.readShort();//读取一个int类型的数据 System.out.println(&quot;i = &quot; + i); //4.关闭流 ois.close();&#125;catch(Exception e)&#123; e.printStackTrace();&#125;finally&#123; //单独处理close方法出现的异常，避免关闭某个资源时出现异常导致另一个资源没有关闭 try&#123;if(oos!=null)oos.close();&#125;catch(Exception e)&#123;e.printStackTrace();&#125; try&#123;if(ois!=null)ois.close();&#125;catch(Exception e)&#123;e.printStackTrace();&#125;&#125; JDK7 try-with-resources处理异常并自动关闭资语法： 1234567try( //构建需要关闭资源的对象)&#123; //可能会出现异常的代码&#125;catch(Exception e)&#123; //处理异常&#125; 例：在a.dat中写出数据并处理异常 1234567891011try(//1.创建节点流 OutputStream os = new FileOutputStream(&quot;a.dat&quot;); //2.封装过滤流 ObjectOutputStream oos = new ObjectOutputStream(os);)&#123; //3.读写数据 oos.writeInt(100);//向外输出一个int类型数据 &#125;catch(Exception e)&#123; e.printStackTrace();&#125; 注意：try-with-resources机制只能用在实现了AotuCloseable的类 CoreJavaDay23对象序列化相关概念对象序列化：将JVM中的对象转换成二进制字节的形式在流中传输 对象反序列化：将程序外部以字节形式存在的对象，读取到JVM中，合成为一个对象 序列化授权概念：在Java中为了出于安全的考虑，并不是所有的对象都可以在流中传输进行共享，如果需要在流中传输对象就必须进行授权 授权的方式：实现java.io.Serializable接口 此接口的源码如下，是一种标识型接口，没有方法 1public interface Serializable &#123;&#125; 授权的作用：告知JVM此类对象可以在流中传输 未授权的结果：在流中传输对象时会产生NotSerializableException （不可序列化异常） 例：将Student对象写到a.dat文件中再读取 123456789101112131415161718class Student implements Serializable&#123;//实现Serializable接口，授权 private String name; private Integer age; private Double score; public Student() &#123; &#125; public Student(String name, Integer age, Double score) &#123; this.name = name; this.age = age; this.score = score; &#125; @Override public String toString() &#123; return &quot;Student&#123; name=&quot; + name + &quot;, age=&quot; + age +&quot;, score=&quot; + score +&#x27;&#125;&#x27;; &#125;&#125; 使用Object流将Student对象写到a.dat文件中（序列化） 123456789101112131415//1.创建节点流OutputStream os = new FileOutputStream(&quot;a.dat&quot;);//2.封装过滤流ObjectOutputStream oos = new ObjectOutputStream( os );//3.读写数据Student stu = new Student(&quot;wangyx&quot;,12,100.0);Student stu2 = new Student(&quot;yangdd&quot;,20,95.5);oos.writeObject(stu);//将对象拆分为二进制字节的形式写到文件中 oos.writeObject(stu2);//将对象拆分为二进制字节的形式写到文件中//4.关闭流oos.close(); 使用Object流将a.dat文件中的内容读取到程序中合并成Student对象（反序列化） 1234567891011121314//1.创建节点流InputStream is = new FileInputStream(&quot;a.dat&quot;);//2.封装过滤流ObjectInputStream ois = new ObjectInputStream( is );//3.读写数据Student stu3 = (Student)ois.readObject();//将a.dat文件中的二进制字节合并为一个对象Student stu4 = (Student)ois.readObject();//将a.dat文件中的二进制字节合并为一个对象System.out.println( stu3 );System.out.println( stu4 ); //4.关闭流oos.close(); 序列化相关补充 12341. JDK中常用的类和接口很多已经实现了Serializable便于我们后续使用，例如：8种包装类、String、ArrayList、HashSet、HashMap等等2. 序列化对象时，必须保证其所有属性均可序列化,例如：如果希望将Student写到文件中，除了要保证Student可以被序列化也要保证其属性String name、Integer age、Double score 这些类也可以被序列化。3. 序列化对象为集合时，必须保证其所有元素都是可序列化的4. 使用transient修饰符修饰属性，可以让其不参与序列化过程，不会拆分为字节在流中传输 字符与乱码字符的存储形式与传输形式​ 在计算机中，任何数据都是以字节的形式存储的，字符也不例外，当我们在文件中存储一个字符时，实际存储的是一段“编码”，该编码会映射（对应）一个字符，在打开文件时，由打开文件的工具负责将此“编码”再转换为字符 例： 字符集与编码方式​ 作用：明确字符与“编号”的映射（对应）关系与存储形式，一般情况下字符集只有一套存储形式，所以字符集与编码方式可以理解为“同义词 常见的字符集与编码方式 字符集 编码方式 字符容量 所占空间 所含字符 ASCII - 128 1b 英文字母+标点符号+控制字符 EASCII - 256 1b 兼容ASCII+额外符号+希腊字母 GB2312 - 7445 2b 兼容ASCII+简体中文+中文符号 BIG5 - 13060 2b 兼容ASCII+繁体中文+中文符号 GBK - 21886 1~2b 兼容ASCII+中文字符+特殊符号 GB18030 - 70244 1~4b 兼容ASCII+GB系列+BIG5+少数民族字符+扩展符号 Unicode UTF-8UTF-16UTF-32 144697 14b24b4b 兼容ASCII+N国字符+特殊字符+表情符号 1234561. ASCII（Amarican Standard Code for Information Interchange）美国标准信息交换代码2. EASCII（Extended ASCII）扩展美国标准信息交换代码3. Unicode（USC）：统一编码、万国码编码与解码：1. ASCII（Amarican Standard Code for Information Interchange）美国标准信息交 乱码1概念：字符在编解码过程中出现的问题，无法将字节转换成原来的文字 原因1：编解码方式不同 例：Linux 默认使用UTF-8，Windos默认使用GBK，传输数据时 原因2：字符的完整性被破坏 ​ 计算机是以字节为单位处理数据的，由于字符可能占用多个字节，如果还是以单个字节的形式去处理字符，那么一个字符的完整性将得不到保证 例：使用字节流向文件中输出一个中文字符 字符流 –在内部保证一个字符的完整性-用字节流write一个汉字 字符流父类Writer（输出流）–10224 12public void write(String str) //写入一个字符串 -1代表结束public void write(String str, int off, int len) //写入字符串的一部 Writer（输出流） 123public int read()//读一个字符public int read(char[] cbuf)//读多个字符 保存到cbuf中public int read(char[] cbuf, int off, int len) 使用案例： 12345678910111213//向a.txt中输入一段中文Writer w = new FileWriter(&quot;a.txt&quot;);w.write(&quot;床前明月光&quot;);w.close(); //读取a.txt文件中的内容Reader r = new FileReader(&quot;a.txt&quot;);while(true)&#123; int a = r.read(); if(a==-1)break; System.out.println((char)a);&#125; r.close(); 字符节点流【重点】FileWriter： 字符文件输出流 FileReader： 字符文件输入流 字符过滤流BufferedWriter ：带缓冲8192的字符输出流，内部提供了一个newLine()方法根据平台的不同可以使用不同的换行符进行换行 BufferedReader： 带缓冲8192的字符输入流，内部提供了一个readLine()方法一次读取一行文字，读取完毕后该方法返回null 使用案例： 1234567891011121314151617//向a.txt中输入一段中文Writer w = new FileWriter(&quot;a.txt&quot;);BufferedWriter bw = new BufferedWriter( w );bw.write(&quot;床前明月光&quot;);//\\n表示newLine \\r 表示return \\r\\n \\r \\n bw.newLine();//换行bw.write(&quot;撒了一碗汤&quot;);bw.close(); //读取a.txt文件中的内容Reader r = new FileReader(&quot;a.txt&quot;);BufferedReader br = new BufferedReader( r );while(true)&#123; String str = br.readLine();//读取一行文字,达到文件结尾返回null if(str==null)break; System.out.println( str );&#125;r.close(); PrintWriter：带缓冲的可以将所有数据类型转换字符输出，支持换行，本身也是一个节点流 123456PrintWriter pw = new PrintWriter(&quot;a.txt&quot;);pw.println(&quot;床前明月光&quot;);pw.println(&quot;撒了一碗汤&quot;);pw.println(&quot;举头拿毛巾&quot;);pw.println(&quot;低头擦裤裆&quot;);pw.close(); 桥转换 OutputStreamWriter &#x2F;InputStreamReader​ 作用：将字节流转换为字符流，在转换过程中可以自己定义编码方式 默认字符流使用的编码与操作系统相关 windos系统默认 GBK Bridge –读取文件—字节—字符的过程–自动分配编码，手动分配编码 需求：1.设置编码格式、2.转换字符流–System.in 使用场景1：按照指定编码读取文本文件 123456789101112//字符流读取文件时默认编码方式与操作系统有关 GBKInputStream is = new FileInputStream(&quot;test.txt&quot;);//字节流//桥转换流 将字节流转换为字符流 转换时可以指定编码方式InputStreamReader isr = new InputStreamReader(is,&quot;UTF-8&quot;);//将读到的字节转换为字符//过滤流BufferedReader br = new BufferedReader( isr );while(true)&#123; String str = br.readLine(); if(str==null)break; System.out.println( str );&#125;br.close(); 使用场景2：将字节流转换为字符流 案例：模仿Scanner从控制台中读取数据 1234567InputStream is = System.in;//由System提供，从控制台中读取数据，使用read方法时会阻塞 等待输入//桥转换，将字节流转换为字符流InputStreamReader isr = new InputStreamReader( is );//使用Buffered读取一行BufferedReader br = new BufferedReader( isr );String str = br.readLine();//读取一个字符System.out.println(str+&quot;------------&gt;&quot;); File类 作用：表示一个目录或一个文件 可以作为节点的流参数，表示目标路径 方法： 方法名 作用 createNewFile( ) 创建一个文件，如果文件已存在不会覆盖 mkdir( ) 创建一个新的目录（文件夹） delete( ) 删除一个文件或空目录 exists( ) 判断File对象表示的文件（目录）是否存在 getAbsolutePath( ) 获得文件的绝对路径 getName() 获得文件名 getParent( ) 获得文件所在目录 File[] listFiles() 如果File对象是目录，返回目中所有的File对象 File[] listFiles(FileFilter f ) 获取满足 文件过滤器指定的文件 递归删除文件目录 12345678public static void deleteDir(File dir)&#123;File[] fs = dir.listFiles(); for(File f:fs)&#123; if(f.isDirectory())deleteDir(f); f.delete(); &#125; dir.delete();&#125; 过滤文件查找目录所有.xml文件 123456789101112131415public static void findFiles(File f)&#123; File[] fs = f.listFiles(new FileFilter()&#123; public boolean accept(File file) &#123; if(file.isDirectory())return true; //if(file.getName().endsWith(&quot;.xml&quot;))return true; //return false; return file.getName().endsWith(&quot;.xml&quot;); &#125; &#125;); for (File file : fs) &#123; if(file.isFile()) System.out.println(file.getAbsolutePath()); if(file.isDirectory())findFiles(file); &#125; &#125; I O总结 类名 作用 InputStream 字节输入流父类 OutputStream 字节输出流父类 FileInputStream 字节输入节点流 FileOutputStream 字节输出节点流 BufferedInputStream 字节输入缓冲过滤流（带缓冲） BufferedOutputStream 字节输出缓冲过滤流（带缓冲） ObjectInputStream 字节输入过滤流（带缓冲，读8中基本数据类型+对象） ObjectOutputStream 字节输出过滤流（带缓冲，写8种基本数据类型+对象） PrintStream 以字节为单位将8种基本数据类型与对象转换为字符串输出到目标路径 Reader 字符输入流父类 Writer 字符输出流父类 FileReader 字符输入节点流 FileWriter 字符输出节点流 BufferedReader 字符输入缓冲过滤流（内部提供了readLine() 方法读取一行文字） BufferedWriter 字符输出缓冲过滤流 PrintWriter 以字符为单位将任意类型转换为字符串并输出 InputStreamReader 字符桥转换流（将字节输入流转换为字符输入流，可以自定义编码格式） OutputStreamWriter 字符桥转换流（将字节输出流转换为字符输出流，可以自定义编码格式） File 表示磁盘中的一个文件，可以通过File对象操作磁盘文件，也可以作为流对象的参数 1234567891011121314151617181920212223242526272829[//1.创建节点流](//1.xn--5brr72ak7kqldo82a) InputStream is = new FileInputStream(&quot;a.dat&quot;); [//2.封装过滤流](//2.xn--ket641b59ae30dklh) ObjectInputStream ois = new ObjectInputStream( is ); [//3.读写数据](//3.xn--g7qq84bbobv67e) int i = ois.readInt();//读取一个int类型的数据 System.out.println(&quot;i = &quot; + i); double d = ois.readDouble();//读取一个double类型的数据 System.out.println(&quot;d = &quot; + d); boolean b = ois.readBoolean();//读取一个boolean类型的数据 System.out.println(&quot;b = &quot; + b); List li = (List)ois.readObject();//读取一个List类型的数据 System.out.println(&quot;li = &quot; + li); [//4.关闭流](//4.xn--d6qt19dp21a) ois.close(); CoreJavaDay24多线程程序 123456789 就是一个拥有特定功能的软件，本质上就是一堆可运行的文件的合集，程序运行前就是存储在磁盘中的文件，程序运行时 额外需要内存，CPU等其它硬件资源 内存：不同程序使用不同位置的内存 CPU资源：所有资资源共享，分时间片 微观上串行，宏观上并行的方式 进程：每一个运行的程序它的资源合集，运行时的程序因这些资源而存在，运行时的程序就是进程 线程：一个OS可以运行多个程序（多个进程），一个进程中还可以有多个线程 多个进程在OS中分CPU时间片宏观上并行执行 多个线程在进程中也是并行的，也可以并行的执行任务java程序： 在java中可以使用多线程的方法将多个需要并行的任务，并发的执行起来 线程：是OS粒度最细的资源单位 12是OS粒度最细的资源单位，用来执行一个进程中的子任务创建线程的目的是在一个程序中将多个子任务并行起来。 进程概念： 1231. 程序是静态的概念，而进程是程序的实体，在CUP执行时，才被赋予生命，只有当程序真实执行时，被称为进程。2. CPU会将一段时间分为若干时间片，用于分配给进程，由操作系统负责选择将时间片分配给哪个进程，没有获得到时间片的进程将被暂停（阻塞，挂起）3. 在单核CPU中，任何时间点上，只能有一个进程在运行，由于切换速度很快，人类无法察觉，所以宏观并行，微观串行。 例：CPU为应用程序分配时间片，操作系统分配时间片 线程概念： 121. 线程是轻量级进程，一个进程可以包含多个线程，多个线程完成不同的工作，交替并发执行，称为多线程。2. 线程是CPU调度时的基本单位 线程的重要组成部分 1231. OS：操作系统（Operating System）分配时间片2. 要处理的数据：堆空间共享（对象），栈空间独立（局部变量）3. 线程要完成的任务：代码 ​ 就目前而言，我们的虚拟机中只存在一个线程，main线程 创建线程&amp;启动线程1.继承Thread类，覆盖run方法，将需要线程执行的任务写在run方法中 例： 1234567//继承Thread类class MyThread extends Thread&#123; //覆盖run方法 public void run()&#123; //需要线程完成的任务 &#125;&#125; 创建线程对象并启动线程 12Thread th = new MyThread();//创建线程对象th.start();//启动线程 2.实现Runnable接口，实现run方法，将需要线程执行的任务写在run方法中 JDK提供的Runnable接口： 123public interface Runnable &#123; void run();&#125; 例： 1234567//实现Runnable接口class MyTask implements Runnable&#123; //实现run方法 public void run()&#123; //需要线程完成的任务 &#125;&#125; 创建线程对象并启动线程 123456//1、创建Runnable对象Runnable task = new MyRunnable();//2、创建Thread对象，将task非配给线程Thread t1 = new Thread( task );//3、启动线程t1.start(); Runnable接口通常表示任务，所以创建了Runanble任务对象后，需要将该对象分配给线程去执行，类似于向线程派发任务。 多线程程序的执行效果单线程：程序只有一个执行流程，自顶向下一次运行 多线程：程序存在多个并行流程，互不等待，互不干扰 例： 1234567891011121314151617181920212223242526272829303132public class TestThread1&#123; public static void main(String[] args) throws Exception&#123; System.out.println(&quot;main程序开始&quot;); //创建t1线程 Thread t1 = new MyThread(); //启动t1线程 t1.start(); //main线程循环3000次打印MainThread+i for (int i = 0; i &lt; 3000; i++) &#123; System.out.println(&quot;MainThread &quot; + i); &#125; System.out.println(&quot;main程序结束&quot;); &#125;&#125;//自定义线程class MyThread extends Thread&#123; @Override public void run() &#123; System.out.println(&quot;t1程序开始&quot;); //循环3000次打印MyThread+i for (int i = 0; i &lt; 3000; i++) &#123; System.out.println(&quot;MyThread &quot; + i); &#125; System.out.println(&quot;t1程序结束&quot;); &#125;&#125; 线程的执行状态线程在执行时会经历的多种状态，便于我们理解线程，控制线程 线程常用方法 方法声明 作用 void start() 启动线程 static void sleep( long millis ) 当前线程休眠millis毫秒 void join() 在当前线程中调用其他线程的join()方法，让其他线程加入此线程 static Thread currentThread() 返回执行此方法的当前线程 long getId() 返回当前线程id String getName() 返回线程名称 void setName(String name) 设置线程名称 CoreJavaDay25123456单线程的程序可以满足大部分的需求场景，多线程技术的好处： 1.使得程序中多个功能同时运行，满足不同用户同时访问的需求 2.充分的利用硬件资源多线程带来的问题： 大多数情况下，如果多个线程之间功能独立，互不干扰，那么可以说就不存在问题 问题的前提：多个线程不独立，在工作工程中有一些交互，最典型的就是访问相同的数据（集合），就可能会出现被访问的数据状态不一致的现象。 线程同步概念： 121. 同步（synchronous）：单线程的默认执行方式，例如主函数调用其他方法时，必须等到其他方法执行完毕，主函数才能继续执行，是一种串行执行方式。2. 异步（asynchronous）：多线程环境下的默认执行方式，例如主函数启动新的线程，线程会执行run方法，而在run方法执行时主函数并不需要等待，可以继续执行;此时主函数与run方法就形成了异步执行，是一种并行执行方式。 线程同步实现思路与相关概念线程同步的实现思路: 12锁住临界资源对象，只提供一把钥匙，第一个访问临界资源的线程可以获取钥匙，使用临街资源，其他线程进入等待状态。得到钥匙的线程可以执行原子操作，待原子操作结束后将钥匙还给临界资源对象 相关概念: 12互斥锁标记：Java中任何对象都有一个互斥锁标记，用来分配给线程，争夺到锁标记的线程可以进行后续操作，其他线程进入锁池等待；当原子操作结束后，该线程会释放锁标记，其他线程再进行争夺，如此往复。锁池：Java中任何对象都具备的一个空间，用来存放等待争夺该对象锁标记的线程对象。 实现方式一：同步代码块语法：同步代码块 1234synchronized( 临界资源 )&#123; //原子操作&#125; 特点：只有拥有临界资源对象锁标记的线程，才能进入相同的同步代码块，线程退出同步代码块时，会释放锁标记 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class TestSynchronized2 &#123; public static void main(String[] args) &#123; //被多线程共享的对象（临界资源） MyObject obj = new MyObject(); //使用匿名内部类创建t1线程 Thread t1 = new Thread()&#123; public void run()&#123; //同步代码块，只有得到obj对象锁标记的线程，才能执行 synchronized ( obj ) &#123; //调用obj中的method方法（原子操作） obj.method( &quot;T1--------&quot;); &#125; &#125; &#125;; //使用匿名内部类创建t2线程 Thread t2 = new Thread()&#123; public void run()&#123; //同步代码块，只有得到obj对象锁标记的线程，才能执行 synchronized( obj )&#123; //调用obj中的method方法（原子操作） obj.method( &quot;T2--------&quot;); &#125; &#125; &#125;; //使用匿名内部类创建t3线程 Thread t3 = new Thread()&#123; public void run()&#123; //同步代码块，只有得到obj对象锁标记的线程，才能执行 synchronized( obj )&#123; //调用obj中的method方法（原子操作） obj.method( &quot;T3--------&quot;); &#125; &#125; &#125;; t1.start();//启动t1线程 t2.start();//启动t2线程 t3.start();//启动t3线程 &#125;&#125;//MyObject类class MyObject &#123; public void method(String str)&#123; //打印1000次str for(int i=1; i&lt;=1000; i++) System.out.println( str + i ); &#125;&#125; 运行结果：得到锁标记的线程可以执行，其他线程必须等待该线程出同步代码块（释放锁标记），才能继续争夺锁标记。 实现方式二：同步方法语法：使用synchronized修饰方法 123访问权限修饰符 ... synchronized 返回值类型 方法名 (参数表)抛出的异常&#123; //默认对this加锁 当this成为临界资源时，只有一个线程能进入到该方法中执原子操作&#125; 特点：使用当前对象this作为临界资源，当前对象被多线程共享时，需要竞争锁标记，当该方法执行完毕后，线程会释放锁标记 例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class TestSynchronized2 &#123; public static void main(String[] args) &#123; //被多线程共享的对象（临界资源） MyObject obj = new MyObject(); //使用匿名内部类创建t1线程 Thread t1 = new Thread()&#123; public void run()&#123; //调用obj中的method方法 obj.method( &quot;T1--------&quot;); &#125; &#125; &#125;; //使用匿名内部类创建t2线程 Thread t2 = new Thread()&#123; public void run()&#123; //调用obj中的method方法 obj.method( &quot;T2--------&quot;); &#125; &#125;; //使用匿名内部类创建t3线程 Thread t3 = new Thread()&#123; public void run()&#123; //调用obj中的method方法 obj.method( &quot;T3--------&quot;); &#125; &#125;; t1.start();//启动t1线程 t2.start();//启动t2线程 t3.start();//启动t3线程 &#125;&#125;//MyObject类class MyObject &#123; //当此类的某个对象被多线程共享时，调用此方法会竞争此对象的锁标记 public synchronized void method(String str)&#123;//（原子操作） //打印10次str for(int i=1; i&lt;=1000; i++) System.out.println( str + i ); &#125;//该方法结束后释放锁标记&#125; 等同于： 1234567891011class MyObject &#123; //当此类的某个对象被多线程共享时，调用此方法会竞争此对象的锁标记 public synchronized void method(String str)&#123;//（原子操作） //同步代码块 synchronized( this )&#123; //打印10次str for(int i=1; i&lt;=1000; i++) System.out.println( str + i ); &#125; &#125;&#125; 锁池中的线程​ 处于对象锁池中的线程需要等待锁标记的释放，一旦释放一起参与竞争，具有随机性 ​ 处于锁池中的线程将进入阻塞状态（Blocked），等待锁标记的释放 线程状态图： 线程安全与性能概念： 123线程安全是指在多线程并发环境下可以保证其原子性不被破坏，实现方式就是将线程由异步转换为同步同步线程后，线程将不能并发同时访问，影响并发环境下的执行效率，所以线程安全与性能是对立的在目前的应用环境系统中，可以保证线程安全的框架有很多而且性能也会较高，而JDK提供的synchronized机制比较落后，因此JDK提供的一些线程安全的类并没有太高的应用价值 例： 123456StringBuilder 线程不安全，在多线程环境应用中无法保证原子性，效率高StringBuffer 线程安全，可以保证多线程环境应用中不会出现破坏原子性的问题，效率低Vector 线程安全，效率低ArrayList 线程不安全，效率高Hashtable 线程安全，效率低HashMap 线程不安全 效率高 CoreJavaDay26反射 1234567891011121314151617181920可以更加灵活的创建对象，访问属性和调用方法的途径面向对象： 1.定义类（对象的模版） 2.创建对象 3.访问属性 4.调用方法java中面向对象编程的标准语法 1.通过class关键字 2. new 构造方法 3. 通过 .属性 4. 通过 .方法反射的语法反射和标准创建对象的语法共性的前置条件： 1. 反射和标准创建对象语法不同点，就在于加载后的类型信息使用不是自动的，需要程序员手动使用类型信息完成后续对象的创建，属性的方法和方法的调用的。 反射就是学习如何手动使用一个类的类型信息，完成创建对象，访问属性和调用方法的操作! 1.如何获取类加载后的一个类的信息 一个类被类加载后在JVM中，以一个特殊的对象为形式存储起来，这个特殊的对象记录了被加载的类的所有信息，其可以用来创建对象（注意：这个特殊的对象也有类型，是Class类型） 2.如何通过反射创建对象 3.如何通过反射访问属性 4.如何通过反射调用方法 类加载类加载时机与过程： 12341）当虚拟机第一次使用某个类时（new对象、调用静态成员、使用子类）某个类时，需要通过CLASSPATH查找该类的.class文件。2）将.class文件中保存的类的描述信息（属性、方法..等等）加载到内存中进行保存。3）加载时会初始化该类的必要信息，初始化静态属性、静态方法，调用静态初始化代码块等。4）类加载只会执行一次 类加载时机： 1231、第一次创建一个类的对象2、第一次访问一个类的静态成员3、创建子类对象或加载子类时 创建对象的过程： 1234561、先加载父类2、加载子类3、初始化父类属性4、调用父类构造方法5、初始化子类属性6、调用子类构造方法 注意：类加载只执行一次 虚拟机加载完一个类时会在元数据区形成一个类的对象Class 该对象就是类在内存中的体现，一个类只有一个Class对象 12345由于对象存在封装的特点，隐藏内部实现的细节，不暴露私有成员，外部无法访问反射编程（上帝模式）计算机---&gt;模板-------&gt;加载模板----&gt;获取类对象----&gt;获取属性/方法等----&gt;选择对象执行一个是创建对象，看你会干什么，再让你干另外一个是你不用告诉我，我知道你会干什么，直接让你去干 Class 对象​ Class对象是JVM类加载的产物，该对象封装了一个.class文件中的所有信息 记录学生信息叫学生对象，记录一个类的信息叫类对象 获取Class对象的方式1.通过对象的getClass()方法获取 12List list = new ArrayList();Class c = list.getClass(); 2.通过类名.class方式获取 1Class&lt;ArrayList&gt; c = ArrayList.class; 3.通过Class.forName(“全类名”);全类名：带包的类名 1Class c = Class.forName(&quot;java.util.ArrayList&quot;); 常用方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263Class&lt;Sub&gt; sub = Sub.class;//获取Sub类的Class对象String sn = sub.getSimpleName();//获取类名String sn2 = sub.getName();//获取全类名String packName = sub.getPackage().getName();//获取包名Class cl = sub.getSuperclass();//获取父类所对应Class对象System.out.println(sub.getInterfaces()[0]);//获取已实现的接口Object o = sub.newInstance();//通过Class对象创建Sub对象Sub s = (Sub)o;Field fe = sub.getField(&quot;e&quot;);//获得Sub类中访问公开的属性fe.set(s, 100);//为e属性赋值Field fd = sub.getDeclaredField(&quot;d&quot;);//获得Sub类中所有属性fd.setAccessible(true);//设置访问权限为true才能操作私有成员fd.set(s, 200);//为私有属Field[] fs = sub.getFields();//获得一个类中可以访问到的所有公开属性Field[] fsd = sub.getDeclaredFields();//获得本类中的所有属性（包括非公开属性）------------------------------获取方法--------------------------------------------------Class&lt;Sub&gt; cl = Sub.class;Method m1 = cl.getMethod(&quot;m1&quot;, null);//获取无参的m1方法Method m2 = cl.getMethod(&quot;m1&quot;, int.class);//获取有参的m1方法 参数类型为 intMethod m3 = cl.getMethod(&quot;m1&quot;,String.class,double.class,boolean.class );//获取有参的m1方法 参数类型为 String double boolean//创建对象调用方法Sub sub = cl.newInstance();m1.invoke( sub , null);//使用sub对象调用m1方法 invoke(执行该方法的对象,实参) 无参传入nullm2.invoke( sub, 100);//使用sub对象调用m1(int ) 方法 传入实参m3.invoke( sub, &quot;ABC&quot;,20.5,true); Method[] ms = cl.getMethods();//获取该类可以访问到的所有公开方法Method mm = cl.getDeclaredMethod(&quot;m2&quot;, null);//获取本类中的某个方法mm.setAccessible(true);//设置访问权限mm.invoke(sub, null); Method[] ms2 = cl.getDeclaredMethods();//获取本类中的所有方法class Super&#123; int a; public double b; private int c; public void m1()&#123;&#125; private void m2()&#123;&#125;&#125;class Sub extends Super implements Serializable&#123; private int d; public int e; public void m1()&#123; System.out.println(&quot;m1( )&quot;); &#125; public void m1(int i)&#123; System.out.println(&quot;m1 ( int )&quot;+i); &#125; public void m1(String a,double b,boolean c)&#123; System.out.println(&quot;m1(String double boolean)&quot;+a+b+c); &#125; private void m2()&#123; System.out.println(&quot;m2( )&quot;); &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"面试题","date":"2023-11-05T13:05:36.647Z","updated":"2023-12-18T07:50:04.705Z","comments":true,"path":"2023/11/05/面试题/","permalink":"http://example.com/2023/11/05/%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"day01 Integer a &#x3D; 128;Integer b &#x3D; 128; a &#x3D;&#x3D; b 的结果是什么? 123456789结果：false# 常量池：1. jvm认为数字 -128 ~ 127之间的数字在java程序使用频率是最高。2. 每次使用数字， 都需在内存中开辟空间(占用空间)， 初始化数据(消耗时间)3. jvm启动时候，会在内存中先初始化一定数量的数字：-128~127之间。4. 后续java程序运行期间， 凡是需要使用-128~127之间数字的，都直接从常量池获取，减少数字重复占用内存， 减少数字创建等待时间。提升效率提升。== ：比较基本类型比较的是变量保存的值，比较引用是比较是地址值是否相同，是否指向同一个对象equals ：用于比较对象的内容是否相等 String，StringBuilder，StringBuffer 的区别? 1234567891011121314# String不可变性1. 串池中的字符串, 是jvm级别, 多线程共享, 一旦某个线程修改字符串内容, 导致其他线程对于该字符串引用内容, 发生意外修改, 不安全.2. String对象,在做字符串拼接,修改字符串, 必须新创建一个新的字符串.---(字符串不可变性)总结: 字符串对象一旦创建, 内容是不会改变.# 题目答案：1. String不可变性导致拼接会产生大量中间对象, 浪费时间, 浪费空间 效率降低.2. StringBuilder可变字符串, 在拼接, 避免中间对象的产生,节省空间, 节省时间. 效率高.# 补充String 字符串常量 不可变 使用字符串拼接时是不同的2个空间StringBuffer 字符串变量 可变 字符串拼接直接在后面追加 线程安全StringBuilder 字符串变量 可变 字符串拼接直接在后面追加 非线程安全 集合 List Set Map 特点 12345678910111213141516171819202122# List集合:有序号(从0开始)对象可以重复有顺序(维持了存入的顺序)# Set集合:无序号对象不可以重复注意：① 默认set认为对象的地址是一样的，才是重复对象。对象的属性值一样，不属于重复对象。② set对存入对象判定是否是同一对象的规则：先判断对象hashcode是否一样。(类似对象地址)。如果hashcode相同， 会继续调用对象equals方法，判定对象是否相同。如果希望set认为对象的属性值一样， 就是同一对象只保留1份。重写对象hashcode方法和equals重写规则： 尽量让相同对象的hashcode相同， 对象属性不一样的对象的equals返回false无顺序(对象存入set后,顺序混乱)# Map集合每个对象Entry，包含key-valuekey不可以重复value可以重复无顺序 包装类和基本数据类型的区别 12345678910111213# 说明基本数据类型: byte short int long float double boolean char (8种)包装数据类型: Integer Long Byte Short Double Boolean Character区别:1. 包装类型属于对象类型2. 包装类型的默认值是null;例子:Double score = null;Double score = 0.0;在网上商城项目中，价格不要使用Double类型。BigDecimal b = new BigDecimal(&quot;130.08&quot;);BigDecimal result = b.multiply(new BigDecimal(&quot;100&quot;));System.out.println(result); 什么是数据库的事务，什么是脏读，不可重复读，幻读 12345事务有四个特性 ACID：1.原⼦性: 原⼦性指的就是事务⾥⾯执⾏的增删改操作是⼀个原⼦操作，要么全部成功，要么全部失败。2.隔离性: 隔离性指的是两个事务之间同时操作数据库的时候有相应的隔离级别，可以限制事务与事务之间数据的影响。3.⼀致性: ⼀致性指的是事务操作前和事务操作后数据必须是正确的。4.持久性: 持久性指的是事务做完操作之后，数据就永久保存了，不会为⼀些原因导致数据丢失。事务的这些特性会保证我们项⽬中数据的安全，不会因为⼀些异常导致数据出问题。 事务的隔离级别有四个： 123451.未提交读: 未提交读会引起脏读问题。脏读就是指⼀个事务插⼊数据后，还没有提交事务的情况下，其他的事务就可以读到该数据，这就是脏读问题。2.已提交读: 已提交读解决了脏读的问题，但是没有解决不可重复读的问题。不可重复读指的是⼀个事务读两次相同的数据，发现两次读到的数据是不⼀致的。因为中间有其他的事务修改这个数据。为了避免不可重复读的问题，我们可以把事务的隔离级别提⾼到可重复读的级别。3.可重复读: 可重复读解决了不可重复 读的问题，但是有幻读的问题，幻读是指⼀个事务读到数据库⾥⾯没有⼀条数据，在他插⼊该数据的时候突然发现数据库⾥⾯已经有这个数据了。4.序列化 :数据库提供了序列化读的隔离级别，可以解决幻读问题。隔离级别越⾼，那么数据库的性能就会越低。 过滤器和拦截器的区别 12341、使用范围与规范不同：Filter是Servlet规范中定义的，依赖于Servlet容器。拦截器是SpringMvc的组件，只有springMVC框架可以使用。2、使用资源不同：拦截器可以使用Spring里的任何资源、对象，例如Service对象、数据源、事务管理等，通过IOC注入到拦截器即可；而Filter没有被spring管理，他不能注入spring的bean对象。3、作用范围不同：Filter在只在Servlet前后起作用。而拦截器对控制器请求起作用。过滤器可以拦截任意资源包括，servlet，静态资源html,css，js。拦截器只能拦截springMVC的控制器方法。4、实现机制不同：拦截器是基于java的反射机制的，而过滤器是基于函数回调。 mybatis 中取值⽅式有⼏种？各⾃的区别是什么 123#&#123;&#125;和$&#123;&#125;的区别 占位符和字符串拼接1. #&#123;&#125;相当于sql语句的占位符，他的执行效率和安全性都比字符串拼接要好,可以防止SQL注入攻击。2. $&#123;&#125;相当于字符串拼接，更加灵活,但是容易被SQL注入攻击，可以应用在sql中的关键字。 select * from 表 order by ? 这个场景可以应用在$&#123;&#125;上。 mybatis 的⼀级缓存和⼆级缓存 1234561. mybatis中默认带了一级缓存，自动就使用了一级缓存。一级缓存是跟sqlSession相关的缓存。当我们使用同样的sqlSession去执行相同的查询sql那么一级缓存就会生效。一级缓存应用场景不多，几乎用不到。2. mybatis的二级缓存不是默认打开的，需要我们手动设置开启二级缓存。二级缓存是跟SqlSessionFactory相关的缓存。只要是同一个sqlSessionFactory创建的sqlSession对象执行的sql语句都共用这个二级缓存。 day02 spring 常⻅的注解有哪些? 12345678组件注解： @Controller @Service @Repository @Component @Bean @Configration @Scope装配注解： @Autowire @Resource @Valueaop注解： @Aspect @Before @After @Pointcut @Transcational @AroundMvc注解： @RestController @RequetMapping @PathVariable @RequestBody @RequestParam SpringMVC 处理请求的流程 123456781. 客户端（浏览器）发送请求，直接请求到 DispatcherServlet（核心控制器）。2. DispatcherServlet 根据请求信息调用 HandlerMapping（映射器），解析请求对应的 Handler（控制器）。3. 解析到对应的 Handler（也就是我们平常说的 Controller 控制器）后，开始由 HandlerAdapter 适配器处理。4. HandlerAdapter 会根据 Handler来调用真正的处理器开处理请求，并处理相应的业务逻辑。5. 处理器处理完业务后，会返回一个 ModelAndView（模型和视图） 对象，Model 是返回的数据对象，View 是个逻辑上的 View。6. ViewResolver（视图解析器） 会根据逻辑 View 查找实际的 View。7. DispaterServlet 把返回的 Model 传给 View（视图渲染）。8. 把 View 返回给请求者（浏览器） springboot 的 starter 机制 12345678其他问法：1.springboot为什么可以简化配置。2.springboot的重要注解在springboot的入口类上面有一个注解@SpringbootApplication，被分解成了三个非常重要的注解。 @SpringBootConfigration（配置类） @EnabledAutoConfigration（跟starter机制相关） @ComponentScanner（扫描当前包以及子包中的所有注解）starter机制就是springboot在启动的时候会自动装配第三方依赖中的bean对象。starter机制的注解会自动扫描第三方依赖中META-INF,spring.factories配置文件。这个配置文件中有个配置项指向了第三方依赖的配置类@Configration，在这个配置类中，第三方依赖会把要管理的对象都配置成@Bean注解。 spring 中 bean 对象的⽣命周期 12345678910对象的生命周期被分成了1.创建阶段 2.初始化 3.使用 4.销毁1. 单例对象在spring容器创建的时候就会被创建出来，而多例的对象会在ac.getBean()的时候创建出对象。2. spring会对对象的属性进行依赖的注入。3. 执行BeanPostProcessor的前置处理。4. 执行InitializingBean接口的初始化方法。5. 执行bean标签中配置的init-method的初始化方法。@PostConstruct这个注解key替代init-method配置6. 执行BeanPostProcessor的后置处理的方法。7. 到此整个bean对象创建完毕，我们就使用这个bean对象。8. 在spring容器要销毁对象的时候，bean会执行销毁操作，先执行DisposableBean接口的销毁方法。9. 执行配置在bean标签上面的destory-method的方法。 对应的注解是@PreDestroy Spring 中有哪⼏种⽅式把 bean 对象交给 IOC 容器 123451.Bean注解加上，Configuration2.使用Component注解。3.使用Import注解，可以导入一个普通的类，也可以导入一个ImportSelector4.可以实现FactoryBean接口。5.可以实现BeanDefinitionRegistryPostProcessor接口，手动向容器中注册BeanDefinition 123456781.从SpringApplication.run()开始2.获取，启动运行过程监听器。方便在各个阶段添加额外功能。3.环境变量的构建。读取配置文件中的内容转换成对象BeanDefinition4.创建ioc容器5.ioc容器的前置处理。从spring.factory里面读取信息。6.刷新容器，创建bean对象。7.ioc容器的后置处理，默认是一个空方法，如有需要可以重写该方法。8.发出结束执行事件。 Spring 事务失效的⼏个场景 1234567891011121. 抛出检查异常导致事务不能回滚 a. Spring 默认只能回滚运⾏时异常。 b. 解决办法就是配置 rollbackfor 属性2. 业务⽅法内⾃⼰处理了异常 a. 事务通知类中只有捕捉到异常后才有可能事务回滚，在业务类中⾃⼰把异常处理了就相当于没有异常发⽣。 b. 解决办法是捕捉到异常处理后再⼿动抛出⼀下。3. ⾮ public ⽅法导致事务失效 a. Spring 为⽅法添加代理，添加事务通知的前提是业务⽅式必须是 public b. 解决办法就是把⽅法改为 public4. 调⽤本类中的其他⽅法会导致事务失效。 a. 本类中的其他⽅法调⽤时不会经过代理，因此⽆法增强。 b. 把⾃⼰通过注⼊的⽅式作为属性，然后调⽤⽅法。 MySQL篇 如何定位慢查询 一个SQL语句执行很慢，如何分析 explain，desc命令 索引 聚簇索引和非聚簇索引(二级索引) 覆盖索引 创建索引 索引失效 SQL优化 主从同步原理 ​ –分担访问压力 分库分表 框架篇 Bean的生命周期 Spring的循环依赖 Spring的一级缓存无法解决缓存依赖问题 Spring的二级缓存可以解决普通对象的缓存依赖问题，不能解决代理对象的缓存依赖问题 Spring使用三级缓存可以解决普通对象和代理对象的循环依赖问题，无法解决构造方法产生的循环依赖问题(使用懒加载解决) Spring框架常见注解 集合 数组 多线程 Redis 微服务 限流常见算法：漏桶算法，令牌桶算法 XA保证数据的强一致性，CP模式 AT保证了高可用，AP模式 rabbitMQ 延迟队列&#x3D;死信交换机+TTL 若消息和队列都设置了存活时间，以短的时间为准 JVM OOM：内存溢出 ​ 设计模式 技术场景","categories":[],"tags":[]},{"title":"胡苏航的第一篇博客","slug":"胡苏航的第一篇博客","date":"2023-11-05T12:30:18.000Z","updated":"2023-11-05T12:30:52.693Z","comments":true,"path":"2023/11/05/胡苏航的第一篇博客/","permalink":"http://example.com/2023/11/05/%E8%83%A1%E8%8B%8F%E8%88%AA%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"欢迎赵一麟的来到","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2023-11-05T11:56:05.547Z","updated":"2023-11-05T11:56:05.547Z","comments":true,"path":"2023/11/05/hello-world/","permalink":"http://example.com/2023/11/05/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}