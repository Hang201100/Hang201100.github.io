<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-javaNote" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/11/06/javaNote/" class="article-date">
  <time class="dt-published" datetime="2023-11-06T08:03:11.000Z" itemprop="datePublished">2023-11-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/11/06/javaNote/">javaNote</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="CoreJavaDay01"><a href="#CoreJavaDay01" class="headerlink" title="CoreJavaDay01"></a>CoreJavaDay01</h2><p><strong>java是一门高级编程语言</strong>：人与机器沟通交流的工具</p>
<h2 id="Java特性"><a href="#Java特性" class="headerlink" title="Java特性"></a>Java特性</h2><p> 1.简单性  ：与C++相比非常简单</p>
<p>2.面向对象 ：面向对象编程思想</p>
<p>​					  JDK8后 函数式编程</p>
<p>3.安全性与可靠性</p>
<p>4.跨平台</p>
<p>​	编程语言编写的代码—–&gt;OS系统下可运行的程序</p>
<p>5.开源性 ：源代码公开</p>
<h3 id="Java的运行机制（如何做到跨平台）"><a href="#Java的运行机制（如何做到跨平台）" class="headerlink" title="Java的运行机制（如何做到跨平台）"></a>Java的运行机制（如何做到跨平台）</h3><p>1.编译型</p>
<p>​	源代码—&gt;编译器编译—&gt;平台相关的可运行程序（硬件+OS）</p>
<p>2.解释性</p>
<p>​	源代码—&gt;解释器—&gt;逐行解释执行</p>
<p>3.先编译后解释</p>
<p>​	源代码—&gt;编译器编译—&gt; .class(字节码)—&gt;解释器—&gt;逐行解释执行</p>
<h3 id="Java的运行环境"><a href="#Java的运行环境" class="headerlink" title="Java的运行环境"></a>Java的运行环境</h3><p>1.JVM（java虚拟机）：用来屏蔽底层环境差异的软件</p>
<p>2.JRE（java运行环境）:JVM+解释器</p>
<p>3.JDK（java开发工具包）:JRE+编译器+工具+类库</p>
<p><img src="C:\Users\18060\Pictures\01." alt="image-20230320162820518"></p>
<h3 id="编写Java程序"><a href="#编写Java程序" class="headerlink" title="编写Java程序"></a>编写Java程序</h3><p>1.源文件名必须以 .java结尾</p>
<p>2.使用文本工具打开这个文件，编写符合java语法要求的代码</p>
<p>3.java程序的最小编程 单位是类（class）</p>
<p>4.java中任何一个类可以有一个main函数，是程序的入口</p>
<p><img src="/javaNote.assets/02.png" alt="image-20230320173325780"></p>
<h2 id="CoreJavaDay02"><a href="#CoreJavaDay02" class="headerlink" title="CoreJavaDay02"></a>CoreJavaDay02</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>​	作用：注解释义，用来对代码进行描述解释的文字，可以提高代码可读性；不是代码，编译后不会生成到 .class文件中</p>
<p>1.单行注释：注释范围是一行，以 &#x2F;&#x2F; 开头</p>
<p>2.多行注释：注释多行文字，以 &#x2F;* 开头，以 *&#x2F; 结尾</p>
<p>3.文档注释</p>
<p>​	作用：注释多行文字，可以生成帮助文档，仅限公开（public）的组件</p>
<p>​	1 在源代码中添加注释  &#x2F;**   *&#x2F;</p>
<p>​	2 使用jdk内置的文档工具抽取文档注释形成文档</p>
<h3 id="package"><a href="#package" class="headerlink" title="package"></a>package</h3><p>​	作用：用来对java源文件编译后生成的 .class文件自动生成到指定目录（文件夹），便于分类管理，使目录更加整洁</p>
<p>​	语法：在源文件的首行（必须是首行），添加package包名</p>
<p>​	规范：公司或者组织的域名倒置+模块名</p>
<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>​	程序的各个组成部分的名字</p>
<p>​	语法要求：</p>
<p>​		1.没有长度限制</p>
<p>​		2.大小写敏感，区分大小写</p>
<p>​		3.字母，下划线，数字，$，￥组成，数字不能开头</p>
<p>​		4.不能和关键字，保留字冲突</p>
<p>​	约定成俗</p>
<p>​		包名：全小写</p>
<p>​		类名：单词首字母都大写</p>
<p>​		变量名和方法名：首单词小写，其余单词首字母大写</p>
<p>​		常量：全大写，多个单词之间使用 _ 来连接  eg : MAX_SIZE</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>​	概念：内存中的一块存储空间，用来保存程序运行时的数据</p>
<p>Java是一种强类型的语言，特点：定义变量必须明确变量的类型，为变量赋值时，赋的值也必须和变量类型匹配</p>
<p>不同类型的差异，体现在分配空间大小不同，存储的数据内容和范围不同</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>​	规定一个变量将占用的空间大小</p>
<p>​	语法： 数据类型 变量；</p>
<p><img src="/javaNote.assets/03.png" alt="image-20230321114307612"></p>
<p>基本数据类型：变量内部保存的就是数据本身<img src="/javaNote.assets/04.png" alt="image-20230321114414491"></p>
<p><img src="/javaNote.assets/05.png" alt="image-20230321154541888"></p>
<p>引用数据类型：变量内部存放的是地址</p>
<p>引用数据类型 变量 &#x3D; 对象；</p>
<h3 id="数字和进制"><a href="#数字和进制" class="headerlink" title="数字和进制"></a>数字和进制</h3><p>数字：统计计量</p>
<p>进制：方便统计记录超大规模的数值</p>
<p>原码 反码 补码</p>
<p>​	正数的原码，反码，补码都相同</p>
<p>​	负数的反码 &#x3D; 数据位取反</p>
<p>​	负数的补码 &#x3D; 反码+1</p>
<p>整数：二进制中为了表示整数和负数，字节空间的首位不再作为数据位，作为符号位   1  -  ,0    +</p>
<h2 id="CoveJavaDay03"><a href="#CoveJavaDay03" class="headerlink" title="CoveJavaDay03"></a>CoveJavaDay03</h2><h3 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h3><ol>
<li>自动类型转换</li>
</ol>
<p>​	   大类型变量 &#x3D; 小类型变量；</p>
<p>​		byte&lt;short&lt;int&lt;long&lt;float&lt;double</p>
<ol start="2">
<li>强制类型转换</li>
</ol>
<p>​	小类型变量 &#x3D; (小类型) 大类型变量；</p>
<p>​	3. 自动类型提升</p>
<p><img src="/javaNote.assets/06.png" alt="image-20230322142255642"></p>
<p>​	String：字符串可以拼接上任意类型数据，拼接后的数据肯定都是字符串String</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ol>
<li><p>数学运算符</p>
<p>+, - , * , &#x2F; , %</p>
</li>
<li><p>赋值运算符</p>
</li>
</ol>
<p>​	&#x3D; , +&#x3D; , -&#x3D; , *&#x3D; , &#x2F;&#x3D; , %&#x3D;</p>
<p>+&#x3D; , -&#x3D; , *&#x3D; , &#x2F;&#x3D; , %&#x3D; 虽然过程中会发生数学运算，但是不会自动类型提升</p>
<p><img src="/javaNote.assets/07.png" alt="image-20230322150803593"></p>
<ol start="5">
<li>自增  自减  运算符</li>
</ol>
<p>​	i++  ++i  i–  –i</p>
<ol start="6">
<li>三目运算符：根据布尔值决定从2个值中取哪个值作为结果</li>
</ol>
<p>​	boolean值 ？值1：值2    真取前假取后</p>
<ol start="7">
<li><p>位运算符(了解)：二进制运算</p>
<p>&amp;,  | ,  ~ ,  ^ ,  &lt;&lt;, &gt;&gt; , &gt;&gt;&gt;</p>
</li>
</ol>
<p><img src="/javaNote.assets/08.png" alt="image-20230322163946524"></p>
<p>运算符的优先级</p>
<p><img src="/javaNote.assets/09.png" alt="image-20230322165241044"></p>
<h3 id="Scanner："><a href="#Scanner：" class="headerlink" title="Scanner："></a>Scanner：</h3><p>​	允许我们的程序读取黑窗口中用户输入的数据</p>
<p>使用步骤：</p>
<p>​	1.创建出Scanner扫描器</p>
<p>​	java.util.Scanner sc &#x3D; new java.util.Scanner(System.in);</p>
<p>​	2.调用它内置的方法完成数据的读取</p>
<p>​		&#x2F;&#x2F;读取整数</p>
<p>​		int i&#x3D; sc.nextInt();</p>
<p>​		&#x2F;&#x2F;读取浮点数</p>
<p>​		double d &#x3D; sc.nextDouble();</p>
<p>​		&#x2F;&#x2F;读取字符串</p>
<p>​		String s1 &#x3D; sc.next();</p>
<p>​		String s2 &#x3D; sc.nextLine();</p>
<p>​		&#x2F;&#x2F;读取一个字符</p>
<p>​		sc.next().chartAT(0);&#x2F;&#x2F;先读取一个字符串，然后返回字符串的第一个字符</p>
<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>​	定义在方法(函数)内部的变量</p>
<pre><code>1. 必须先赋值后使用
2. 作用范围：从定义处起到所在代码块结束，即一个&#123; &#125;
3. 作用范围内变量不能重名
</code></pre>
<h2 id="CoreJavaDay04"><a href="#CoreJavaDay04" class="headerlink" title="CoreJavaDay04"></a>CoreJavaDay04</h2><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="if分支结构"><a href="#if分支结构" class="headerlink" title="if分支结构"></a>if分支结构</h4><h4 id="基本if分支结构"><a href="#基本if分支结构" class="headerlink" title="基本if分支结构"></a>基本if分支结构</h4><p>​	语法：if（布尔表达式）{</p>
<p>​		&#x2F;&#x2F;当布尔表达式位true时，执行</p>
<p>​	}</p>
<p>​	<strong>布尔表达式：结果为boolean 类型的表达式、变量或值</strong></p>
<p>​	执行流程：</p>
<p>​	1.首先获取布尔表达式的结果</p>
<p>​	2.如果布尔表达式的值为true就执行语句体</p>
<p>​	3.如果布尔表达式的值为false就不执行语句体</p>
<p>​	4.继续执行后面的语句内容</p>
<h3 id="if-else分支结构"><a href="#if-else分支结构" class="headerlink" title="if-else分支结构"></a>if-else分支结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：<span class="keyword">if</span>( 布尔表达式 )&#123;  </span><br><span class="line"><span class="comment">//当布尔表达式为true时执行</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123; </span><br><span class="line"> <span class="comment">//当布尔表达式为false时执行   </span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>​	执行流程：</p>
<p>​	1.首先获取布尔表达式的结果</p>
<p>​	2.如果布尔表达式的值为true就执行if代码块</p>
<p>​	3.如果布尔表达式的值为false就执行else代码块</p>
<p>​	4.继续执行后面的语句内容</p>
<h4 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">语法：<span class="keyword">switch</span>(变量)&#123;</span><br><span class="line"><span class="keyword">case</span> 值<span class="number">1</span>： 匹配后，要执行的代码；<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> 值<span class="number">2</span>： 匹配后，要执行的代码；<span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">default</span>: 		所有<span class="keyword">case</span>不匹配输出；<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>break关键字:用于switch语句的流程控制，当程序遇到break关键字时立即跳出switch语句执行后续的代码。</p>
<h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><ol>
<li>while</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">语法：<span class="keyword">while</span>(条件)&#123;<span class="comment">//条件就是boolean值	</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">执行流程：</span><br><span class="line"><span class="number">1.</span>判断循环条件</span><br><span class="line"><span class="number">2.</span>执行循环体中的代码</span><br><span class="line"><span class="number">1</span>~<span class="number">2</span>反复执行，循环条件为 <span class="literal">false</span> 跳出循环结构</span><br></pre></td></tr></table></figure>

<p>​		<strong>循环三要素：</strong></p>
<p>​				<strong>1.定义循环变量：设置循环起点</strong></p>
<p>​				<strong>2.设置循环条件：设置循环终点</strong></p>
<p>​				<strong>3.改变循环变量的值：控制循环步长</strong></p>
<ol start="2">
<li>do while</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">语法：<span class="keyword">do</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">while</span>(条件)；</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>：先判断条件，满足条件再执行循环体  判断n+<span class="number">1</span>  循环体n次</span><br><span class="line"><span class="keyword">do</span> <span class="keyword">while</span>：先执行循环体，再判断条件	循环体n次  判断n次，前n-<span class="number">1</span>次为<span class="literal">true</span></span><br></pre></td></tr></table></figure>



<ol start="3">
<li>for循环</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法：for(条件初始语句；条件终止语句；条件更新语句)&#123;</span><br><span class="line">	//循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="4">
<li>死循环</li>
</ol>
<p>while</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>do while</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">				</span><br><span class="line">&#125;while(true);</span><br></pre></td></tr></table></figure>

<p>​	for</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(;;)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h3><p>break</p>
<p>​	作用：提前终止循环</p>
<p>例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(  <span class="type">int</span> i=<span class="number">1</span>;  i&lt;=<span class="number">10</span>; i++  )&#123;</span><br><span class="line">    System.out.println( i );</span><br><span class="line">    <span class="keyword">if</span>( i == <span class="number">5</span> )  <span class="keyword">break</span>;<span class="comment">//跳出循环  </span></span><br><span class="line">&#125;</span><br><span class="line">输出结果：<span class="number">1</span>/<span class="number">2</span>/<span class="number">3</span>/<span class="number">4</span>/<span class="number">5</span> </span><br></pre></td></tr></table></figure>

<p>continue</p>
<p>​	作用：提前结束本次循环，但不能终止循环</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;  i&lt;=<span class="number">10</span>; i++)&#123;</span><br><span class="line">  <span class="keyword">if</span>( i== <span class="number">5</span>  ) <span class="keyword">continue</span>;<span class="comment">//跳过本次循环，继续下次循环</span></span><br><span class="line">  System.out.println( i );</span><br><span class="line">&#125;</span><br><span class="line">输出结果：<span class="number">1</span>/<span class="number">2</span>/<span class="number">3</span>/<span class="number">4</span>/<span class="number">6</span>/<span class="number">7</span>/<span class="number">8</span>/<span class="number">9</span>/<span class="number">10</span></span><br></pre></td></tr></table></figure>

<h3 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h3><p>​	执行流程：外层循环执行一次，内层循环执行n次</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">3</span>; i++)&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;外层循环：&quot;</span>+i);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=<span class="number">5</span>; j++)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;\t内层循环：&quot;</span>+j);</span><br><span class="line">  &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">外层循环：1</span></span><br><span class="line"><span class="comment">        内层循环：1</span></span><br><span class="line"><span class="comment">        内层循环：2</span></span><br><span class="line"><span class="comment">        内层循环：3</span></span><br><span class="line"><span class="comment">        内层循环：4</span></span><br><span class="line"><span class="comment">        内层循环：5</span></span><br><span class="line"><span class="comment">外层循环：2</span></span><br><span class="line"><span class="comment">        内层循环：1</span></span><br><span class="line"><span class="comment">        内层循环：2</span></span><br><span class="line"><span class="comment">        内层循环：3</span></span><br><span class="line"><span class="comment">        内层循环：4</span></span><br><span class="line"><span class="comment">        内层循环：5</span></span><br><span class="line"><span class="comment">.... */</span>  </span><br></pre></td></tr></table></figure>

<p>应用场景：一个循环的循环体 的一部分又是一个重复的过程。</p>
<h2 id="CoreJavaDay05"><a href="#CoreJavaDay05" class="headerlink" title="CoreJavaDay05"></a>CoreJavaDay05</h2><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>​	表示提供了一个特定功能的代码段</p>
<pre><code>1. 函数就是一段代码
2. 这段代码一定拥有一个特定的功能
</code></pre>
<p> 作用：当程序中需要一个特定的功能，就可以定义出一个函数，在需要使用这个功能的地方，可以调用这个函数，复用特定功能的代码，减少代码的冗余</p>
<p><img src="/javaNote.assets/10.png" alt="image-20230324151701574"></p>
<h3 id="1-函数的定义"><a href="#1-函数的定义" class="headerlink" title="1.函数的定义"></a>1.函数的定义</h3><p>​	函数组成分为2部分：函数的声明和函数的实现(函数体)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回值类型 函数名(形参列表)&#123;</span><br><span class="line">	函数的实现(函数体)：就是函数抽取的功能代码段</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">函数声明三要素：</span><br><span class="line">   函数名：给函数起个名字，合法标识</span><br><span class="line">   形参列表：定义在函数名后的局部变量，用来接收调用者调用函数的数据</span><br><span class="line">   返回值类型：用来声明这个函数执行结束之后，返回一个什么类型的数据</span><br><span class="line">   一旦定义了返回值类型后，就需要在函数中使用<span class="keyword">return</span>返回结果.</span><br><span class="line">   语法：<span class="keyword">return</span> 结果(常量字面值|有值的变量|有值的式子);</span><br><span class="line">   函数一旦执行<span class="keyword">return</span>语句，整个函数调用就会立刻结束</span><br><span class="line">   注意：函数返回值为<span class="keyword">void</span>时，仍可使用<span class="keyword">return</span>，<span class="keyword">return</span>后不跟任何结果</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h3 id="2-函数的调用"><a href="#2-函数的调用" class="headerlink" title="2.函数的调用"></a>2.函数的调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">函数名(值<span class="number">1</span>，值<span class="number">2</span>，...) 调用时()里的值，构成了实参列表</span><br><span class="line">    实参列表和形参列表必须要匹配：数量匹配，类型匹配，顺序匹配</span><br><span class="line">    </span><br><span class="line">    执行流程：在main函数中自上而下的执行代码，遇到函数调用语句时，程序的流程将跳出主函数进入了函数定义处，然后自上而下的执行自定义函数，函数执行完毕程序流程返回到main的函数调用处，并继续向下执行，</span><br><span class="line"></span><br><span class="line">	嵌套函数调用中，最外层的函数最先执行；最内层的函数最先执行完。</span><br></pre></td></tr></table></figure>

<p><img src="/javaNote.assets/13.png" alt="image-20230329211503257"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">栈数据结构：</span><br><span class="line"></span><br><span class="line">	1.可以存储多块数据</span><br><span class="line">	2.存储的时侯，最后存储的数据在最上方；最先存储的数据在最下方		3.FILO : first input last output</span><br></pre></td></tr></table></figure>

<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>​	定义：一个函数中调用自己</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">m();<span class="comment">//递归调用</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">递归的使用前提：当前这个问题的解决方案和问题的规模没有关系</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pbulic <span class="keyword">static</span> 返回值类型 f(<span class="type">int</span> n)&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(最小规模的判断)<span class="keyword">return</span> 值；</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>	f(比n小)+额外的处理；</span><br><span class="line">&#125;</span><br><span class="line">递归要素：</span><br><span class="line">	<span class="number">1.</span>问题必须前提：问题的求解方式与规模无关</span><br><span class="line">	<span class="number">2.</span>大规模问题拆分成小规模</span><br><span class="line">	<span class="number">3.</span>回归条件</span><br></pre></td></tr></table></figure>



<h2 id="CoreDay07"><a href="#CoreDay07" class="headerlink" title="CoreDay07"></a>CoreDay07</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>​	数组：用于一次性的定义多个相同类型的变量，在内存中是连续的存储空间</p>
<p>​	1.有需求需要一下子定义多个变量，数组用来简化多个变量的定义过程</p>
<p>​	2.数组的多个变量在空间上时连续的</p>
<h3 id="数组的定义声明"><a href="#数组的定义声明" class="headerlink" title="数组的定义声明"></a>数组的定义声明</h3><ol>
<li>语法：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">数据类型[] 数组名;</span><br><span class="line"></span><br><span class="line">数据类型 []数组名; </span><br><span class="line"></span><br><span class="line">数据类型 数组名[];</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>手动为数组分配空间：</li>
</ol>
<p>​		数组是由多个内存空间构成， 必须根据需求手动分配空间数量，无法自动分配 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名 = new 数据类型[ 长度 ];</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>使用下标操作数组 </p>
<p>—将数据保存到数组中</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名[下标] = 数据;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>获取数组长度</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数组长度：表示数组的空间数量，数组的容量</span><br><span class="line">数组名.length</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>遍历数组</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;数组名.length; i++)&#123;</span><br><span class="line">  <span class="comment">//使用i变量作为数组下标</span></span><br><span class="line">   数组名[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>创建数组的其他方式</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>数据类型[] 数组名 = <span class="keyword">new</span> 数据类型[ 长度 ];</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>数据类型[] 数组名;</span><br><span class="line">数组名 = <span class="keyword">new</span> 数据类型[]&#123;元素<span class="number">1</span>, 元素<span class="number">2</span>, 元素<span class="number">3.</span>...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>数据类型[] 数组名 = &#123;元素<span class="number">1</span>, 元素<span class="number">2</span>, 元素<span class="number">3.</span>...&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="数组的特性"><a href="#数组的特性" class="headerlink" title="数组的特性"></a>数组的特性</h3><p>​	数组元素的默认值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] is = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">System.out.println( is[<span class="number">0</span>] );<span class="comment">//默认值：0</span></span><br><span class="line">    </span><br><span class="line"><span class="type">double</span>[] ds = <span class="keyword">new</span> <span class="title class_">double</span>[<span class="number">5</span>];</span><br><span class="line">System.out.println( ds[<span class="number">0</span>] );<span class="comment">//默认值：0.0</span></span><br><span class="line">    </span><br><span class="line">String[] str = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">5</span>];</span><br><span class="line">System.out.println( str[<span class="number">0</span>] );<span class="comment">//默认值：null</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/javaNote.assets/12.png" alt="image-20230328165251505"></p>
<h3 id="数组扩容"><a href="#数组扩容" class="headerlink" title="数组扩容"></a>数组扩容</h3><p>​	数组在定义后长度就会确定，随着不断的使用，数组元素使用完毕，就需要扩容数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">数组扩容步骤： </span><br><span class="line">	<span class="number">1.</span>新建一个更大的数组</span><br><span class="line">	<span class="number">2.</span>将旧数组中的元素逐一复制到新数组中</span><br><span class="line">	<span class="number">3.</span>丢弃旧数组，使用新数组</span><br><span class="line">    方式<span class="number">1</span>：</span><br><span class="line">	    <span class="comment">//1.数组扩容</span></span><br><span class="line">        <span class="comment">//新建一个更大的数组</span></span><br><span class="line">        <span class="type">int</span>[] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[arr1.length*<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr1.length ; i++) &#123;</span><br><span class="line">            arr2[i] = arr1[i];<span class="comment">//将旧数组中的元素赋值给新数组</span></span><br><span class="line">        &#125;</span><br><span class="line">        arr1 = arr2;<span class="comment">//丢弃旧数组，使用新数组</span></span><br><span class="line">        System.out.println(arr2.length);</span><br><span class="line"></span><br><span class="line">	方式<span class="number">2</span>：</span><br><span class="line">        <span class="comment">//新建一个更大的数组</span></span><br><span class="line">        <span class="type">int</span>[] arr3 = <span class="keyword">new</span> <span class="title class_">int</span>[arr1.length*<span class="number">2</span>];</span><br><span class="line">		</span><br><span class="line">        System.arraycopy(arr1,<span class="number">0</span>,arr3,<span class="number">0</span>,arr1.length);</span><br><span class="line">	<span class="comment">//参数1：旧数组，参数2：旧数组赋值元素的起始下标</span></span><br><span class="line">	<span class="comment">// 参数3：新数组，参数4：新数组接收旧数组元素值的起始下标</span></span><br><span class="line">	<span class="comment">//参数5：复制的元素个数</span></span><br><span class="line">        arr1 = arr3;<span class="comment">//丢弃旧数组，使用新数组</span></span><br><span class="line">	方式<span class="number">3</span>：</span><br><span class="line">        <span class="comment">//参数1：旧数组，参数2：新数组长度</span></span><br><span class="line">    arr1  = java.util.Arrays.copyOf(arr1,arr1.length*<span class="number">2</span>);</span><br><span class="line">        System.out.println(arr1.length);</span><br></pre></td></tr></table></figure>

<h2 id="CoreJavaDay08"><a href="#CoreJavaDay08" class="headerlink" title="CoreJavaDay08"></a>CoreJavaDay08</h2><h3 id="可变长参数"><a href="#可变长参数" class="headerlink" title="可变长参数"></a>可变长参数</h3><p>​	作用：JDK5.0特性多个相同类型数据作为参数时可自动封装为数组，一定程度上替换数组类型参数</p>
<p>​	作用：JDK5.0特性多个相同类型数据作为参数时可自动封装为数组，一定程度上替换数组类型参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">m1(a);</span><br><span class="line">m1(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>);<span class="comment">//自动封装为数组</span></span><br><span class="line">m1();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">(<span class="type">int</span>... a)</span>&#123;</span><br><span class="line"> <span class="comment">//在m1函数中 使用a 等同于使用数组</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;a.length; i++)&#123;</span><br><span class="line">     System.out.println(a[i]);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 一个方法只允许有一个可变长参数，反例：m1(int... a, int... b)</span><br><span class="line">2. 可变长参数必须为方法的最后一个参数，反例：m1(int... b,int c)</span><br></pre></td></tr></table></figure>

<h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><p>​	根据元素大小，将数组中的元素按照一定顺序重新排序</p>
<p>​	冒泡排序，选择排序，插入排序，希尔排序，归并排序，快速排序</p>
<p>冒泡排序：</p>
<p>​	排序规则：数组两个相邻的元素依次比较，每次将最大的数值放到最后的位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">一共进行 a.length轮</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test1</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        <span class="comment">//冒泡</span></span><br><span class="line">        <span class="comment">// i = 0: i&lt;a.length-1,j&lt;a.length-1-i</span></span><br><span class="line">        <span class="comment">// i = 1: i&lt;a.length,j&lt;a.length-i</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; a.length; i++) &#123;<span class="comment">//控制比较轮数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; a.length-i; j++) &#123;<span class="comment">//控制比较次数</span></span><br><span class="line">                <span class="keyword">if</span> (a[j]&gt;a[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[j+<span class="number">1</span>];</span><br><span class="line">                    a[j+<span class="number">1</span>] = a[j];</span><br><span class="line">                    a[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.print(a[i]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>选择排序</p>
<p>​	排序规则：每一次从无序区元素中选出最小的一个元素，存放在无序区的起始位置，直到全部待排序的元素排完</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;a.length-<span class="number">1</span>; i++)&#123;<span class="comment">//控制比较轮数</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;a.length; j++)&#123;<span class="comment">//控制比较次数</span></span><br><span class="line">    <span class="keyword">if</span>(a[i]&gt;a[j])&#123;</span><br><span class="line">      <span class="comment">//交换位置</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[i];</span><br><span class="line">      a[i] = a[j];</span><br><span class="line">      a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化实现（减少交换次数）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>; i&lt; a.length; i++)&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> i;<span class="comment">//记录最小元素的下标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i; j&lt;a.length; j++)&#123;<span class="comment">//找到最小元素的位置</span></span><br><span class="line">       <span class="keyword">if</span>(a[j]&lt;a[min])&#123;</span><br><span class="line">                min = j;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="comment">//完成交换</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[i];</span><br><span class="line">    a[i] = a[min];</span><br><span class="line">    a[min] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(Arrays.toString(a));</span><br></pre></td></tr></table></figure>

<p>JDK提供的快速排序</p>
<p>​	方法：java.util.Arrays.sort(）</p>
<p>​	特点：由JDK实现的快速排序</p>
<p>​	使用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a = &#123;<span class="number">19</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">4</span>&#125;;</span><br><span class="line">java.util.Arrays.sort( a );<span class="comment">//排序完成</span></span><br><span class="line"><span class="comment">//打印输出</span></span><br><span class="line">System.out.println( java.util.Arrays.toString( a ) );<span class="comment">//1 4 6 8 19</span></span><br></pre></td></tr></table></figure>

<h2 id="CoreJavaDay09"><a href="#CoreJavaDay09" class="headerlink" title="CoreJavaDay09"></a>CoreJavaDay09</h2><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>​	一种编程思想，解题模式</p>
<p>​	面向过程的编程思想：自顶向下，逐步求精，复杂的问题，尝试拆解成多个小问题，习惯性的将复杂问题拆分成多步，按照顺序考虑清楚每一步怎么做，适用于小型复杂问题</p>
<p>面向对象的编程思想是一种解决复杂问题的编程方式</p>
<p>​	不同编程思想看待问题，解决问题的切入点不同</p>
<p>​	不同编程思想并不是互斥的，可以结合使用</p>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>​	一切客观存在的事物</p>
<p>​	对象的组成成分：任何的对象都会有其特征（有什么，即对象的属性）和行为（做什么，即对象的方法）。</p>
<p>面向对象的思想：</p>
<ol>
<li>找解决问题所需要的对象</li>
<li>使用对象（可能使用的是特征，也可是行为，可能是一个对象也可能是多个）完成需求</li>
</ol>
<h4 id="什么是类："><a href="#什么是类：" class="headerlink" title="什么是类："></a>什么是类：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.类是对象的模板，用来描述对象具备的属性和方法。</span><br><span class="line">2.JVM通过类中的信息创建对象（类的实例）</span><br><span class="line">3.类是从多个相同类型对象抽取出的共性和特征，保留所关注的部分。</span><br><span class="line">类是对象的模版，对象是类的实例</span><br></pre></td></tr></table></figure>

<h4 id="类的组成部分"><a href="#类的组成部分" class="headerlink" title="类的组成部分"></a>类的组成部分</h4><p>1.属性&#x2F;成员变量&#x2F;实例变量</p>
<p>​	局部变量：方法内    最多就是当前方法</p>
<p>​	实例变量：类内方法外   整个类内部</p>
<p>​	局部变量与实例变量可以同名，同名时局部变量优先</p>
<p>例：学生类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">  <span class="comment">//属性</span></span><br><span class="line">  String name;  <span class="comment">//姓名</span></span><br><span class="line">  <span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">  <span class="type">boolean</span> sex;  <span class="comment">//性别</span></span><br><span class="line">  <span class="type">double</span> score; <span class="comment">//成绩</span></span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>

<p>2.方法&#x2F;成员方法&#x2F;实例方法</p>
<p>​	方法&#x2F;成员方法&#x2F;实例方法</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数表) 抛出的异常&#123;</span><br><span class="line">  //方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：主函数与Student类无关，不要把主函数写在Student类中，如果需要主函数，我们会将主函数写到另外一个类中</p>
<h4 id="创建对象与使用对象"><a href="#创建对象与使用对象" class="headerlink" title="创建对象与使用对象"></a>创建对象与使用对象</h4><p>1.创建对象</p>
<p>​	语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名();</span><br><span class="line"><span class="number">1.</span>内存中分配对象的存储空间 主要由实例变量构成</span><br><span class="line"><span class="number">2.</span>为属性赋默认值</span><br><span class="line"><span class="number">3</span>，再为属性赋初始值（如果有）</span><br><span class="line"><span class="number">4.</span>执行构造方法中的代码</span><br></pre></td></tr></table></figure>

<p> 2.为引用赋值</p>
<p>​	在Java中每定义一个类，就多了一种自定义的数据类型，可以将对象保存在同类型引用中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();<span class="comment">//创建Student对象并为 stu1引用赋值</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">stu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();<span class="comment">//创建Student对象并为 stu2引用赋值</span></span><br><span class="line"><span class="type">Teacher</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();<span class="comment">//创建Teacher对象并为 t1 引用赋值</span></span><br></pre></td></tr></table></figure>

<p> 3.对象是独立的</p>
<p>​	模板只有一个，通过模板可以创建多个对象，每个对象都拥有自己独立的内存空间</p>
<p><img src="/javaNote.assets/14.png" alt="image-20230330150151471"></p>
<h4 id="调用对象中的方法"><a href="#调用对象中的方法" class="headerlink" title="调用对象中的方法"></a>调用对象中的方法</h4><p>​	语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象名.方法名( 实参 );</span><br></pre></td></tr></table></figure>



<h4 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h4><p>​	在一个类中可以定义多个方法名相同，但形参列表必须不同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">注意事项：</span><br><span class="line">	尽量在同类操作有不同的参数时，使用重载 ，对返回值类型没有要求，相同与否不影响重载，</span><br><span class="line">	参数列表不同指的是数量不同，类型不同，顺序不同，但是形参名不同不算</span><br><span class="line">调用时的匹配过程：</span><br><span class="line">  1.会根据实参的类型，匹配相同类型形参列表的方法</span><br><span class="line">  2.如果上一步匹配不到，不会立刻报错，而是采用就近向上匹配原则</span><br><span class="line">  3.如果经过就近匹配原则后还不能找到对应形参列表的方法，则会报错</span><br><span class="line">  注意：就近向上匹配过程中，可能会出现多个方法都能就近匹配的情况，此时编译器无法抉择，也会报错</span><br></pre></td></tr></table></figure>

<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>​	作用：通常用于在创建对象的同时对对象进行一些初始化工作，比如为属性赋值</p>
<p>​		构造方法也支持方法重载</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">特殊之处：</span><br><span class="line"> <span class="number">1.</span>构造方法名固定位类名</span><br><span class="line"> <span class="number">2.</span>没有返回值类型</span><br><span class="line"> <span class="number">3.</span>不能手动调用（调用方式和普通方法不同）</span><br><span class="line"> 	 普通方法：对象名.方法名( 实参 )</span><br><span class="line"> 	 构造方法：只能和 <span class="keyword">new</span> 结合使用，在创建对象的过程中调用执行</span><br><span class="line"> 	 <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();<span class="comment">//在创建对象的过程中调用</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="CoreJavaDay10"><a href="#CoreJavaDay10" class="headerlink" title="CoreJavaDay10"></a>CoreJavaDay10</h2><h3 id="数据传递规则"><a href="#数据传递规则" class="headerlink" title="数据传递规则"></a>数据传递规则</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 基本类型传值，两者之间任何一方更改，不影响另一方。</span><br><span class="line">2. 引用类型（对象、数组）传地址（形参和实参会指向同一对象），两者之间任何一方更改，影响另一方</span><br></pre></td></tr></table></figure>

<p>注意：打印引用，可以获得对象所在内存地址，必须通过引用获取地址中存储的数据</p>
<h3 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h3><p>​	运行时由JVM自动创建的变量，表示当前对象引用</p>
<p>this的两种用法：</p>
<p>​	this.属性名   区分同名的的局部变量</p>
<p>​	this(…) 用在构造方法中嵌套调用其它的构造方法</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyClass method &quot;</span>+ <span class="built_in">this</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">MyClass</span> <span class="variable">mc1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">mc1.method();<span class="comment">//mc1调用method, this就是mc1</span></span><br><span class="line"></span><br><span class="line"><span class="type">MyClass</span> <span class="variable">mc2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">mc2.method();<span class="comment">//mc2调用method, this就是mc2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="使用this-访问属性或方法"><a href="#使用this-访问属性或方法" class="headerlink" title="使用this.访问属性或方法"></a>使用this.访问属性或方法</h4><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">访问属性：this.属性名;</span><br><span class="line">访问方法：this.方法名(实参);</span><br></pre></td></tr></table></figure>

<p>可用于区分局部变量与实例变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line">    <span class="type">int</span> a ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">        System.out.println( a );<span class="comment">//打印局部变量 a</span></span><br><span class="line">        System.out.println( <span class="built_in">this</span>.a );<span class="comment">//打印属性 a</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用this-调用本类其他构造方法"><a href="#使用this-调用本类其他构造方法" class="headerlink" title="使用this( )调用本类其他构造方法"></a>使用this( )调用本类其他构造方法</h4><p>​	语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">必须在构造方法的第一行</span><br><span class="line">this( );//调用本类无参构造</span><br><span class="line">this( 实参 );//调用本类有参构造</span><br></pre></td></tr></table></figure>

<p>作用：提高构造方法的重用性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">30</span>);;<span class="comment">//无参构造里嵌套调用有参构造</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：this() 只能定义在构造方法的第一行</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>概念：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.封装（Encapsulation）</span><br><span class="line">2.尽可能隐藏对象的内部实现细节，控制用户对对象的修改和访问权限，保障内部属性的安全。</span><br></pre></td></tr></table></figure>

<h4 id="private修饰符"><a href="#private修饰符" class="headerlink" title="private修饰符"></a>private修饰符</h4><p>​	修饰符：修饰程序中的各个组件，被修饰的组件拥有不同的特点与权限</p>
<p>priavte修饰符的特点:\</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. private表示私有的，可以修饰属性、方法。</span><br><span class="line">2. 被修饰的组件只能在本类中使用，对外不可见。</span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> b;<span class="comment">//被private修饰，只能在本类中使用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ma</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mb</span><span class="params">()</span>&#123;&#125;<span class="comment">//被private修饰，只能在本类中使用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestMyClass</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">mc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        mc.a = <span class="number">10</span>;</span><br><span class="line">        mc.b = <span class="number">20</span>;<span class="comment">//编译错误，无权访问</span></span><br><span class="line">        mc.ma();</span><br><span class="line">        mc.mb();<span class="comment">//编译错误，无权访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="私有化属性、方法"><a href="#私有化属性、方法" class="headerlink" title="私有化属性、方法"></a>私有化属性、方法</h4><p>使用private修饰属性，将属性或方法私有化，控制访问权限</p>
<h4 id="提供访问或修改私有成员的途径（get-set方法）"><a href="#提供访问或修改私有成员的途径（get-set方法）" class="headerlink" title="提供访问或修改私有成员的途径（get&#x2F;set方法）"></a>提供访问或修改私有成员的途径（get&#x2F;set方法）</h4><p>语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">get方法</span><br><span class="line"><span class="keyword">public</span> 返回值类型 get属性名()&#123;</span><br><span class="line">    <span class="keyword">return</span> 属性;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回值类型与属性类型一致</span></span><br><span class="line"><span class="comment">//方法名中的属性名首字母大写</span></span><br><span class="line">set方法:</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> set属性名(形参类型 形参名)&#123;</span><br><span class="line">    <span class="built_in">this</span>.属性名 = 形参名;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//形参类型与属性类型一致</span></span><br><span class="line"><span class="comment">//形参名与属性名一致</span></span><br><span class="line"><span class="comment">//方法名中的属性名首字母大写</span></span><br></pre></td></tr></table></figure>

<p>​	封装的意义：尽可能隐藏对象的内部实现细节，控制用户对对象的修改和访问权限，保障内部属性的安全</p>
<p>封装的实现方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 属性私有</span><br><span class="line">2. 根据需要提供公开的get或set方法，无特殊情况两个方法都要提供。</span><br></pre></td></tr></table></figure>

<h2 id="CoreJavaDay11"><a href="#CoreJavaDay11" class="headerlink" title="CoreJavaDay11"></a>CoreJavaDay11</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>​	子类（派生类）——继承于—–&gt;  父类（超类）</p>
<p>​	在面向对象的开发设计中，如果发现两个类满足 is a关系，这两个类就应该体现继承关系</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal eat()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal sleep()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类继承了父类中的属性和方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="访问权限修饰符"><a href="#访问权限修饰符" class="headerlink" title="访问权限修饰符"></a>访问权限修饰符</h3><p>​	作用：控制组件可见（可用）范围</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>本类</th>
<th>同包</th>
<th>其他包子类</th>
<th>任意位置</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>(default)</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<p>​	当组件前没有访问权限修饰符时，默认为（default）修饰</p>
<p>private ：严格受到边界的保护，只能在对象边界()类内部才能访问</p>
<p>public：不再受边界的保护 ，任意位置访问到，一定能被子类继承</p>
<p>(不加任何修饰符) default：同包下的类可以访问，同包下的类可以继承，不同包的子类不能继承</p>
<p>protected：受保护，同包下任意类以及不同包子类中，一定能被继承到</p>
<p><strong>额外注意</strong>：默认的类只能在同包下定义子类，公开类可以在任意位置定义子类</p>
<h3 id="方法的覆盖（方法重写）"><a href="#方法的覆盖（方法重写）" class="headerlink" title="方法的覆盖（方法重写）"></a>方法的覆盖（方法重写）</h3><p>使用场景：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当父类的方法不再适用于子类或无法满足子类需求时，可以覆盖掉父类的方法</span><br><span class="line">再对其进行调用时，会调用覆盖后的方法</span><br></pre></td></tr></table></figure>

<p>语法：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">返回值类型、方法名、参数表相同，修饰符相同或更宽</span><br><span class="line">默认---&gt; protected ---&gt; public</span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestOverride</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">    <span class="type">Sub</span> <span class="variable">sub</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">    sub.m1();<span class="comment">//调用子类覆盖后的m1方法 打印 m1 in sub</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Super</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;m1 in super&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Super</span>&#123;</span><br><span class="line">  <span class="comment">//覆盖：访问权限修饰符相同或更宽 返回值类型、方法名、参数表相同</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;m1 in sub&quot;</span>);  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法覆盖和方法重载的区别：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 方法覆盖发生在父子类之间，语法要求：访问权限修饰符相同或更宽 返回值类型、方法名、参数表相同。</span><br><span class="line">2. 方法重载可以在本类中，也可以在父子类间进行重载，语法要求：方法名相同、参数表不同，其他无要求。</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：覆盖的基础是要继承到父类的方法，如果父类的方法是私有的，就不是覆盖，构造方法不能被继承，自然也不能被覆盖。</p>
<h3 id="对象创建的过程"><a href="#对象创建的过程" class="headerlink" title="对象创建的过程"></a>对象创建的过程</h3><p><strong>没继承</strong></p>
<ol>
<li><p>为对象的实例变量分配空间</p>
</li>
<li><p>赋值：默认值或者初始值</p>
</li>
<li><p>执行本类构造方法的代码</p>
</li>
</ol>
<p><strong>有继承</strong></p>
<p>​	循先父后子的顺序，如果父类还有父类，那么就要先初始化父类的父类以此类推..</p>
<ol>
<li><p>为对象的实例变量（子类和父类）分配空间</p>
</li>
<li><p>为父类属性赋值：默认值或者初始值</p>
</li>
<li><p>执行父类的构造方法</p>
</li>
<li><p>为子类的属性赋值：默认值或者初始值</p>
</li>
<li><p>执行子类构造方法的代码</p>
</li>
</ol>
<h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p>​	含义：super表示父类对象的引用</p>
<p>​	用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.super.属性 ，super.方法(...) 明确在子类中要使用的是父类的属性或方法</span><br><span class="line"></span><br><span class="line">使用前提：属性和方法能被当前子类继承到</span><br><span class="line"></span><br><span class="line">2.super(...)  用在子类构造方法中，指明对象创建过程中调用哪个父类的哪个构造方法，有继承关系的对象创建流程：沿着</span><br></pre></td></tr></table></figure>

<p>​	访问属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Super</span>&#123;</span><br><span class="line">  <span class="type">int</span> a=<span class="number">10</span>;<span class="comment">//父类属性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Super</span>&#123;</span><br><span class="line">  <span class="type">int</span> a=<span class="number">20</span>;<span class="comment">//子类属性，属性遮盖</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">30</span>;<span class="comment">//局部变量</span></span><br><span class="line">    System.out.println( a );      <span class="comment">//打印局部变量a</span></span><br><span class="line">    System.out.println( <span class="built_in">this</span>.a );  <span class="comment">//打印本类属性a</span></span><br><span class="line">    System.out.println( <span class="built_in">super</span>.a );  <span class="comment">//打印父类属性a</span></span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问被覆盖的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Super</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;m1 in super&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Super</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;<span class="comment">//覆盖父类的方法</span></span><br><span class="line">    <span class="built_in">super</span>.m1();<span class="comment">//调用父类中的m2方法</span></span><br><span class="line">    System.out.println(<span class="string">&quot;m1 in sub&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	使用super() 明确自动创建父类对象时，所使用的构造方法，默认使用父类的无参构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">  String name;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name, <span class="type">int</span> age)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>()&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">    <span class="comment">//使用父类有参构造为属性赋值</span></span><br><span class="line">    <span class="built_in">super</span>(name,age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. super()只能定义在构造方法的第一行</span><br><span class="line">2. 每个构造方法第一行代码隐式包含super() 表示创建对象时默认使用父类的无参构造方法</span><br><span class="line">3. 定义类时通常会为该类添加两个构造方法，有参构造方法为属性赋值，无参构造方法用于子类创建对象时使用，这是一种约定俗成的编程习惯</span><br></pre></td></tr></table></figure>

<h2 id="CoreJavaDay12"><a href="#CoreJavaDay12" class="headerlink" title="CoreJavaDay12"></a>CoreJavaDay12</h2><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>​	前提是继承，必须出现父子继承关系的代码，继承关系必须合理</p>
<p>多态：3句话3个体现</p>
<p>​	1.子类对象可以看做父类对象，因此 	Animal a &#x3D; new Dog();</p>
<p>​	2.通过父类引用只能调用父类声明的方法，不能调用子类独有的方法</p>
<p>​	3.调用的方法实际执行效果只看子类类型（对象实际类型），执行重写后的实现</p>
<p>概念：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">多态（Polymorphism）</span><br><span class="line">使用父类引用指向不同的子类对象，不同的子类对象最终会呈现不同的”形态特点”</span><br></pre></td></tr></table></figure>

<p>多态的体现（语法）：使用父类引用存储子类对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;&#125;<span class="comment">//Dog is a Animal</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;&#125;<span class="comment">//Cat is a Animal</span></span><br><span class="line"><span class="comment">//父类引用指向子类对象，子类对象不会改变</span></span><br><span class="line"><span class="type">Animal</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();<span class="comment">//多态的体现，父类引用指向子类对象</span></span><br><span class="line"><span class="type">Animal</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();<span class="comment">//多态的体现，对象的实际类型不会改变</span></span><br><span class="line">System.out.println(dog.getClass());<span class="comment">//Dog类型</span></span><br><span class="line">System.out.println(a1.getClass());<span class="comment">//Dog类型</span></span><br></pre></td></tr></table></figure>

<p><strong>特点</strong></p>
<p>1.子类对象类型始终不变</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pet</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Dog</span> <span class="variable">d</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"><span class="comment">//Pet p  = d;//将Dog对象存储到Pet引用中</span></span><br><span class="line"><span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> d;<span class="comment">//将Dog对象存储到Animal引用中</span></span><br><span class="line"></span><br><span class="line">System.out.println( d );</span><br><span class="line"><span class="comment">//System.out.println( p );</span></span><br><span class="line">System.out.println( a );</span><br></pre></td></tr></table></figure>

<p>2.编译时，只能调用引用类型中声明的方法</p>
<p>​	由于多态的存在，只有在程序运行时才能知道父类中存储的对象是什么类型，而编译器无法得知，编译器只能确定引用中存储的对象是子类，而子类一定会具备父类中的方法，因此只能调用引用类型（父类）中声明的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.运行时，如果子类覆盖了父类中的方法，则执行子类中覆盖的方法</p>
<p>​	调用方法时，调用的是对象中的方法	</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">a1.eat();  <span class="comment">//运行时，调用子类覆盖后的方法</span></span><br><span class="line">a1.sleep(); </span><br><span class="line"><span class="comment">//运行结果：狗啃骨头</span></span><br><span class="line"><span class="comment">//       Animal sleep</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Animal eat&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Animal sleep&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;狗啃骨头~~&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="instanceof关键字"><a href="#instanceof关键字" class="headerlink" title="instanceof关键字"></a>instanceof关键字</h3><p>​	作用：判断引用中所存储的对象是否与某种类型兼容</p>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ref <span class="keyword">instanceof</span> cls </span><br></pre></td></tr></table></figure>

<p>r	ef为某个对象的引用，cls为类名，如果引用中所存储的对象与cls兼容则结果为true，反之为false</p>
<p>应用场景：用于 查找某种类型的对象 或 向下转型时使用instanceof进行判断，避免出现类型转换异常</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> ....;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断a引用中存储的对象是否为Dog类型</span></span><br><span class="line"><span class="keyword">if</span>( a <span class="keyword">instanceof</span> Dog )&#123;</span><br><span class="line">  System.out.println( <span class="string">&quot;Dog in a&quot;</span> );</span><br><span class="line">  <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> (Dog)a;<span class="comment">//强制类型转换</span></span><br><span class="line">  d.shout();<span class="comment">//调用Dog类中的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多态的好处：</p>
<p>​	使用多态屏蔽子类之间的差异，使程序更加灵活</p>
<p>应用场景：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.形参上：形参定义的是父类类型形参，以后传参可以是父类及其子类对象的地址</span><br><span class="line">  返回值类型上：意味着方法的返回值是父类类型，方法执行后可以返回父类类型对象和子类类型的对象</span><br><span class="line">2.数组上：定义一个父类类型的数组，数组的每一个元素就是一个引用，可以指向不同的子类对象</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="CoreJavaDay13"><a href="#CoreJavaDay13" class="headerlink" title="CoreJavaDay13"></a>CoreJavaDay13</h2><h3 id="关键词abstract"><a href="#关键词abstract" class="headerlink" title="关键词abstract"></a>关键词abstract</h3><p>概念：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">abstract （抽象的）</span><br><span class="line">可以修饰类、方法，使程序设计的更加合理</span><br><span class="line">抽象类的作用：1.可以更合理的表现面向对象</span><br><span class="line">			2.强制多态  可以声明方法指向子类对象</span><br></pre></td></tr></table></figure>

<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a><strong>抽象类</strong></h4><p>概念：被abstract修饰的类称为抽象类、</p>
<p>特点：抽象类只能声明引用不能创建对象</p>
<h4 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a><strong>抽象方法</strong></h4><p>概念：被abstract修饰的方法，称之为抽象方法</p>
<p>特点：</p>
<p>​	1.抽象方法只能有声明，不能有实现</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>;<span class="comment">//抽象方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>;<span class="comment">//抽象方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span>&#123;<span class="comment">//非抽象方法</span></span><br><span class="line">   <span class="comment">//方法的实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	2.抽象方法只能定义在抽象类中</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;<span class="comment">//抽象类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>;<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	3.当父类存在抽象方法时，子类必须覆盖父类的抽象方法，否则子类还是抽象类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">例：子类没有覆盖父类的抽象方法</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Super</span>&#123;<span class="comment">//抽象类</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>;<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Super</span>&#123;<span class="comment">//因为没有覆盖MyClass中的抽象方法，所以子类必须也是抽象类</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">例：子类覆盖父类的抽象方法</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Super</span>&#123;<span class="comment">//抽象类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>;<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Super</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;<span class="comment">//覆盖父类中的抽象方法 添加实现&#123;  &#125;</span></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	子类覆盖父类的抽象方法，并添加方法的实现{  }，这种特殊的覆盖语法称之为实现</p>
<p><strong>注意</strong>：由于继承关系可以多级继承，当继承到多个抽象方法时，子类如果不想成为抽象类，必须都予以实现</p>
<h3 id="关键词static"><a href="#关键词static" class="headerlink" title="关键词static"></a>关键词static</h3><p>概念：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static（静态）</span><br><span class="line">可以修饰类、属性、方法、动态初始化代码块、import</span><br><span class="line">被static修饰的方法叫静态方法，没有被static修饰的方法叫实例方法</span><br></pre></td></tr></table></figure>

<h4 id="静态属性（类变量）"><a href="#静态属性（类变量）" class="headerlink" title="静态属性（类变量）"></a>静态属性（类变量）</h4><p>概念：被static修饰的属性，称之为静态属性或类变量</p>
<p>特点：静态属性与对象无关，有独立的存储区域，可以通过类名直接访问，可以被所有对象共享 例</p>
<p><img src="/javaNote.assets/14.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;<span class="comment">//一般属性</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> b;<span class="comment">//静态属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为静态属性赋值</span></span><br><span class="line">MyClass.a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态属性被所有对象共享</span></span><br><span class="line"><span class="type">MyClass</span> <span class="variable">mc1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>()</span><br><span class="line">System.out.println( mc1.a );<span class="comment">//10</span></span><br><span class="line"></span><br><span class="line"><span class="type">MyClass</span> <span class="variable">mc2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">System.out.println( mc2.a );<span class="comment">//10</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>： 静态属性虽然可以通过引用名.的方式使用，但是极度不推荐，容易与一般属性造成混淆</p>
<p><strong>静态方法</strong></p>
<p>概念：被static修饰的方法称为静态方法</p>
<p>特点：</p>
<p>​	1.静态方法与对象无关，可以使用类名直接调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Super</span>&#123;</span><br><span class="line">  <span class="comment">//静态方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用Super类中的静态方法</span></span><br><span class="line">Super.m1();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	2.静态方法与对象无关，因此不能使用非静态的成员（成员变量、成员方法），因为它们需要创建对象后才能使用</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Super</span>&#123;</span><br><span class="line">  <span class="type">int</span> a; <span class="comment">//一般属性</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123; &#125;<span class="comment">//一般方法</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;<span class="comment">//静态方法</span></span><br><span class="line">    System.out.println( a );<span class="comment">//错误：静态方法中不能访问非静态成员</span></span><br><span class="line">    m1();<span class="comment">//错误：静态方法中不能访问非静态成员</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	3.静态方法可以被继承</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Super</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Super</span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用父类中的m1方法</span></span><br><span class="line">Sub.m1();<span class="comment">//可以从父类中继承静态方法m1();</span></span><br></pre></td></tr></table></figure>

<p>​	4.静态方法只能被静态方法所覆盖</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Super</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Super</span>&#123; </span><br><span class="line">  <span class="comment">//覆盖父类中的静态方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sub.m1();<span class="comment">//调用覆盖后的m1方法</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	5.静态方法在使用时没有多态</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Super</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Super</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Super</span> <span class="variable">sup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();<span class="comment">//多态语法</span></span><br><span class="line">sup.m1();<span class="comment">//编译后----&gt;Super.m1();引用名替换为引用类型</span></span><br></pre></td></tr></table></figure>

<p><strong>小结</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static 修饰属性：静态属性，所有此类对象共享，可以直接通过类名访问</span><br><span class="line">static 修饰方法：静态方法，可以直接通过类名方法，静态方法与对象无关，不能使用非静态属性或方法，也不可使用 this 或 super 关键字</span><br></pre></td></tr></table></figure>

<h4 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h4><p>概念：JVM将硬盘中的.class文件加载到内存中的一种行为</p>
<p><img src="/javaNote.assets/15.png"></p>
<p>类加载的时机与过程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 当虚拟机第一次遇到某个类时（new对象、调用静态成员、使用子类）某个类时，需要通过CLASSPATH查找该类的 .class 文件。</span><br><span class="line">2. 将.class文件中保存的类的描述信息（属性、方法..等等）加载到内存中进行保存。</span><br><span class="line">3. 加载时会初始化该类的必要信息，初始化静态属性、静态方法，调用静态初始化代码块等。</span><br><span class="line">4. 类加载只会执行一次。</span><br></pre></td></tr></table></figure>

<p>例：加载时机</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line">   <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">   <span class="comment">//静态初始化代码块，类加载时执行</span></span><br><span class="line">   <span class="keyword">static</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;类加载...&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载时机 1：访问静态成员</span></span><br><span class="line">MyClass.a; </span><br><span class="line"></span><br><span class="line"><span class="comment">//加载时机 2：创建对象</span></span><br><span class="line"><span class="type">MyClass</span> <span class="variable">mc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载时机 3：创建子类对象或加载子类时</span></span><br><span class="line">Sub.a;</span><br><span class="line"><span class="type">Sub</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：只声明引用，不会进行类加载。</p>
<h4 id="静态初始化代码块"><a href="#静态初始化代码块" class="headerlink" title="静态初始化代码块"></a>静态初始化代码块</h4><p>概念：使用static修饰的动态初始化代码块*，称为静态初始化代码块</p>
<p>特点：在类加载时执行一次</p>
<p>作用：用于初始化静态属性，执行在整个系统中只需要运行一次的代码（加载资源、构建容器等） </p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">static</span>&#123;<span class="comment">//静态初始化代码块</span></span><br><span class="line">        a = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h4><p>过程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 如果有需要先加载父类</span><br><span class="line">2. 初始化静态属性</span><br><span class="line">3. 按照顺序初始化静态属性，或执行静态代码块</span><br></pre></td></tr></table></figure>

<p>验证例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Super</span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;static in Super&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Super</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init Super&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Super</span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;static in Sub&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Sub</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init Sub&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一次创建子类对象时输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> in Super</span><br><span class="line"><span class="keyword">static</span> in Sub</span><br><span class="line">init Super</span><br><span class="line">init Sub</span><br></pre></td></tr></table></figure>

<h4 id="静态引入"><a href="#静态引入" class="headerlink" title="静态引入"></a>静态引入</h4><p>使用import static 引入类中的静态资源</p>
<p>例：引入java.lang.System中的静态属性out</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态引入</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="comment">//使用System.out进行输出时，不必再加入类名</span></span><br><span class="line">         out.print(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="static小结"><a href="#static小结" class="headerlink" title="static小结"></a>static小结</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. static 修饰的属性为`静态属性`（类变量）每个对象共用一份，可以使用 类名.属性名的方式直接访问</span><br><span class="line">2. static 修饰的方法为`静态方法`（类方法）每个对象共用一份，可以使用 类名.属性名的方式直接访问</span><br><span class="line">3. static 修饰的初始化代码框为`静态初始化代码框`，主要用于在类加载时对静态变量进行初始化工作</span><br><span class="line">4. import static 称为`静态引入`可以`引入静态资源，使用时不必明确类名</span><br></pre></td></tr></table></figure>

<h3 id="关键词final"><a href="#关键词final" class="headerlink" title="关键词final"></a>关键词final</h3><p>概念：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final （最终的）</span><br><span class="line">可以修饰 变量（局部变量、属性）、方法、类</span><br></pre></td></tr></table></figure>

<h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>概念：被final修饰的变量称为常量</p>
<p>修饰局部变量特点：只能赋值一次，不可修改</p>
<p> 例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//只能赋值一次</span></span><br><span class="line">a = <span class="number">10</span>;<span class="comment">//编译错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span>[] as = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];<span class="comment">//只能赋值一次</span></span><br><span class="line">as = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];<span class="comment">//编译错误</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>修饰局部变量特点：只能赋值一次，不可修改</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">int</span> a;<span class="comment">//编译错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化方式</p>
<p>​	1.直接初始化</p>
<p>​	例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	由于被final修饰的属性不可变，所以为了避免内存空间的浪费，该属性还应该被static修饰</p>
<p>​	2.初始化代码块| 静态块初始化代码块</p>
<p>​	例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> a;</span><br><span class="line">    &#123;</span><br><span class="line">      a = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	3.构造方法赋值</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> a;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">()</span>&#123;</span><br><span class="line">        a = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：由于final修饰的属性必须保证能够被初始化，所以每个构造方法都要为属性初始化</p>
<h4 id="最终方法"><a href="#最终方法" class="headerlink" title="最终方法"></a>最终方法</h4><p>概念：被final修饰的方法，称为最终方法</p>
<p>特点：此方法不能被子类覆盖，可以被子类继承</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Super</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Super</span>&#123;</span><br><span class="line">  <span class="comment">//编译错误：父类final修饰的方法不能被覆盖</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="最终类"><a href="#最终类" class="headerlink" title="最终类"></a>最终类</h4><p>概念：被final修饰的类，称为最终类</p>
<p>特点：不能被继承</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Super</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译错误：父类为最终类，不能继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Super</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/javaNote.assets/16.png"></p>
<h4 id="修饰符组合"><a href="#修饰符组合" class="headerlink" title="修饰符组合"></a>修饰符组合</h4><p>规则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. static、final与abstract不能连用，因为abstract为抽象的，修饰类必须由子类继承才能使用，修饰方法必须由子类覆盖才能使用，不能调用abstract修饰的方法等特点，与static final 意义冲突。</span><br><span class="line">2. private 与 abstract不能一起修饰方法，否则该方法将无法被覆盖</span><br><span class="line">3. static与final可以连用，意义不冲突</span><br><span class="line">4. 在定义常量时通常使用public static final 进行声明，称为公开静态常量</span><br></pre></td></tr></table></figure>

<p><img src="/javaNote.assets/17.png"></p>
<h2 id="CoreJavaDay14"><a href="#CoreJavaDay14" class="headerlink" title="CoreJavaDay14"></a>CoreJavaDay14</h2><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>概念：接口是特殊的抽象类,约束一个类所具备的额外能力，降低程序间的耦合</p>
<p>接口的独有语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.接口中的方法默认是公开抽象方法</span><br><span class="line"></span><br><span class="line">2.接口中定义的属性必须是公开静态常量</span><br><span class="line"></span><br><span class="line">3.接口中没有构造方法，抽象父类可以有</span><br><span class="line"></span><br><span class="line">4.接口与接口之间可以多继承，类和类之间只有单继承</span><br><span class="line">	接口会从父接口中继承到抽象方法，那么在实现子接口的时候就需要将所有的抽象方法都实现，否则实现类就需要成为抽象类</span><br><span class="line"></span><br><span class="line">5.一个类只能继承一个类，但能同时实现多个接口</span><br><span class="line">	一个类继承父类的同时可以实现多个接口，注意继承在前实现在后</span><br></pre></td></tr></table></figure>

<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><ol>
<li>语法：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface 接口名&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">例：</span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">IA</span>&#123;<span class="comment">//接口名</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>不能创建对象</li>
</ol>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IA</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IA ia;</span><br><span class="line">ia = <span class="keyword">new</span> <span class="title class_">IA</span>();<span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure>

<p>3.接口中的属性</p>
<p>特点：接口中的属性均为公开静态常量，隐式使用 public static final 修饰</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IA</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">A</span>  <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">B</span> <span class="operator">=</span> <span class="number">20</span>;<span class="comment">//隐式包含 public static final </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IA.A<span class="comment">//可以直接访问A</span></span><br><span class="line">IA.B<span class="comment">//可以直接访问B</span></span><br></pre></td></tr></table></figure>

<p>4.接口中的方法</p>
<p>特点：接口中的方法默认为公开抽象方法，隐式使用 public abstract 修饰</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>;<span class="comment">//隐式包含 public abstract</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.接口中的非抽象方法与静态方法</p>
<p>特点：JDK8或以上接口中可以定义非抽象方法与静态方法，非抽象方法需要使用default修饰符修饰</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IA</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="comment">//静态方法</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="comment">//一般方法（非抽象方法）</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：接口中不能定义构造方法</p>
<h4 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h4><p>1.接口与接口之间多继承</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IA</span>&#123; &#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IB</span>&#123;&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IC</span>&#123;&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ID</span> <span class="keyword">extends</span> <span class="title class_">IA</span>,IB,IC&#123; &#125;<span class="comment">//同时继承IA、IB、IC接口</span></span><br></pre></td></tr></table></figure>

<p>父接口中定义的属性或方法也会向下传递</p>
<p>2.接口与接口之间多实现</p>
<p>子类可以通过“实现“的方式继承接口</p>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class 类名 implements 接口<span class="number">1</span> , 接口<span class="number">2.</span>..&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IA</span>&#123;&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IB</span>&#123;&#125;</span><br><span class="line"><span class="comment">//实现IA,IB两个接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">IA</span>,IB&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>实现接口就要实现接口中所有的抽象方法，否则子类应为抽象类</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IA</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IB</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass1</span> <span class="keyword">implements</span> <span class="title class_">IA</span>,IB&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;&#125;<span class="comment">//实现IA接口中的m1方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;&#125;<span class="comment">//实现IB接口中的m2方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由于没有实现IB接口中的m2方法，因此MyClass2应为抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> MyClass2 <span class="keyword">implements</span> <span class="title class_">IA</span>,IB&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;&#125;<span class="comment">//实现IA接口中的m1方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：实现接口中的方法，访问权限修饰符必须为public ,因为接口中的抽象方法默认被public 修饰</p>
<p>​	可以继承一个类并实现多个接口，接口也属于该类的一种“父类型”， 支持多态</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Super</span>&#123;&#125;<span class="comment">//父类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IA</span>&#123;&#125;<span class="comment">//IA接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IB</span>&#123;&#125;<span class="comment">//IB接口</span></span><br><span class="line"><span class="comment">//Sub继承Super类，实现IA，IB两个接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Super</span> <span class="keyword">implements</span> <span class="title class_">IA</span>,IB&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以用父类型引用存储子类对象</span></span><br><span class="line"><span class="type">Super</span> <span class="variable">sup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line"><span class="type">IA</span> <span class="variable">ia</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line"><span class="type">IB</span> <span class="variable">ib</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以使用instanceof判断类型是否兼容</span></span><br><span class="line"><span class="type">Super</span> <span class="variable">sup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">System.out.println( sup <span class="keyword">instanceof</span> Sub );<span class="comment">//true</span></span><br><span class="line">System.out.println( sup <span class="keyword">instanceof</span> Super);<span class="comment">//true</span></span><br><span class="line">System.out.println( sup <span class="keyword">instanceof</span> IA);<span class="comment">//true</span></span><br><span class="line">System.out.println( sup <span class="keyword">instanceof</span> IB);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>​	访问接口中被覆盖的default方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Super</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;&#125;<span class="comment">//抽象方法</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;&#125;<span class="comment">//非抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">implements</span> <span class="title class_">Super</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line">       Super.<span class="built_in">super</span>.m2();<span class="comment">//访问父接口中的m2方法</span></span><br><span class="line">       System.out.println(<span class="string">&quot;Sub.m2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="与抽象类的异"><a href="#与抽象类的异" class="headerlink" title="与抽象类的异"></a>与抽象类的异</h4><p>相同点：可以作为引用，不能创建对象；可以使用多态</p>
<p>不同点：</p>
<table>
<thead>
<tr>
<th>特点</th>
<th>抽象类</th>
<th>接口</th>
</tr>
</thead>
<tbody><tr>
<td>关键字</td>
<td>abstract class</td>
<td>interface</td>
</tr>
<tr>
<td>属性</td>
<td>无要求</td>
<td>默认为公开静态常量<br>隐式使用 <code>public static final</code></td>
</tr>
<tr>
<td>方法</td>
<td>无要求</td>
<td>默认为公开抽象方法<br>隐式使用 <code>public abstract</code><br>default方法 与 static 方法</td>
</tr>
<tr>
<td>构造方法</td>
<td>有</td>
<td>无</td>
</tr>
<tr>
<td>继承关系</td>
<td>单继承</td>
<td>接口之间多继承，类与接口多实现</td>
</tr>
</tbody></table>
<p>父类的作用：</p>
<p>​	1.抽取共性代码组成，提高代码复用性</p>
<p>​	2.配合多态</p>
<p>接口的作用：</p>
<p>1.抽取不同类型共性大的方法声明</p>
<p>2.配合多态</p>
<p>​	通过接口引用能接受的对象类型范围比父类引用能接受的类型范围要广泛的多</p>
<h4 id="接口的应用"><a href="#接口的应用" class="headerlink" title="接口的应用"></a>接口的应用</h4><p><strong>使用接口标识一个类所具备的额外能力</strong></p>
<p>概念：父类决定了子类应具备的特征，接口扩充额外功能</p>
<p>例：找出所有会跑的动物</p>
<p>使用接口标识每种能力</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每个接口都标识一种而外能力</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Runnable</span>&#123;<span class="comment">//所有会跑的动物实现此接口</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Swimmable</span>&#123;<span class="comment">//所有会游泳的动物实现此接口</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Flyable</span>&#123;<span class="comment">//所有会飞的动物实现此接口</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>找出所有动物中具备run（跑）能力（方法）的动物</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">    <span class="comment">//动物数组</span></span><br><span class="line">    Animal[] as = &#123; <span class="keyword">new</span> <span class="title class_">Dog</span>(),<span class="keyword">new</span> <span class="title class_">Cat</span>(),</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Fish</span>(),<span class="keyword">new</span> <span class="title class_">Bird</span>(),<span class="keyword">new</span> <span class="title class_">Cat</span>(),</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Dog</span>(),<span class="keyword">new</span> <span class="title class_">Fish</span>()</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//遍历动物数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;as.length; i++)&#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> as[i];</span><br><span class="line">        <span class="comment">//找出每一种会跑的对象，会跑的对象应实现Runnable接口</span></span><br><span class="line">        <span class="keyword">if</span>( a <span class="keyword">instanceof</span> Runnable )&#123;</span><br><span class="line">            Runnable r= (Runnable) a;</span><br><span class="line">            r.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每种动物实现具有标识额外能力的接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Dog 继承Animal  实现两种标识能力的接口Runanble,Swimmable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>,Swimmable&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Cat继承Animal  实现两种标识能力的接口Runanble</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Fish继承Animal  实现两种标识能力的接口Swimmable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fish</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">Swimmable</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Bird继承Animal  实现两种标识能力的接口Flyable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">Flyable</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong>可以更自然的使用多态，找到符合能力的对象而不是只限定类型</p>
<p><strong>管理常量</strong></p>
<p>​	由于接口中的属性都是默认为公开静态常量，使用接口更好的管理常量</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用接口标识颜色，统一颜色的校验方式</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Color</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">RED</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">YELLO</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">GREEN</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>降低程序间耦合</strong></p>
<p>例：Computer（电脑）与USB外设</p>
<p>例Computer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span>&#123;<span class="comment">//电脑类</span></span><br><span class="line">    USB usb;</span><br><span class="line">    <span class="comment">//接入设备</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUSB</span><span class="params">(USB usb)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.usb = usb;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开机方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--开机--&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(usb!=<span class="literal">null</span>)</span><br><span class="line">          usb.service();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类组装Computer与USB外设</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">USB</span> <span class="variable">mou</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mouse</span>(<span class="string">&quot;罗技&quot;</span>);</span><br><span class="line"><span class="type">USB</span> <span class="variable">kb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Keyboard</span>(<span class="string">&quot;雷柏&quot;</span>);</span><br><span class="line"><span class="type">USB</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fan</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Computer</span> <span class="variable">com</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line"><span class="comment">//将鼠标接入到电脑中</span></span><br><span class="line">com.setUSB(f);</span><br><span class="line"><span class="comment">//开机    </span></span><br><span class="line">com.on();</span><br></pre></td></tr></table></figure>

<p>只要实现了USB接口的外设，都能够接入电脑</p>
<p><img src="/javaNote.assets/18.png" alt="image-20230410175342110"></p>
<p>USB接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface USB&#123;</span><br><span class="line">    public void service();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//USB鼠标类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mouse</span> <span class="keyword">implements</span> <span class="title class_">USB</span>&#123;</span><br><span class="line">  String name;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Mouse</span><span class="params">(String name)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;控制指针&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//USB键盘类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Keyboard</span> <span class="keyword">implements</span> <span class="title class_">USB</span>&#123;</span><br><span class="line">  String name;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Keyboard</span><span class="params">(String name)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;录入信息&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//USB风扇类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fan</span> <span class="keyword">implements</span> <span class="title class_">USB</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;吹风~~~~~~&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>接口回调</strong></p>
<p>概念：开发时定义好接口后，先有接口的使用者，后有接口的实现者</p>
<p>体现：使用接口作为参数，使用接口作为属性</p>
<p>例：Computer类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span>&#123;<span class="comment">//电脑类</span></span><br><span class="line">    USB usb;</span><br><span class="line">    <span class="comment">//接入设备</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUSB</span><span class="params">(USB usb)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.usb = usb;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开机方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--开机--&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(usb!=<span class="literal">null</span>)</span><br><span class="line">        usb.service();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	该类在设计过程中不需要关心将来由谁实现USB接口，不会与具体的对象产生耦合，设计Computer不用关心其他外设对象</p>
<p>例：使用JDK提供的java.util.Arrays.sort(  ) 完成对象数组的排序</p>
<p>Student类，实现Comparable接口</p>
<p>实现规则：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> Student类实现Comparable接口则在&lt;&gt;中写Student，Worker类实现Comparable接口则在&lt;&gt;中写Worker</span><br><span class="line"><span class="number">2.</span> &lt;&gt;为泛型，后续章节讲解</span><br><span class="line"><span class="number">3.</span> 实现caompareTo方法时，参数类型与&lt;&gt;中的类型一致</span><br><span class="line"><span class="number">4.</span> 该方法返回一个整数，升序排列规则如下：</span><br><span class="line">   参与比较的两个对象分别是<span class="built_in">this</span>与参数other</span><br><span class="line">   以age排序为例：</span><br><span class="line">     如果<span class="built_in">this</span>.age &gt; other.age 返回 正数 (实际应用时可省略<span class="built_in">this</span>.)</span><br><span class="line">     如果<span class="built_in">this</span>.age &lt; other.age 返回 负数 (实际应用时可省略<span class="built_in">this</span>.)</span><br><span class="line">     相等返回<span class="number">0</span>，或对下一个属性进行大小验证，则age相等时参照其他属性进行排序</span><br><span class="line">     基本数据类型使用 &gt;、&lt;、== 验证大小，对象类型直接使用 属性名.compareTo( other.属性名 ) 即可</span><br><span class="line">     例如:参照name属性进行排序</span><br><span class="line">     name.compareTo( other.name )</span><br><span class="line">     前提：对象所属类已实现Comparable接口</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//Student实现Comparable接口，实现comparaTo方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt; &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age , <span class="type">double</span> score)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age  = age;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//按照分数进行升序排列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student other)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)(score - other.score);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStudent</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建若干学生对象，将对象保存到stus数组中</span></span><br><span class="line">        Student[] stus = &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;wangyx&quot;</span>,<span class="number">16</span>,<span class="number">99.0</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;yangdd&quot;</span>,<span class="number">36</span>,<span class="number">59.9</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;zhangmj&quot;</span>,<span class="number">13</span>,<span class="number">72.2</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;yangyl&quot;</span>,<span class="number">18</span>,<span class="number">100.0</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;wangmj&quot;</span>,<span class="number">19</span>,<span class="number">92.0</span>)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用java.util.Arrays.sort帮助完成排序</span></span><br><span class="line">        java.util.Arrays.sort( stus );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;stus.length; i++)&#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> stus[i];</span><br><span class="line">            System.out.println(stu.name+<span class="string">&quot;\t&quot;</span>+stu.age+<span class="string">&quot;\t&quot;</span>+stu.score);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口的好处：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 设计与实现完全分离</span><br><span class="line">2. 更自然的使用多态</span><br><span class="line">3. 更容易搭建程序框架</span><br><span class="line">4. 更容易更换实现</span><br><span class="line">5. 程序的耦合度降低（各个模块相对独立，彼此间没有必然联按照程序需要，使用时通过组合完成任务）。</span><br></pre></td></tr></table></figure>

<p><strong>补充</strong></p>
<p>​	多继承存在的问题</p>
<p>由于一个类可以实现（继承）多个接口，所以可能出现以下问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IA</span>&#123;</span><br><span class="line">    String <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IB</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类如果实现IA接口中的method方法，就无法实现IB接口中的method方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span>  <span class="title class_">IA</span>,IB&#123;</span><br><span class="line">    <span class="comment">//编译错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	如果是静态方法，也可能出现此类问题，因此JDK8中规定，实现类无法从父接口中继承静态方法 </p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IA</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IB</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果MyClass能够继承静态方法，那么使用子类调用method方法时，编译器就分不清使用哪个method方法了</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span>  <span class="title class_">IA</span>,IB&#123;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="CoreJavaDay15"><a href="#CoreJavaDay15" class="headerlink" title="CoreJavaDay15"></a>CoreJavaDay15</h2><p>内部类</p>
<h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>1.定义位置</p>
<p>类以内，方法以外</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OuterClass</span>&#123;<span class="comment">//外部类</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">InnerClass</span>&#123;<span class="comment">//成员内部类</span></span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.创建对象</p>
<p>特点：：创建内部类对象需要依赖外部类</p>
<p>步骤：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 先创建外部类对象</span><br><span class="line"><span class="number">2.</span> 通过外部类对象 创建成员内部类对象</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line">外部类类名.内部类类名 变量名 = 外部类引用.new 内部类类名();</span><br><span class="line">例：</span><br><span class="line"><span class="type">OuterClass</span> <span class="variable">oc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>();<span class="comment">//创建外部类对象</span></span><br><span class="line">OuterClass.<span class="type">InnerClass</span> <span class="variable">oci</span> <span class="operator">=</span> oc.<span class="keyword">new</span> <span class="title class_">InnerClass</span>();<span class="comment">//创建内部类对象时依赖外部类对象</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：成员内部类不允许定义静态组件</p>
<p>3.内部类访问外部类成员</p>
<p>语法：在内部类中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">外部类类名.this.成员变量</span><br><span class="line">外部类类名.this.成员方法</span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OuterClass</span>&#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//外部类成员变量</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">InnerClass</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">20</span>;<span class="comment">//内部类局部变量</span></span><br><span class="line">            System.out.println( a );<span class="comment">//打印局部变量</span></span><br><span class="line">            System.out.println( OuterClass.<span class="built_in">this</span>.a );<span class="comment">//访问外部类成员变量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>1.定义位置：类以内方法以外，定义时使用 static 修饰内部类</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OuterClass</span>&#123;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span>&#123;<span class="comment">//静态内部类</span></span><br><span class="line">     </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.创建对象</p>
<p>特点：直接可以创建对象，不依赖外部类</p>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">外部类类名.内部类类名 变量名 = <span class="keyword">new</span> 外部类类名.内部类类名();</span><br><span class="line">例：</span><br><span class="line"><span class="comment">//创建静态内部类对象</span></span><br><span class="line">OuterClass.<span class="type">InnerClass</span> <span class="variable">oci</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>.InnerClass();</span><br></pre></td></tr></table></figure>

<p>3.访问静态内部类</p>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">外部类.内部类.静态成员</span><br><span class="line">例：</span><br><span class="line">OuterClass.InnerClass.a;<span class="comment">//访问内部类静态成员</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：</p>
<ol>
<li><p>静态内部类只能访问外部的静态成员</p>
</li>
<li><p>直接访问内部静态成员不会加载外部静态成员</p>
</li>
</ol>
<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>1.定义位置：定义在方法的内部</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    </span><br><span class="line">       <span class="keyword">class</span> <span class="title class_">InnerClass</span>&#123;<span class="comment">//局部内部类</span></span><br><span class="line">     </span><br><span class="line">       &#125;</span><br><span class="line">&#125;       </span><br></pre></td></tr></table></figure>

<p>2.创建对象</p>
<p>特点：创建对象与作用范围仅在该方法中，与局部变量一致</p>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">内部类类名 变量名 = <span class="keyword">new</span> 内部类类名();</span><br><span class="line">例：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">class</span> <span class="title class_">InnerClass</span>&#123;<span class="comment">//局部内部类</span></span><br><span class="line">         </span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//创建局部内部类对象</span></span><br><span class="line">     <span class="type">InnerClass</span> <span class="variable">ic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InnerClass</span>();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.局部内部类访问外部方法的局部变量</p>
<p>特点：被访问的局部变量必须声明为final常量</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">     <span class="keyword">final</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//外部方法的局部变量</span></span><br><span class="line">     </span><br><span class="line">     <span class="keyword">class</span> <span class="title class_">InnerClass</span>&#123;<span class="comment">//局部内部类</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println( value );<span class="comment">//访问外部方法的局部变量，该局部变量必须被final修饰</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//创建局部内部类对象</span></span><br><span class="line">     <span class="type">InnerClass</span> <span class="variable">ic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InnerClass</span>();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：JDK8或以上局部内部类访问外部方法中的局部变量，编译器会隐式使用final修饰外部变量</p>
<p>4.使用场景</p>
<p>​	当需要提供某个接口实现类对象，该类只对内部使用且对象只用一次时，可以使用局部内部类实现接口</p>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>面向对象编程的弊端：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">面向对象编程无论完成什么功能，都需要依赖对象，需要对象就要定义类再通过类创建对象，最终需要将创建的对象交给使用者才能使用</span><br><span class="line">有些情况作为对象的使用者并不关注对象所属类型，只关注对象所具备的方法，所以至于该类叫什么，并不重要。</span><br><span class="line">作为接口的实现者，只需要按照对方的需要，提供对应类型的实现类对象即可，而构建对象的语法过于繁琐（先定义类，再创建对象），甚至于有些情况定义实现类的代码比方法中完成功能的代码还要多，而通过大量的编程中也可以发现，实现类与实现类之间的区别仅在于方法实现的不同，因此遭到很多程序员的吐槽。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>特点：匿名内部类是特殊的局部内部类，只用于实现一个接口或继承一个类，定义类与创建对象同时进行，简化构建实现类（子类）的代码</p>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类名/接口名 变量名 = <span class="keyword">new</span> 类名/接口名()&#123;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//匿名内部类，该类为子类/实现类</span></span><br><span class="line">      </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>例：使用局部内部类继承抽象类，实现接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Super</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SuperInterface</span>&#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">   <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">   </span><br><span class="line">       <span class="comment">//使用匿名内部类创建Super类的子类对象</span></span><br><span class="line">       <span class="type">Super</span> <span class="variable">sup</span> <span class="operator">=</span>   <span class="keyword">new</span> <span class="title class_">Super</span>()&#123;<span class="comment">//&#123; &#125; 为无名子类</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;<span class="comment">//子类覆盖父类的抽象方法</span></span><br><span class="line">           </span><br><span class="line">           &#125;   </span><br><span class="line">       &#125;;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//使用匿名内部类创建SuperInterface接口的实现类对象</span></span><br><span class="line">        <span class="type">SuperInterface</span> <span class="variable">sup</span> <span class="operator">=</span>   <span class="keyword">new</span> <span class="title class_">SuperInterface</span>()&#123;<span class="comment">//&#123; &#125; 为无名子类</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;<span class="comment">//子类实现接口中的抽象方法</span></span><br><span class="line">           </span><br><span class="line">           &#125;   </span><br><span class="line">       &#125;;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>局部内部类与匿名内部类，以实现USB接口并创建对象为例</p>
<p><img src="/javaNote.assets/19.png" alt="image-20230412110757331"></p>
<p>因为定义类与创建对象的代码整合在一起，所以匿名内部类一生只有一个对象</p>
<p>使用案例1：Computer与USB设备</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//USB台灯：局部内部类实现方式</span></span><br><span class="line">    <span class="keyword">class</span>  <span class="title class_">Lamp</span> <span class="keyword">implements</span> <span class="title class_">USB</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;台灯发光&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建USB台灯对象</span></span><br><span class="line">    <span class="type">USB</span> <span class="variable">usb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lamp</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//USB台灯：匿名内部类实现方式</span></span><br><span class="line">     <span class="type">Usb</span> <span class="variable">usb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">USB</span>()&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;台灯发光&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建Computer对象</span></span><br><span class="line">    <span class="type">Computer</span> <span class="variable">com</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">    com.setUSB( usb1 );<span class="comment">//接入usb设备</span></span><br><span class="line">    com.on();<span class="comment">//开机</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用案例2：实现Comparator接口完成排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestClassLoader</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Student[] stus = &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;wangyx&quot;</span>,<span class="number">16</span>,<span class="number">99.0</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;yangdd&quot;</span>,<span class="number">36</span>,<span class="number">59.9</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;zhangmj&quot;</span>,<span class="number">13</span>,<span class="number">72.2</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;yangyl&quot;</span>,<span class="number">18</span>,<span class="number">100.0</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;wangmj&quot;</span>,<span class="number">19</span>,<span class="number">92.0</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//局部内部类实现</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">StudentComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Student&gt; &#123;</span><br><span class="line">            <span class="comment">//实现compare方法</span></span><br><span class="line">            <span class="comment">//o1，o2是参与比较过程的两个对象</span></span><br><span class="line">            <span class="comment">//实现原则与Comparable一致</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (<span class="type">int</span>)(o1.score - o2.score);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建自定义比较器</span></span><br><span class="line">        <span class="type">Comparator</span> <span class="variable">com</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StudentComparator</span>();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//匿名内部类实现</span></span><br><span class="line">        Comparator&lt;Student&gt; com1 = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Sutndet&gt;&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (<span class="type">int</span>)(o1.score - o2.score);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用Arrays.sort进行排序，传入对象数组与比较器</span></span><br><span class="line">        Arrays.sort( stus , com1 );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;stus.length; i++)&#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> stus[i];</span><br><span class="line">            System.out.println(stu.name+<span class="string">&quot;\t&quot;</span>+stu.age+<span class="string">&quot;\t&quot;</span>+stu.score);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h3><p>概念：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. Lambda表达式是JDK8加入的一种新的编程方式，试图屏蔽纯面向对象编程的弊端，引入像python、js等语言的函数式编程（面向过程）特点，让接口的实现者只关注方法的实现，简化定义类、实现接口、创建对象的过程。</span><br><span class="line">2. Lambda表达式是匿名内部类的再简化，只保留函数的主要部分</span><br><span class="line">3. Lambda只能用来实现只有一个抽象方法的接口，这样的接口我们也称之为函数式接口（Function Interface）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>作用：与匿名内部类一致，实现接口并创建对象，简化开发</p>
<p>函数描述符：用于描述一个函数或者方法</p>
<p>完整语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(数据类型1  形参1，数据类型 形参2)-&gt;&#123;方法实现&#125;</span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IA</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IB</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">m2</span><span class="params">(<span class="type">int</span> a)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IC</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">m3</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLambda</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//创建IA接口实现类对象</span></span><br><span class="line">        <span class="type">IA</span> <span class="variable">ia</span> <span class="operator">=</span> ()-&gt; System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建IB接口实现类对象</span></span><br><span class="line">        <span class="type">IB</span> <span class="variable">ib1</span> <span class="operator">=</span> (<span class="type">int</span> a)-&gt;&#123; <span class="keyword">return</span> a+<span class="number">10</span>;&#125;;</span><br><span class="line">        <span class="type">IB</span> <span class="variable">ib2</span> <span class="operator">=</span> a-&gt;a+<span class="number">10</span>;<span class="comment">//简写形式</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建IC接口实现类对象</span></span><br><span class="line">        <span class="type">IC</span> <span class="variable">ic1</span> <span class="operator">=</span> (<span class="type">int</span> a,<span class="type">int</span> b)-&gt;&#123;<span class="keyword">return</span> a+b;&#125;;</span><br><span class="line">        <span class="type">IC</span> <span class="variable">ic2</span> <span class="operator">=</span> (a,b)-&gt;a+b;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>简写形式与规则</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 方法实现只有一行语句且不是return语句时，可以省略&#123; &#125;</span><br><span class="line">2. 方法实现需要返回结果，但只有一行代码时，可以省略return与&#123;&#125; </span><br><span class="line">   简写语法：(形参1，形参2)-&gt;方法实现</span><br><span class="line">   例1：(a,b)-&gt;System.out.println(a+b) </span><br><span class="line">   例2：(a,b)-&gt;a+b  //返回a+b的结果</span><br><span class="line">   </span><br><span class="line">3. 方法实现只有一个的形参时，可以省略()</span><br><span class="line">   简写语法：形参1-&gt;方法实现</span><br><span class="line">   例：a-&gt;System.out.println(a)</span><br><span class="line"></span><br><span class="line">总结：是否需要&#123; &#125;取决于代码行数与是否有return语句，是否需要()取决于参数个数   </span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：return 语句不可视为单句实现所以需要加大括号</p>
<p>案例1：Computer与USB设备</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//USB台灯：匿名内部类实现方式</span></span><br><span class="line">     <span class="type">Usb</span> <span class="variable">usb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">USB</span>()&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;台灯发光&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//USB台灯：Lambda表达式实现方式</span></span><br><span class="line">    <span class="type">USB</span> <span class="variable">usb2</span> <span class="operator">=</span> ()-&gt;System.out.println(<span class="string">&quot;台灯发光&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建Computer对象</span></span><br><span class="line">    <span class="type">Computer</span> <span class="variable">com</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">    com.setUSB( usb2 );<span class="comment">//接入usb设备</span></span><br><span class="line">    com.on();<span class="comment">//开机</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例2：实现Comparator接口完成排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//匿名内部类方式实现</span></span><br><span class="line">   Comparator&lt;Student&gt; stuCom1 = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;()&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.age-o2.age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//Lambda表达式方式实现    </span></span><br><span class="line">    Comparator&lt;Student&gt; stuCom2 = (o1,o2)-&gt;o1.age-o2.age;    </span><br><span class="line">        </span><br><span class="line">    <span class="comment">//排序    </span></span><br><span class="line">    java.util.Arrays.sort( stus ,stuComp2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> Lambda表达式只是简化了编写实现类、实现方法、构建对象的语法，程序编译后依然会转换为内部类的形式</p>
<h2 id="CoreJavaDay16"><a href="#CoreJavaDay16" class="headerlink" title="CoreJavaDay16"></a>CoreJavaDay16</h2><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>概念：应用程序编程接口，JDK提供的一套为开发人员使用的通用类与工具，帮助程序员解决日常开发时的种种需求</p>
<h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><p>特点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. Object（对象），万物皆对象，所以Object类为所有类的父类</span><br><span class="line">2. Object中所有方法都是子类所具备的方法</span><br><span class="line">3. Object作为引用可以存储任何对象，作为参数可以接收任何对象，作为返回值类型可以返回任何对象</span><br></pre></td></tr></table></figure>

<p>Object类常用方法</p>
<h4 id="getClass"><a href="#getClass" class="headerlink" title="getClass"></a><strong>getClass</strong></h4><p>方法声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Class&lt;?&gt; getClass()</span><br></pre></td></tr></table></figure>

<p>作用：返回引用中所存储的对象实际类型，可用于类型判断</p>
<p>例：比较引用中存储的对象类型是否一致（完全相同）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line"><span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"></span><br><span class="line">System.out.println( o2 <span class="keyword">instanceof</span> Animal );   <span class="comment">//o2为Dog类型，Dog is a Ainmal 所以为 true</span></span><br><span class="line">System.out.println( o2.getClass() == o1.getClass() );<span class="comment">//o1为Animal类型，o2为Dog类型，false 两者类型不一致</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a><strong>toString</strong></h4><p>方法声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<p>作用：返回一段可以描述当前对象的字符串（对象的字符串体现形式）</p>
<p>Object默认的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//返回 类名+@+基于内存生成的hash码并转换为16进制</span></span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：不能体现对象与对象之间的所有差异，例如属性的差异</p>
<p>子类应该覆盖toString，提供更好的实现</p>
<p>例：Student类覆盖toString</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">  String name;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="type">double</span> score;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">double</span> score)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.score = score;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;wangyx&quot;</span>,<span class="number">16</span>,<span class="number">59</span>);</span><br><span class="line">System.out.println( stu.toString() );<span class="comment">//打印结果为地址</span></span><br></pre></td></tr></table></figure>

<p>覆盖规则：在toString方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="string">&quot;类名[属性名=&quot;</span>+属性值+<span class="string">&quot; , 属性名=&quot;</span>+属性值....+<span class="string">&quot; ]&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>覆盖案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">  String name;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="type">double</span> score;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">double</span> score)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.score = score;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//覆盖父类中的toString方法，返回由各个属性构成的字符串</span></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;Student [name=&quot;</span>+name+<span class="string">&quot; , age=&quot;</span>+age+<span class="string">&quot; , socre=&quot;</span>+score+<span class="string">&quot; ]&quot;</span>; </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;wangyx&quot;</span>,<span class="number">16</span>,<span class="number">100D</span>);</span><br><span class="line">System.out.println( stu.toString() );<span class="comment">//打印结果：Student [name=wangyx , age=16 , socre=100 ]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>System.out打印语句在打印对象时，会自动调用对象的toString方法，打印返回值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;wangyx&quot;</span>,<span class="number">16</span>,<span class="number">100D</span>);</span><br><span class="line">System.out.println( stu.toString() );</span><br><span class="line">System.out.println( stu );<span class="comment">//自动调用stu.toString() ,打印结果，所以同上</span></span><br></pre></td></tr></table></figure>

<h4 id="equals"><a href="#equals" class="headerlink" title="equals"></a><strong>equals</strong></h4><p>方法声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br></pre></td></tr></table></figure>

<p>作用：比较两个对象是否“相同”</p>
<p>Object中默认的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">   <span class="comment">//使用==进行比较，只比较地址是否相同</span></span><br><span class="line">   <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：所谓“相同”的对象不仅是地址的验证，如果地址不同各个属性相同，我们也认为两个对象是相同的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;wangyx&quot;</span>,<span class="number">16</span>,<span class="number">100D</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">stu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;wangyx&quot;</span>,<span class="number">16</span>,<span class="number">100D</span>);</span><br><span class="line"></span><br><span class="line">System.out.println( stu1==stu2 );<span class="comment">//结果为false，但是两个对象属性相同</span></span><br><span class="line">System.out.println( stu1.equals( stu2 ) );<span class="comment">//结果同上</span></span><br></pre></td></tr></table></figure>

<p>​	子类应该覆盖equals方法，提供更好的实现，让其具备能够鉴定属性是否相同的能力</p>
<p>覆盖规则：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.如果地址相同对象一定相同</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>==o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.如果o为null则没有判断的必要性，如果两者类型不一样也没有判断的必要性</span></span><br><span class="line">    <span class="keyword">if</span>(o==<span class="literal">null</span> || getClass()!=o.getClass() )  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//向下转型</span></span><br><span class="line">    本类类名 other = (本类类名) o;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//验证各个属性是否相同</span></span><br><span class="line">    <span class="keyword">if</span>(Objects.equals( 属性<span class="number">1</span> , other.属性<span class="number">1</span>) &amp;&amp; Objects.equals(属性<span class="number">2</span> , other.属性<span class="number">2</span>)... )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//相同返回true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果没有true，则返回false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	Objects是JDK1.7提供的工具类，其内部的equals方法可以帮我们完成两个参数是否相同的验证； 基本数据类型也可以使用&#x3D;&#x3D;判断</p>
<p>覆盖案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">  String name;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="type">double</span> score;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//覆盖equals方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span>&#123;</span><br><span class="line">    <span class="comment">//1.如果地址相同对象一定相同</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>==o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.如果o为null则没有判断的必要性，如果两者类型不一样也没有判断的必要性</span></span><br><span class="line">    <span class="keyword">if</span>(o==<span class="literal">null</span> || getClass()!=o.getClass() )  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.向下转型</span></span><br><span class="line">    <span class="type">Student</span> <span class="variable">other</span> <span class="operator">=</span> (Student)o;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.验证内容（各个属性）是否相同 </span></span><br><span class="line">    <span class="keyword">if</span>( Objects.equals(name,other.name) &amp;&amp; Objects.equals(age,other.age) &amp;&amp; Objects.equals( score,other.score ) )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a><strong>finalize</strong></h4><p>方法声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span><br></pre></td></tr></table></figure>

<p>作用：当对象被垃圾回收器（Garbage Collection) 准备回收前调用</p>
<p>相关概念：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 垃圾对象：在JVM生命周期中会创建无数个对象，每个对象都会占用一块内存空间，如果每个对象都无限期存活在内存中，那么很快就会把内存消耗光引发内存不足的问题，JVM提供了一个系统级的垃圾回收器（gc )，自动回收无用对象所占用的内存空间。</span><br><span class="line">2. 垃圾对象的认定算法：零引用算法，没有引用指向该对象时，认定为垃圾对象</span><br><span class="line">3. 垃圾对象的回收时机：基于内存大小采用延迟回收策略</span><br></pre></td></tr></table></figure>

<p>​	GC相关方法：使用System.gc() 或 Runtime.gc() 提示gc尽快执行垃圾回收操作。但不保证立即执行。</p>
<p><img src="/javaNote.assets/20.png" alt="image-20230413100914496"></p>
<h2 id="CoreJavaDay17"><a href="#CoreJavaDay17" class="headerlink" title="CoreJavaDay17"></a>CoreJavaDay17</h2><h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><p>概念：包装类即每种基本数据类型所对应的对象类型，由JDK5提供，真正实现万物皆对象，包装基本数据类型值为对象的类，包装类就是给基本数据类型提供一个对象的外衣</p>
<h4 id="类型对照"><a href="#类型对照" class="headerlink" title="类型对照"></a>类型对照</h4><table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td><strong>Integer</strong></td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td><strong>Double</strong></td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>boolean</td>
<td><strong>Boolean</strong></td>
</tr>
</tbody></table>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><h5 id="valueOf方法"><a href="#valueOf方法" class="headerlink" title="valueOf方法"></a><strong>valueOf方法</strong></h5><p>方法声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer valueOf​(<span class="type">int</span> i)<span class="keyword">throws</span> NumberFormatException</span><br></pre></td></tr></table></figure>

<p>作用：将 基本数据类型 或 字符串 转换为 包装类型</p>
<p>例：基本数据类型转换为包装类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">oi</span> <span class="operator">=</span> Integer.valueOf( a );</span><br><span class="line"><span class="type">Byte</span> <span class="variable">ob</span> <span class="operator">=</span> Byte.valueOf( b );</span><br></pre></td></tr></table></figure>

<p>例：字符串转换为包装类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">oi</span> <span class="operator">=</span> Integer.valueOf(<span class="string">&quot;12&quot;</span>);</span><br><span class="line"><span class="type">Double</span> <span class="variable">od</span> <span class="operator">=</span> Double.valueOf(<span class="string">&quot;12.5&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：如果 字符串 不符合 字面值形式 ，转换时会出现数字格式化异常（java.lang.NumberFormatException: For input string: “错误的字符串”）</p>
<h5 id="xxValue方法"><a href="#xxValue方法" class="headerlink" title="xxValue方法"></a><strong>xxValue方法</strong></h5><p>xx为基本数据类型，例如byteValue、intValue、doubleValue等等</p>
<p>方法声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">byte</span> <span class="title function_">xxValue</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<p>作用：将 包装类型 转换为 基本数据类型</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>);</span><br><span class="line"><span class="type">Byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Byte</span>(<span class="number">20</span>);</span><br><span class="line"><span class="type">Double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">30D</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> i.intValue();<span class="comment">//将i转换为基本数据类型</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">b2</span> <span class="operator">=</span> b.byteValue();<span class="comment">//将b转换为基本数据类型</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d2</span> <span class="operator">=</span> d.doubleValue();<span class="comment">//将d转换为基本数据类型</span></span><br></pre></td></tr></table></figure>

<h5 id="parseXx-方法"><a href="#parseXx-方法" class="headerlink" title="parseXx 方法"></a>parseXx 方法</h5><p>Xx为基本数据类型，注意首字母大写；例如：parseByte、parseInt、parseDouble等等</p>
<p>方法声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> parseInt​(String s)</span><br></pre></td></tr></table></figure>

<p>作用：将 字符串 转换为基本数据类型</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b3</span> <span class="operator">=</span> Byte.parseByte(<span class="string">&quot;12&quot;</span>);<span class="comment">//将字符串转换为byte</span></span><br><span class="line"><span class="type">int</span>  <span class="variable">i3</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;1234&quot;</span>);<span class="comment">//将字符串转换为int</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d3</span> <span class="operator">=</span> Double.parseDouble(<span class="string">&quot;12.5&quot;</span>);<span class="comment">//将字符串转换为double</span></span><br></pre></td></tr></table></figure>

<h5 id="自动封箱-自定拆箱"><a href="#自动封箱-自定拆箱" class="headerlink" title="自动封箱&amp;&amp;自定拆箱"></a><strong>自动封箱&amp;&amp;自定拆箱</strong></h5><p>概念：JDK5提供的一种类型转换机制，基本数据类型可以自动转换为包装类型，反之亦可</p>
<p><strong>自动封箱</strong>：自动将 基本数据类型 转换为 包装类型</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">Double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">12.5</span>;</span><br></pre></td></tr></table></figure>

<p>转换时会自动调用valueOf方法进行转换</p>
<p><strong>自动拆箱</strong>：自动将 包装类型 转换为 基本数据类型</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">in</span> <span class="operator">=</span> i;</span><br><span class="line"></span><br><span class="line"><span class="type">Double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">dn</span> <span class="operator">=</span> d;<span class="comment">//自动将包装类型，转换为基本数据类型</span></span><br></pre></td></tr></table></figure>

<p>转换时会自动调用 xxValue 方法进行转换</p>
<h5 id="包装类的优势"><a href="#包装类的优势" class="headerlink" title="包装类的优势"></a>包装类的优势</h5><p>1.Object可以统一所有数据类型</p>
<p>例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//自动封箱</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">o3</span> <span class="operator">=</span> <span class="number">12.5</span>;<span class="comment">//自动封箱</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.可以区分null值与0值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">   String name;</span><br><span class="line">   Double score;<span class="comment">//可以区分null（没考试） 或 0（考0分）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.内部支持缓存区</p>
<p>缓存区大小 1B，缓存数值：-128~127</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用valueOf方法进行转换时，如果缓存区中存在能表示该数值的对象，则从缓存中获取</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> Integer.valueOf(<span class="number">120</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> Integer.valueOf(<span class="number">120</span>);</span><br><span class="line">System.out.println( i1 == i2 );<span class="comment">//true ：相同的对象，地址相同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果使用构造方法，则每次创建的对象是都新对象</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>( <span class="number">120</span> );</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>( <span class="number">120</span> );</span><br><span class="line">System.out.println( i3 == i4 );<span class="comment">//false：不同的对象，地址不同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当然如果数值过大，依然要重新创建对象</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i5</span> <span class="operator">=</span> Integer.valueOf(<span class="number">130</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i6</span> <span class="operator">=</span> Integer.valueOf(<span class="number">130</span>);</span><br><span class="line">System.out.println( i5 == i6 );<span class="comment">//false：不同的对象，地址不同</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="file://C:\Users\18060\Desktop\javaNote\photos\javaNote\21.png?lastModify=1681464662" alt="image-20230413143749883"></p>
<p><strong>注意</strong>：包装类需要使用equals方法验证是否相等</p>
<h2 id="CoreJavaDay18"><a href="#CoreJavaDay18" class="headerlink" title="CoreJavaDay18"></a>CoreJavaDay18</h2><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><p>作用：Java中最常用的字符串类</p>
<p>特点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String类属于<span class="keyword">final</span>类无法被继承</span><br><span class="line">String内部使用一个<span class="keyword">final</span> <span class="type">char</span>[] data 来存储每个字符</span><br><span class="line">String对象是不可变的</span><br></pre></td></tr></table></figure>

<p>例：String对象的内部存储</p>
<p><img src="/javaNote.assets/22.png" alt="image-20230413173309189"></p>
<h4 id="串池"><a href="#串池" class="headerlink" title="串池"></a>串池</h4><p>作用：JVM为String分配的一块内存空间，用于缓存在程序中使用的字符串</p>
<p><img src="/javaNote.assets/23.png" alt="image-20230414110636739"></p>
<p>缓存时机：每次创建新的字符串时，将该字符串添加到串池中（以空间换时间）</p>
<p>例：比较两个字符串地址是否相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;wangyx&quot;</span>;<span class="comment">//将wangyx添加到串池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;wangyx&quot;</span>;<span class="comment">//不再新建，直接使用串池中的wangyx</span></span><br><span class="line">System.out.println( str1 == str2 );<span class="comment">//结果为true</span></span><br></pre></td></tr></table></figure>

<h4 id="String的不变性"><a href="#String的不变性" class="headerlink" title="String的不变性"></a>String的不变性</h4><p>​	由于Stirng内部是由一个final char[] 存储每个字符，而数组的长度一旦确定不可更改，被final修饰又不能进行扩容，所以String对象一旦创建将不可改变，只能再构建新的字符串对象，这种特点与数组是一样的</p>
<p>​	除了final char[]能够限制String对象不变s以外，还通过底层限制了String内容的不变性</p>
<p><img src="file://C:/Users/18060/Desktop/javaNote/photos/javaNote/24.png?lastModify=1681464701" alt="image-20230414112625030"></p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span><span class="string">&quot;A&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span><span class="string">&quot;B&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span><span class="string">&quot;C&quot;</span>;</span><br><span class="line"></span><br><span class="line">str1 + str2 +str3<span class="comment">//会产生多个String对象 </span></span><br></pre></td></tr></table></figure>

<p><img src="file://C:\Users\18060\Desktop\javaNote\photos\javaNote\26.png?lastModify=1681464575" alt="image-20230414172445278"></p>
<h4 id="创建String对象"><a href="#创建String对象" class="headerlink" title="创建String对象"></a>创建String对象</h4><p>1.第一种方式使用 “ “ 号直接构建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;World&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>2.使用new 语句构建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;World&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="双引号-与new语句构建String对象的区别"><a href="#双引号-与new语句构建String对象的区别" class="headerlink" title="双引号 与new语句构建String对象的区别"></a>双引号 与new语句构建String对象的区别</h4><p>1.双引号 与new语句构建String对象的区别 </p>
<p>例:</p>
<p><img src="/javaNote.assets/27.png" alt="image-20230414172714436"></p>
<p>2.使用双等号进行判断时</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">System.out.println( str1 == str2 );<span class="comment">//地址不同结果为：false</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>验证两个字符串是否相同，请使用equals方法</p>
<h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>toCharArray()</td>
<td>将字符串转换为字符数组</td>
</tr>
<tr>
<td>equalsIgnoreCase()</td>
<td>忽略大小写验证</td>
</tr>
<tr>
<td>indexOf(String ch)</td>
<td>查找字符第一次出现的位置（下标）</td>
</tr>
<tr>
<td>indexOf(String ch,int formIndex)</td>
<td>从formIndex位置开始向后查找字符位置（下标）</td>
</tr>
<tr>
<td>lastIndexOf(String ch)</td>
<td>查找ch最后一次出现的位置</td>
</tr>
<tr>
<td>length( )</td>
<td>返回字符串的长度</td>
</tr>
<tr>
<td>toUpperCase()</td>
<td>将字符串转换为大写字符</td>
</tr>
<tr>
<td>toLowerCase()</td>
<td>将字符串转换为小写字符</td>
</tr>
<tr>
<td>trim()</td>
<td>去掉字符串两边的空格</td>
</tr>
<tr>
<td>replace(String a,String b)</td>
<td>将字符串中的 字符串a 替换为 字符串b</td>
</tr>
<tr>
<td>String[] split(String regex )</td>
<td>以 regex 为分割条件 将字符串分割成多部分并返回</td>
</tr>
<tr>
<td>substring(int beginIndex, int endIndex)</td>
<td>截取字符串 从beginIndex开始 到endIndex-1结束</td>
</tr>
</tbody></table>
<h4 id="StringBuffer-StringBuilder"><a href="#StringBuffer-StringBuilder" class="headerlink" title="StringBuffer&#x2F;StringBuilder"></a>StringBuffer&#x2F;StringBuilder</h4><p>作用：StringBuffer与StringBuilder为可变长字符串，允许字符串在原有基础上进行修改</p>
<p>区别：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. StringBuffer：JDK1.0，操作速度慢，线程安全</span><br><span class="line">2. StringBuilder：JDK5.0，操作速度快，线程不安全</span><br></pre></td></tr></table></figure>

<p>创建对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();<span class="comment">//创建StringBuilder对象</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();  <span class="comment">//创建StringBuffer对象</span></span><br></pre></td></tr></table></figure>

<p>常用方法：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/StringBuilder.html#append(boolean)">append</a>(Object obj)</td>
<td>将任意类型的数据转换字符串拼接到结尾</td>
</tr>
<tr>
<td>charAt(int index)</td>
<td>返回index位置的字符</td>
</tr>
<tr>
<td>deleteCharAt(int index)</td>
<td>删除index位置的字符</td>
</tr>
<tr>
<td>insert(int offset , Object obj )</td>
<td>将任意类型的数据转换为字符串插入到offset位置</td>
</tr>
<tr>
<td>toString()</td>
<td>将StringBuilder转换为String</td>
</tr>
</tbody></table>
<p>效率比较案例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.currentTimeMillis();<span class="comment">//获取当前时间的毫秒形式</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">30000</span>; i++)&#123;</span><br><span class="line">    str+=i;<span class="comment">//将i拼接到字符串中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">t2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">System.out.println(t2 - t1);<span class="comment">//计算消耗时间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">t3</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="comment">//创建StringBuilder</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">30000</span>; i++)&#123;</span><br><span class="line">    sb.append( i );<span class="comment">//将i拼接到StringBuilder中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">t4</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">System.out.println( t4 - t3 );</span><br></pre></td></tr></table></figure>

<h2 id="CoreJavaDay19"><a href="#CoreJavaDay19" class="headerlink" title="CoreJavaDay19"></a>CoreJavaDay19</h2><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>概念：程序在运行过程时出现的特殊情况，非语法导致的编译错误</p>
<p>程序运行过程中遇到不正常的情况，有2种选择：</p>
<p>​	1.一旦出现异常，上抛异常信息，然后终止程序运行（后续代码不再执行）</p>
<p>​	2.直接忽略，硬着头皮继续向下执行</p>
<p>​	JVM对于异常的默认态度是一旦出现异常就必须上抛异常，然后终止后续的程序，避免更大的错误。</p>
<p>​	在程序开发过程中，有时候需要主动的使用异常来避免更大的问题</p>
<p><strong>总结：</strong></p>
<p>1.异常表示的是程序运行过程中不正常的情况</p>
<p>2.JVM一旦发现异常，默认就会终止程序后续的运行，避免更大的问题</p>
<p><img src="/javaNote.assets/28.png" alt="image-20230417114642754"></p>
<p>异常的作用：遇到不正常的情况，代替return抛出异常信息，终止后续代码执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如何代替return的语法执行：</span><br><span class="line">	return正常结果：终止方法的后续执行</span><br><span class="line">	throw异常结果：类似于return，可以终止后续方法的执行</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h4><p><img src="/javaNote.assets/29.png" alt="image-20230417143937180"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. Throwable：所有异常类的父类</span><br><span class="line">2. Error或子类：表示错误;例如JVM、硬件、执行逻辑错误，不能通过代码避免，不能通过代码进行处理，无需关注</span><br><span class="line">3. Exception或直接子类：称为已检查异常 或 编译时异常，已知的程序隐患，不能通过代码避免，必须通过代码进行处理，否则编译错误</span><br><span class="line">4. RuntimeException或子类：称为未检查异常 或 运行时异常，可以通过代码避免，可以通过代码处理也可不处理，编译器不干预，建议优先避免</span><br></pre></td></tr></table></figure>



<p><img src="/javaNote.assets/30.png" alt="image-20230418100440461"></p>
<h2 id="CoreJavaDay20"><a href="#CoreJavaDay20" class="headerlink" title="CoreJavaDay20"></a>CoreJavaDay20</h2><p>集合：特殊的对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  对象：集合还是对象，可以调用方法（不同的方法有不同的作用）</span><br><span class="line">  特殊：特殊在它的作用，用来保存多个 其它类型的对象  的 对象</span><br><span class="line">新技术用来解决旧技术的不足或不能</span><br></pre></td></tr></table></figure>

<p>作用：存储对象的容器，代替数组，使用更加便捷</p>
<p><img src="/javaNote.assets/31.png" alt="image-20230418154236389"></p>
<p>体系结构：</p>
<p><img src="/javaNote.assets/32.png" alt="image-20230418154300759"></p>
<h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h3><p>特点：内部的每个元素都是一个对象</p>
<p>常用方法：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>add( Object o )</td>
<td>将o添加到集合中</td>
</tr>
<tr>
<td>contains( Object o )</td>
<td>判断集合中是否有与o相同的元素</td>
</tr>
<tr>
<td>remove( Object o )</td>
<td>将o从集合中移除</td>
</tr>
<tr>
<td>clear()</td>
<td>清空集合</td>
</tr>
<tr>
<td>isEmpty()</td>
<td>判断集合中是否存在有效元素 true 不存在</td>
</tr>
<tr>
<td>size()</td>
<td>返回有效元素个数</td>
</tr>
</tbody></table>
<h3 id="List-接口"><a href="#List-接口" class="headerlink" title="List 接口"></a>List 接口</h3><p>特点：Collection接口的子接口，有序、有下标、元素可以重复</p>
<p>常用方法：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>add(int index , Object o)</td>
<td>将o保存到集合中index位置（不会覆盖原有元素）</td>
</tr>
<tr>
<td>Object remove(int index)</td>
<td>移除index位置的元素（其他元素向前位移）返回被移除的对象</td>
</tr>
<tr>
<td>Object get(int index)</td>
<td>获取index位置的元素</td>
</tr>
<tr>
<td>Object set(int index,Object o)</td>
<td>将index位置的元素替换为o并返回被替代的元素（index位置必须有元素）</td>
</tr>
<tr>
<td>List subList(int a, int b)</td>
<td>截取集合中的一部分元素，从a开始到b-1结束</td>
</tr>
</tbody></table>
<h3 id="List接口实现类"><a href="#List接口实现类" class="headerlink" title="List接口实现类"></a>List接口实现类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List是接口，定义了这类集合的操作方法和特性</span><br><span class="line">	集合特点：有序，有下标，内容可以重复，增强版本的数组</span><br><span class="line">	操作方法：增删改查</span><br><span class="line">需要由实现类实现</span><br><span class="line">	1.ArrayList JDK1.2 由数组实现 查询快，增减慢  线程不安全</span><br><span class="line">	2.LinkedList  JKD1.2  链表实现，查询慢，增删快，线程不安全</span><br><span class="line">	3.Vector JDK1.0 由数组实现  查询快 ，增删慢  线程安全</span><br></pre></td></tr></table></figure>

<h3 id="集合常见使用方法"><a href="#集合常见使用方法" class="headerlink" title="集合常见使用方法"></a>集合常见使用方法</h3><p>以ArrayList为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建集合对象</span></span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储元素</span></span><br><span class="line">list.add( e );</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储自定义类型对象1</span></span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>) );</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储自定义类型对象2</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">20</span>);</span><br><span class="line">list.add(stu1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除元素</span></span><br><span class="line">list.remove( <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改元素</span></span><br><span class="line">list.set( <span class="number">0</span> , <span class="string">&quot;ABC&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="遍历集合"><a href="#遍历集合" class="headerlink" title="遍历集合"></a>遍历集合</h3><h4 id="for循环遍历"><a href="#for循环遍历" class="headerlink" title="for循环遍历"></a>for循环遍历</h4><p>​	特点：使用for循环中的循环变量充当下标，获取集合中的每个元素，只能遍历List接口下的集合</p>
<p>规范：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;集合名.size(); i++)&#123;</span><br><span class="line">  <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> 集合名.get(i);<span class="comment">//根据下标获取元素</span></span><br><span class="line">&#125;</span><br><span class="line">例：</span><br><span class="line">    <span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.size(); i++)&#123;</span><br><span class="line">  <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> list.get(i);<span class="comment">//根据下标获取元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="迭代器（iterator）遍历"><a href="#迭代器（iterator）遍历" class="headerlink" title="迭代器（iterator）遍历"></a>迭代器（iterator）遍历</h4><p>​	特点：内部使用cursor（游标）遍历，无需使用下标，可以遍历Collection并保证遍历完整</p>
<p>规范：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> 集合名.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;<span class="comment">//指针下移</span></span><br><span class="line">  <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> it.next();<span class="comment">//取出游标经过的一个对象     </span></span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代器常用方法：</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>boolean hasNext()</td>
<td>如果下一行有元素返回true</td>
</tr>
<tr>
<td>E next()</td>
<td>返回下一个元素</td>
</tr>
<tr>
<td>void remove()</td>
<td>移除当前元素</td>
</tr>
</tbody></table>
<h4 id="for-each遍历"><a href="#for-each遍历" class="headerlink" title="for-each遍历"></a>for-each遍历</h4><p>JDK5提供的一种特殊的遍历方式，统一所有容器的遍历形式</p>
<p>实现原理：内部使用迭代器进行遍历</p>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(定义一个与元素类型相同的变量  : 集合（数组）引用 )&#123;</span><br><span class="line">  <span class="comment">//每次循环从数组或集合中取出一个元素 为 变量赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历数组</span></span><br><span class="line"><span class="type">int</span>[] a = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">233</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i : a )&#123;<span class="comment">//每次循环从a数组中取出一个元素 为变量i赋值</span></span><br><span class="line">  System.out.print(i+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历集合</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;小叶&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;峰槐&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;锦哲&quot;</span>);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span>(String o  : list )&#123;<span class="comment">//每次循环从list集合中取出一个元素为o变量赋值</span></span><br><span class="line">  System.out.println( o );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历存储了自定义类型对象的集合    </span></span><br><span class="line"><span class="type">List</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list2.add( <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;wangyx&quot;</span>,<span class="number">18</span>,<span class="number">59D</span>) );</span><br><span class="line">list2.add( <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;yangdd&quot;</span>,<span class="number">22</span>,<span class="number">10000D</span>) );</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span>(Object obj: list2)&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">Worker</span> <span class="variable">w1</span> <span class="operator">=</span> (Worker)obj;<span class="comment">//向下转型</span></span><br><span class="line">  <span class="comment">//打印worker对象的每个属性</span></span><br><span class="line">  System.out.println(w1.getName()+<span class="string">&quot;\t&quot;</span>+w1.getAge()+<span class="string">&quot;\t&quot;</span>+w1.getSalary());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="forEach方法遍历"><a href="#forEach方法遍历" class="headerlink" title="forEach方法遍历"></a>forEach方法遍历</h4><p>JDK8提供的一种遍历方式，可以配合Lambda表达式一起使用</p>
<p>实现原理：内部使用迭代器进行遍历</p>
<p>实现原理：内部使用迭代器进行遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer action)</span></span><br></pre></td></tr></table></figure>

<p>Comsumer接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Consumer</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	实现Consumer接口，实现accept方法，参数为集合中的元素，forEach方法遍历时，会自动向该方法传入实参</p>
<p>例：匿名内部类实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Consumer</span> <span class="variable">con</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>() &#123;</span><br><span class="line">    <span class="comment">//实现accept方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        System.out.println( o ); <span class="comment">//打印元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用forEach方法，传入Consumer实现类对象</span></span><br><span class="line">list.forEach( con );</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>例：Lambda表达式实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.forEach( o -&gt; System.out.prsintln(a) );</span><br></pre></td></tr></table></figure>

<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>​	用于表示代码定义时无法进行确定的类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">泛型的使用：</span><br><span class="line">	1.声明泛型  &lt;泛型名&gt; 如：&lt;R&gt; &lt;T&gt; &lt;E&gt;</span><br><span class="line">	2.在程序不能确定类型的地方，使用泛型表示（占位）</span><br><span class="line">	3.使用泛型时，要为泛型赋上确切的类型名</span><br><span class="line">泛型和集合配合使用，可以对集合元素类型进行约束</span><br><span class="line">注意：如果集合类型没有明确泛型，那么等同于明确了Object，一行代码前后两处泛型必须相同，这这里没有多态!!!</span><br></pre></td></tr></table></figure>

<h2 id="CoreJavaDay21"><a href="#CoreJavaDay21" class="headerlink" title="CoreJavaDay21"></a>CoreJavaDay21</h2><h3 id="set集合"><a href="#set集合" class="headerlink" title="set集合"></a>set集合</h3><p>特点：Collection接口的子接口，无序、无下标、元素不可重复</p>
<p>常用方法：Set接口的方法均继承自Collection</p>
<p>使用Set集合存储元素</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Set集合对象</span></span><br><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用add方法添加元素</span></span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;wangyx&quot;</span>));</span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;yangdd&quot;</span>));</span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;huxz&quot;</span>));</span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;luxw&quot;</span>));</span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;wangyx&quot;</span>));</span><br><span class="line">    </span><br><span class="line">set.remove(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;wangyx&quot;</span>));<span class="comment">//删除内容一样的对象</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//set集合没有单独获取元素的方法</span></span><br><span class="line"><span class="comment">//只能遍历</span></span><br><span class="line"><span class="keyword">for</span>(String str : set )&#123;</span><br><span class="line">  System.out.println( str );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Set接口实现类"><a href="#Set接口实现类" class="headerlink" title="Set接口实现类"></a>Set接口实现类</h3><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>特点：由数组+链表进行存储，高效存取，内部的元素称为entry</p>
<p>HashSet存储结构示意：</p>
<p><img src="/javaNote.assets/34.png" alt="image-20230419153437381"></p>
<p>每个相同的对象拥有相同的hashCode，而不同的对象尽量拥有不同的hashCode</p>
<p>Object提供的的hashCode方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//native方法底层使用c++实现，并未在java代码中予以实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>测试hashCode方法</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建若干Student对象</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>( <span class="string">&quot;wangyx&quot;</span>,<span class="number">16</span>,<span class="number">100D</span> );</span><br><span class="line"><span class="type">Student</span> <span class="variable">stu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>( <span class="string">&quot;yangdd&quot;</span>,<span class="number">42</span>,<span class="number">59.9</span> );</span><br><span class="line"><span class="type">Student</span> <span class="variable">stu3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>( <span class="string">&quot;huxz&quot;</span>,<span class="number">72</span>,<span class="number">101D</span>  );</span><br><span class="line"><span class="type">Student</span> <span class="variable">stu4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>( <span class="string">&quot;luxw&quot;</span>,<span class="number">18</span>,<span class="number">100D</span>  );</span><br><span class="line"><span class="comment">//与stu1内容相同的对象</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">stu5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>( <span class="string">&quot;wangyx&quot;</span>,<span class="number">16</span>,<span class="number">100D</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">//对每个对象调用Object中的hashCode方法，打印结果</span></span><br><span class="line">System.out.println( stu1.hashCode() );<span class="comment">//93122545</span></span><br><span class="line">System.out.println( stu2.hashCode() );<span class="comment">//2083562754</span></span><br><span class="line">System.out.println( stu3.hashCode() );<span class="comment">//1239731077</span></span><br><span class="line">System.out.println( stu4.hashCode() );<span class="comment">//557041912</span></span><br><span class="line">System.out.println( stu5.hashCode() );<span class="comment">//1134712904</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	可以看出，内容相同的对象使用Object中的hashCode方法并不能返回相同的hashCode 因此当内容相同的对象添加到HashSet中，HashSet也会认为这是“不同”的对象，因此无法按照我们的意愿区分重复对象</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建若干Student对象</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>( <span class="string">&quot;wangyx&quot;</span>,<span class="number">16</span>,<span class="number">100D</span> );</span><br><span class="line"><span class="type">Student</span> <span class="variable">stu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>( <span class="string">&quot;yangdd&quot;</span>,<span class="number">42</span>,<span class="number">59.9</span> );</span><br><span class="line"><span class="type">Student</span> <span class="variable">stu3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>( <span class="string">&quot;huxz&quot;</span>,<span class="number">72</span>,<span class="number">101D</span>  );</span><br><span class="line"><span class="type">Student</span> <span class="variable">stu4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>( <span class="string">&quot;luxw&quot;</span>,<span class="number">18</span>,<span class="number">100D</span>  );</span><br><span class="line"><span class="comment">//与stu1内容相同的对象</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">stu5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>( <span class="string">&quot;wangyx&quot;</span>,<span class="number">16</span>,<span class="number">100D</span> );</span><br><span class="line"></span><br><span class="line">Set&lt;Student&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">set.add( stu1 );</span><br><span class="line">set.add( stu2 );</span><br><span class="line">set.add( stu3 );</span><br><span class="line">set.add( stu4 );</span><br><span class="line">set.add( stu5 );</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印set集合元素个数</span></span><br><span class="line">System.out.println( set.size() );<span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>覆盖Object类中的hashCode方法，根据属性生成HashCode </p>
<p>覆盖规范如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Objects.hash( 属性<span class="number">1</span>，属性<span class="number">2</span>,属性<span class="number">3.</span>...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Objects（JDK7）中提供的hash方法会根据属性的值，生成符合规则的哈希码 </p>
<p>例：为Student类覆盖hashCode方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line">    Integer age;</span><br><span class="line">    Double score;</span><br><span class="line">    <span class="comment">//构造方法略...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash( name, age, score );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">测试：</span><br><span class="line">    <span class="comment">//创建若干Student对象</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>( <span class="string">&quot;wangyx&quot;</span>,<span class="number">16</span>,<span class="number">100D</span> );</span><br><span class="line"><span class="type">Student</span> <span class="variable">stu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>( <span class="string">&quot;yangdd&quot;</span>,<span class="number">42</span>,<span class="number">59.9</span> );</span><br><span class="line"><span class="type">Student</span> <span class="variable">stu3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>( <span class="string">&quot;huxz&quot;</span>,<span class="number">72</span>,<span class="number">101D</span>  );</span><br><span class="line"><span class="type">Student</span> <span class="variable">stu4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>( <span class="string">&quot;luxw&quot;</span>,<span class="number">18</span>,<span class="number">100D</span>  );</span><br><span class="line"><span class="comment">//与stu1内容相同的对象</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">stu5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>( <span class="string">&quot;wangyx&quot;</span>,<span class="number">16</span>,<span class="number">100D</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">//对每个对象调用Object中的hashCode方法，打印结果</span></span><br><span class="line">System.out.println( stu1.hashCode() );<span class="comment">//93122545</span></span><br><span class="line">System.out.println( stu2.hashCode() );<span class="comment">//2083562754</span></span><br><span class="line">System.out.println( stu3.hashCode() );<span class="comment">//1239731077</span></span><br><span class="line">System.out.println( stu4.hashCode() );<span class="comment">//557041912</span></span><br><span class="line">System.out.println( stu5.hashCode() );<span class="comment">//93122545  stu5与stu1对象的内容一致，所以hashCode相同</span></span><br></pre></td></tr></table></figure>

<p>再次尝试向HashSet中添加元素，发现依然不能去除重复对象</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建若干Student对象</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>( <span class="string">&quot;wangyx&quot;</span>,<span class="number">16</span>,<span class="number">100D</span> );</span><br><span class="line"><span class="type">Student</span> <span class="variable">stu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>( <span class="string">&quot;yangdd&quot;</span>,<span class="number">42</span>,<span class="number">59.9</span> );</span><br><span class="line"><span class="type">Student</span> <span class="variable">stu3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>( <span class="string">&quot;huxz&quot;</span>,<span class="number">72</span>,<span class="number">101D</span>  );</span><br><span class="line"><span class="type">Student</span> <span class="variable">stu4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>( <span class="string">&quot;luxw&quot;</span>,<span class="number">18</span>,<span class="number">100D</span>  );</span><br><span class="line"><span class="comment">//与stu1内容相同的对象</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">stu5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>( <span class="string">&quot;wangyx&quot;</span>,<span class="number">16</span>,<span class="number">100D</span> );</span><br><span class="line"></span><br><span class="line">Set&lt;Student&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">set.add( stu1 );</span><br><span class="line">set.add( stu2 );</span><br><span class="line">set.add( stu3 );</span><br><span class="line">set.add( stu4 );</span><br><span class="line">set.add( stu5 );</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印set集合元素个数</span></span><br><span class="line">System.out.println( set.size() );<span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>原因：hashCode是一个整数，并不能保证绝对的唯一，有可能出现对象不同而hashCode相同的情况</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;柳柴&quot;</span>,<span class="number">16</span>,<span class="number">100D</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">stu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;柴柕&quot;</span>,<span class="number">16</span>,<span class="number">100D</span>);</span><br><span class="line"></span><br><span class="line">System.out.println( stu1.hashCode() );<span class="comment">//1897947248</span></span><br><span class="line">System.out.println( stu2.hashCode() );<span class="comment">//1897947248</span></span><br></pre></td></tr></table></figure>

<p>​	因此HashSet当发现hashCode相同时，为了避免出现上述情况，还会再次调用equals方法进行验证，而Object提供的equals方法并不能针对属性验证内容是否一致，所以还需要再覆盖Object中的equals方法。</p>
<p>例：为Student类提供equals方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    Integer age;</span><br><span class="line">    Double score;</span><br><span class="line">    <span class="comment">//构造方法略...</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//覆盖Object类中的equals方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) o;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(name, student.name) &amp;&amp; Objects.equals(age, student.age) &amp;&amp; Objects.equals(score, student.score);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//覆盖Object类中的hashCode方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age, score);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次测试，去重成功</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建若干Student对象</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>( <span class="string">&quot;wangyx&quot;</span>,<span class="number">16</span>,<span class="number">100D</span> );</span><br><span class="line"><span class="type">Student</span> <span class="variable">stu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>( <span class="string">&quot;yangdd&quot;</span>,<span class="number">42</span>,<span class="number">59.9</span> );</span><br><span class="line"><span class="type">Student</span> <span class="variable">stu3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>( <span class="string">&quot;huxz&quot;</span>,<span class="number">72</span>,<span class="number">101D</span>  );</span><br><span class="line"><span class="type">Student</span> <span class="variable">stu4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>( <span class="string">&quot;luxw&quot;</span>,<span class="number">18</span>,<span class="number">100D</span>  );</span><br><span class="line"><span class="comment">//与stu1内容相同的对象</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">stu5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>( <span class="string">&quot;wangyx&quot;</span>,<span class="number">16</span>,<span class="number">100D</span> );</span><br><span class="line"></span><br><span class="line">Set&lt;Student&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">set.add( stu1 );</span><br><span class="line">set.add( stu2 );</span><br><span class="line">set.add( stu3 );</span><br><span class="line">set.add( stu4 );</span><br><span class="line">set.add( stu5 );</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历set集合</span></span><br><span class="line">set.forEach( o-&gt;System.out.println(o) );</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">向HashSet集合中添加元素时，HashSet先调用元素中的hashCode方法，如果hashCode与其中的某个元素相同，则会再次调用equals方法验证两元素是否真正相同。</span><br><span class="line">为了确保HashSet能够正确去重，请为元素覆盖hashCode与equals两个方法</span><br></pre></td></tr></table></figure>

<p>为什么不直接使用equals方法验证两个对象是否重复？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为equals方法验证严谨，步骤较多，所以效率比较低，而hashCode是一个整数，比较时效率高很多</span><br></pre></td></tr></table></figure>

<p>HashSet去重过程</p>
<p><img src="/javaNote.assets/33.png" alt="image-20230419141211141"></p>
<p>HashSet去重</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.内容相同的对象有相同的hashCode()返回值</span><br><span class="line">2.要通过equal方法对比内容，那么自定义类型使用HashSet保存时，就需要重写equals</span><br></pre></td></tr></table></figure>

<h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><p>特点：去重机制与HashSet相同，但可以维护元素插入顺序</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建若干Student对象</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>( <span class="string">&quot;wangyx&quot;</span>,<span class="number">16</span>,<span class="number">100D</span> );</span><br><span class="line"><span class="type">Student</span> <span class="variable">stu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>( <span class="string">&quot;yangdd&quot;</span>,<span class="number">42</span>,<span class="number">59.9</span> );</span><br><span class="line"><span class="type">Student</span> <span class="variable">stu3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>( <span class="string">&quot;huxz&quot;</span>,<span class="number">72</span>,<span class="number">101D</span>  );</span><br><span class="line"><span class="type">Student</span> <span class="variable">stu4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>( <span class="string">&quot;luxw&quot;</span>,<span class="number">18</span>,<span class="number">100D</span>  );</span><br><span class="line"><span class="comment">//与stu1内容相同的对象</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">stu5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>( <span class="string">&quot;wangyx&quot;</span>,<span class="number">16</span>,<span class="number">100D</span> );</span><br><span class="line"></span><br><span class="line">Set&lt;Student&gt; set = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">set.add( stu1 );</span><br><span class="line">set.add( stu2 );</span><br><span class="line">set.add( stu3 );</span><br><span class="line">set.add( stu4 );</span><br><span class="line">set.add( stu5 );</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历set集合</span></span><br><span class="line">set.forEach( o -&gt; System.out.println( o.name ) );</span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="comment">//wangyx</span></span><br><span class="line"><span class="comment">//yangdd</span></span><br><span class="line"><span class="comment">//huxz</span></span><br><span class="line"><span class="comment">//luxw</span></span><br></pre></td></tr></table></figure>

<h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p>​	特点：可以自动对集合中的元素进行排序，元素必须实现Comparable接口</p>
<p>​	去重机制：根据Comparable接口中compareTo方法的返回值进行去重，如果返回值为0表示相同的对象</p>
<p>​	compareTo方法实现规范：遵循同异原则，当equals方法返回为true时，compareTo方法返回0，当equals方法返回为false时，compareTo方法返回非0</p>
<p>例：Student实现Comparable接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt;&#123;</span><br><span class="line">    String name;</span><br><span class="line">    Integer age;</span><br><span class="line">    Double score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现compareTo方法，如果name相同，验证age，如果age相同，验证score，排序规则亦是如此</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student stu)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span>name.compareTo(stu.name);</span><br><span class="line">        <span class="keyword">if</span>(result==<span class="number">0</span>) result = age.compareTo(stu.age);</span><br><span class="line">        <span class="keyword">if</span>(result==<span class="number">0</span>) result = score.compareTo(stu.score);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>set实现类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.HashSet  JDK1.2 使用（数组+链表+下标计算算法）散列表 实现  线程不安全</span><br><span class="line">2.LinkedHashSet  JDK1.2  保证遍历顺序和添加顺序相同  散列表+链表  线程不安全</span><br><span class="line">3.TreeSet  SortSet的实现类  JDK1.2  红黑树  线程不安全</span><br></pre></td></tr></table></figure>

<h3 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h3><p><img src="/javaNote.assets/image-20230419171705190.png" alt="image-20230419171705190"></p>
<h4 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h4><p>特点：一个元素由两个对象构成，分别作为Key与Value，无序，无下标，键不可重复，值可以重复，通过键访问值</p>
<p>Map接口的特点与字典相同</p>
<h4 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h4><table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>put(Object key,Object value)</td>
<td>向集合中添加一组键值对，如果键已存在则覆盖</td>
</tr>
<tr>
<td>get(Object key)</td>
<td>根据key返回value，如果key不存在 返回null</td>
</tr>
<tr>
<td>remove(Object key)</td>
<td>根据key移除一组键值对</td>
</tr>
<tr>
<td>containsKey(Object key)</td>
<td>判断key是否存在</td>
</tr>
<tr>
<td>containsValue(Object value)</td>
<td>判断value是否存在</td>
</tr>
<tr>
<td>size()</td>
<td>返回键值对数量</td>
</tr>
<tr>
<td>keySet()</td>
<td>返回所有的key</td>
</tr>
<tr>
<td>values()</td>
<td>返回所有的value</td>
</tr>
<tr>
<td>entrySet()</td>
<td>返回所有的entry（键值对）</td>
</tr>
</tbody></table>
<h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><p>例：创建一个Map集合，存储整数与对应的字符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建map集合</span></span><br><span class="line">Map&lt;Integer,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//添加键值对</span></span><br><span class="line">map.put(<span class="number">65</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">map.put(<span class="number">66</span>, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">map.put(<span class="number">67</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">map.put(<span class="number">68</span>, <span class="string">&quot;D&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据key获取value</span></span><br><span class="line"><span class="type">String</span> <span class="variable">value1</span> <span class="operator">=</span> map.get(<span class="number">65</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">value2</span> <span class="operator">=</span> map.get(<span class="number">80</span>);<span class="comment">//如果key不存在返回null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据key删除一组键值对</span></span><br><span class="line">map.remove( <span class="number">65</span> );</span><br><span class="line">    </span><br><span class="line"><span class="comment">//获取map集合键值对数量</span></span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> map.size();<span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断key是否存在</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> map.containsKey( <span class="number">65</span> );</span><br><span class="line">System.out.println( b1 );<span class="comment">//false</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//判断value是否存在</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> map.containsValue(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">System.out.println( b2 );<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h3 id="遍历Map集合"><a href="#遍历Map集合" class="headerlink" title="遍历Map集合"></a>遍历Map集合</h3><h4 id="键遍历"><a href="#键遍历" class="headerlink" title="键遍历"></a>键遍历</h4><p>​	特点：通过Map中的keySet方法，返回一个存储着所有key的Set集合，遍历该集合获取所有key</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Integer&gt; keys = map.keySet();<span class="comment">//返回Map集合中所有的key </span></span><br><span class="line"><span class="keyword">for</span>(String key : keys)&#123;</span><br><span class="line">  System.out.print(key+<span class="string">&quot;   &quot;</span>);<span class="comment">//打印key 不换行</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);<span class="comment">//通过key获取value</span></span><br><span class="line">  System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="值遍历"><a href="#值遍历" class="headerlink" title="值遍历"></a>值遍历</h4><p>​	特点：通过Map中的values方法，返回一个存储着所有value的Collection集合，遍历该集合获取所有的value</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; values = map.values();<span class="comment">//返回map集合中所有的value</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(String value : values)&#123;<span class="comment">//遍历集合中所有的value</span></span><br><span class="line">  System.out.println(value);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="键值遍历"><a href="#键值遍历" class="headerlink" title="键值遍历"></a>键值遍历</h4><p>​	特点：通过Map中的entrySet方法，返回一个存储着所有Entry（键值对）的Set集合，遍历该集合获取所有的键值对</p>
<p>Map.Entry是Map接口的内部接口，表示键值对</p>
<p>例：Map.Entry示意</p>
<p><img src="/javaNote.assets/35.png" alt="image-20230419172313100"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Map.Entry&lt;Integer,String&gt;&gt; set = map.entrySet();<span class="comment">//返回Map集合中所有的Map.Entry对象（一个Map.Entry对象代表一个键值对）</span></span><br><span class="line"><span class="keyword">for</span>( Map.Entry&lt;Integer, String&gt; entry:set)&#123;<span class="comment">//遍历Map集合中的键值对（Entry&lt;键类型,值类型&gt;)</span></span><br><span class="line"></span><br><span class="line">  <span class="type">String</span> <span class="variable">key</span>  <span class="operator">=</span>  entry.getKey();<span class="comment">//获取key</span></span><br><span class="line">  String value=  entry.getValue();<span class="comment">//获取value</span></span><br><span class="line">  </span><br><span class="line">  System.out.println(key+<span class="string">&quot;    &quot;</span>+value);           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="forEach方法遍历-1"><a href="#forEach方法遍历-1" class="headerlink" title="forEach方法遍历"></a>forEach方法遍历</h4><p>​	该方法需要一个BiComsumer接口的实现类，需要实现该接口的accept方法 accept方法中的两个参数分别表示Map集合中的某个key与value</p>
<p>例：使用匿名内部类实现，打印所有键值对</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map.forEach(<span class="keyword">new</span> <span class="title class_">BiConsumer</span>&lt;K,V&gt;()&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(K key,  V value)</span>&#123;</span><br><span class="line">       System.out.println( key+<span class="string">&quot;\t&quot;</span>+value);</span><br><span class="line">   &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>例：使用Lambda表达式实现，打印所有键值对</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.forEach( (k,v)-&gt;System.out.println(k+<span class="string">&quot;\t&quot;</span>+v) );</span><br></pre></td></tr></table></figure>

<p>Map接口实现类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.HashMap  JDK1.2  线程不安全 允许k-v为null</span><br><span class="line">2.LinkedHashMap JDK1.2  线程不安全  允许k-v为null  可以保证添加顺序和存储顺序一致</span><br><span class="line">3.Hashtable JDK1.0  线程安全  不允许k-v为null</span><br><span class="line">4.Properties JDK1.0  其内部保存的key和value，都是字符串类型</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="CoreJavaDay22"><a href="#CoreJavaDay22" class="headerlink" title="CoreJavaDay22"></a>CoreJavaDay22</h2><h3 id="I-O流"><a href="#I-O流" class="headerlink" title="I O流"></a>I O流</h3><p>​	作用：将程序中的数据发送到外部，或将外部的数据读入到程序的内部，使用IO流可以在不同的程序或容器间交换数据</p>
<p>​	位置：java.io包</p>
<p>相关概念：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> I（Input）输入：站在程序（代码）的角度上，将外部的数据读入到程序内部，称之为输入，例如Scanenr</span><br><span class="line"><span class="number">2.</span> O（Output）输出：站在程序（代码）的角度上，将内部的数据输送到程序外部，称之为输出，例如System.out.println</span><br><span class="line"><span class="number">3.</span> 流：用来传输数据的管道（对象），与生活中的网线、电线、水管、作用相似</span><br></pre></td></tr></table></figure>

<p>计算机数据的两大存储媒介</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 硬盘：硬盘是电脑中用来存放文件的数据存储设备，特点是存储容量大，不受断电影响，可以持久化存储数据，但数据传送速度慢。</span><br><span class="line">2. 内存：内存是计算机中硬盘数据和CPU数据交换的中转站，存储程序中需要经常运算或修改的数据，特点是存储容量小，电子读写，断电后内存中的数据就会被清除，只能存储临时数据，数据传输速度快，是硬盘速度的几倍乃至几十倍有余。</span><br></pre></td></tr></table></figure>

<p>​	IO操作通常用于内存与硬盘之间交互数据，将内存中的数据输送到硬盘某个文件中持久化存储（存档），也可以将硬盘中某个文件读取到程序中进行处理（读档）</p>
<p><img src="file://C:/Users/18060/Desktop/javaNote/photos/javaNote/36.png?lastModify=1682079305" alt="image-20230420143356140"></p>
<h3 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h3><h4 id="按照方向区分"><a href="#按照方向区分" class="headerlink" title="按照方向区分"></a>按照方向区分</h4><p>输入流：用以将程序外部的数据读入到程序内部，例如Scanner</p>
<p>输出流：用以将程序内部的数据输送到程序外部，例如System.out.println</p>
<h4 id="按照处理数据的单位区分"><a href="#按照处理数据的单位区分" class="headerlink" title="按照处理数据的单位区分"></a>按照处理数据的单位区分</h4><p>字节流：以字节为处理单位，可以处理所有类型的数据或文件，例如图片文件，视频文件等</p>
<p>字符流：以字符为单位处理数据，只可以处理文本类型的数据或文件，例如 记事本文件</p>
<h4 id="按照流的功能区分："><a href="#按照流的功能区分：" class="headerlink" title="按照流的功能区分："></a>按照流的功能区分：</h4><p>节点流：负责读写数据的流</p>
<p>过滤流：在节点流的基础上增加额外功能，需要依赖节点流</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.节点流：有实际传输能力的流，如FileInputStream，FileOutputStream</span><br><span class="line">2.过滤流：没有实际传输能力，不能直接用其完成数据的传输。用来给节点流增加额外功能的。</span><br></pre></td></tr></table></figure>



<h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><p>​	特点：以字节为单位处理数据，可以处理所有类型的数据或文件，例如图片文件、视频文件等</p>
<h4 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h4><p>特点：字节输出流父类（抽象类），可以将程序中的数据，输出到程序外部</p>
<p>常用方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>void write(int b)</td>
<td>写出一个字节的数据</td>
</tr>
<tr>
<td>void write(byte[] bs)</td>
<td>写出多个字节的数据</td>
</tr>
<tr>
<td>void close()</td>
<td>释放资源，关闭流</td>
</tr>
</tbody></table>
<p>例：向a.dat文件中写一个字符A</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向程序外部写一个字节数据</span></span><br><span class="line"><span class="comment">//FileOutputStream</span></span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;a.dat&quot;</span>);<span class="comment">//目标位置</span></span><br><span class="line">os.write(<span class="string">&#x27;A&#x27;</span>);<span class="comment">//将一个字节的数据输出到执行位置（指定文件中）</span></span><br><span class="line">os.close();<span class="comment">//关闭流</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>例：向a.dat中写多个字节数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;a.dat&quot;</span>);<span class="comment">//目标位置</span></span><br><span class="line"><span class="comment">//写一组数据</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;ABCDEFG~Z&quot;</span></span><br><span class="line"><span class="type">byte</span>[] bs = str.getBytes();<span class="comment">//将字符串转换为字节数组</span></span><br><span class="line">out.write(bs);<span class="comment">//写数据</span></span><br><span class="line">out.close();<span class="comment">//关闭流</span></span><br></pre></td></tr></table></figure>

<h4 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h4><p>特点：字节输入流父类（抽象类），可以将外部的数据读入到程序内部</p>
<p>常用方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
<th>since</th>
</tr>
</thead>
<tbody><tr>
<td>int read()</td>
<td>读取一个字节的数据并返回，如果数据已读完则返回 -1</td>
<td>—</td>
</tr>
<tr>
<td>byte[] readNBytes(int len)</td>
<td>读取指定len个字节并返回，如果数据已读完则返回空数组</td>
<td>11</td>
</tr>
<tr>
<td>byte[] readAllBytes()</td>
<td>读取剩余的所有字节，上限为<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Integer.html#MAX_VALUE">Integer.MAX_VALUE</a></td>
<td>9</td>
</tr>
<tr>
<td>long transferTo(OutputStream)</td>
<td>将读取到的字节交给os并写出，返回读到的字节数</td>
<td>9</td>
</tr>
<tr>
<td>void close()</td>
<td>释放资源，关闭流</td>
<td>—</td>
</tr>
</tbody></table>
<p>transferTo方法内部支持缓存，默认为8192字节</p>
<p>例：从a.dat中读取一个字节的数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从a.dat中读取一个字节的数据</span></span><br><span class="line"><span class="comment">//FileInputStream</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;a.dat&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> is.read();<span class="comment">//读取一个字节的数据</span></span><br><span class="line">System.out.println((<span class="type">char</span>)b);</span><br><span class="line">is.close();<span class="comment">//关闭流</span></span><br></pre></td></tr></table></figure>

<p>例：从a.dat中读取3个字节数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;a.dat&quot;</span>);</span><br><span class="line"><span class="type">byte</span>[] bs = is.readNBytes(<span class="number">3</span>);<span class="comment">//读取3个字节的数据</span></span><br><span class="line"><span class="comment">//遍历输出结果</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">byte</span> b : bs) &#123;</span><br><span class="line">    System.out.print((<span class="type">char</span>)b);</span><br><span class="line">&#125;</span><br><span class="line">is.close();</span><br></pre></td></tr></table></figure>

<p>l例：将a.dat 文件中的内容拷贝到b.dat</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;a.dat&quot;</span>);<span class="comment">//创建输入流，读取文件</span></span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;a.dat&quot;</span>);<span class="comment">//创建输出流，写文件</span></span><br><span class="line"><span class="type">long</span> <span class="variable">r</span> <span class="operator">=</span> is.transferTo( os );<span class="comment">//将is中的内容写到os中</span></span><br><span class="line">is.close();<span class="comment">//关闭流，释放资源</span></span><br><span class="line">os.close();<span class="comment">//关闭流，释放资源</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="字节流节点流"><a href="#字节流节点流" class="headerlink" title="字节流节点流"></a>字节流节点流</h3><h4 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h4><p>作用：如果系统允许，可以将数据写到系统中的某个文件中</p>
<p>常用构造方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/FileOutputStream.html#(java.lang.String)"><strong>FileOutputStream</strong></a><strong>(</strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/String.html"><strong>String</strong></a>** name)**</td>
<td>创建一个与name所述相同的文件，如果文件已存在，则被覆盖</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/FileOutputStream.html#(java.lang.String,boolean)"><strong>FileOutputStream</strong></a><strong>(</strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/String.html"><strong>String</strong></a>** name,boolean append)**</td>
<td>创建一个与name所述相同的文件，如果append为true文件已存在时直接在原文件中追加内容，反之会创建新文件，覆盖原文件</td>
</tr>
</tbody></table>
<h4 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h4><p>作用：读取某个文件中的内容</p>
<p>常用构造方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/FileInputStream.html#(java.lang.String)"><strong>FileInputStream</strong></a><strong>(</strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/String.html"><strong>String</strong></a>** name)**</td>
<td>从name所述的文件中读取数据，如果文件不存在或是目录则抛出<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/FileNotFoundException.html">FileNotFoundException</a></td>
</tr>
</tbody></table>
<h3 id="字节流过滤流"><a href="#字节流过滤流" class="headerlink" title="字节流过滤流"></a>字节流过滤流</h3><h4 id="ObjectOutputStream"><a href="#ObjectOutputStream" class="headerlink" title="ObjectOutputStream"></a>ObjectOutputStream</h4><p>​	作用：如果系统允许，可以将数据写到系统中的某个文件中，支持8种基本类型数据与对象类型数据</p>
<p>常用构造方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/ObjectOutputStream.html#(java.io.OutputStream)"><strong>ObjectOutputStream</strong></a><strong>(</strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/OutputStream.html"><strong>OutputStream</strong></a>** **<strong>out)</strong></td>
<td>构建Object过滤流对象，需要（依赖）传入<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/OutputStream.html">OutputStream</a>节点流对象将数据写到目标位置</td>
</tr>
</tbody></table>
<p>常用方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>void writerShort(int val)</td>
<td>将一个short类型的数据写到目标位置</td>
</tr>
<tr>
<td>void writeInt(int val)</td>
<td>将一个int类型的数据写到目标位置</td>
</tr>
<tr>
<td>void writeFloat(float val)</td>
<td>将一个float类型的数据写到目标位置</td>
</tr>
<tr>
<td>void writeDouble(double val)</td>
<td>将一个double类型的数据写到目标位置</td>
</tr>
<tr>
<td>void writeBoolean(boolean val)</td>
<td>将一个boolean类型的数据写到目标位置</td>
</tr>
<tr>
<td>void writeObject(Object val)</td>
<td>将任意类型的对象写到目标位置</td>
</tr>
</tbody></table>
<p>例：在a.dat文件中写出多种类型数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建节点流</span></span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;a.dat&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.封装过滤流</span></span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>( os );</span><br><span class="line"></span><br><span class="line"> <span class="comment">//3.读写数据</span></span><br><span class="line">oos.writeInt( <span class="number">100</span> );<span class="comment">//向外输出一个int类型数据</span></span><br><span class="line">oos.writeDouble( <span class="number">200.5</span>);<span class="comment">//向外输出一个double类型数据</span></span><br><span class="line">oos.writeBoolean( <span class="literal">true</span> );<span class="comment">//向外输出一个boolean类型数据</span></span><br><span class="line">        </span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//创建list集合对象</span></span><br><span class="line">list.add(<span class="string">&quot;yangdd&quot;</span>);<span class="comment">//在集合中添加数据</span></span><br><span class="line">list.add(<span class="string">&quot;wangyx&quot;</span>);</span><br><span class="line"></span><br><span class="line">oos.writeObject( list );<span class="comment">//向外输出一个list对象类型数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.关闭流</span></span><br><span class="line">oos.close();</span><br></pre></td></tr></table></figure>

<h4 id="ObjectInputStream"><a href="#ObjectInputStream" class="headerlink" title="ObjectInputStream"></a>ObjectInputStream</h4><p>​	作用：读取某个文件中的数据，支持8种基本数据类型与对象类型数据</p>
<p>​	构造方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>ObjectInputStream(InputStream   is)</td>
<td>构建Object过滤流对象，需要（依赖）传入<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/InputStream.html">InputStream</a>节点流对象，读取目标文件中的数据</td>
</tr>
</tbody></table>
<p>常用方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>short  readShort()</td>
<td>读取一个short类型数据并返回</td>
</tr>
<tr>
<td>int readInt( )</td>
<td>读取一个int类型数据并返回</td>
</tr>
<tr>
<td>float readFloat()</td>
<td>读取一个float类型数据并返回</td>
</tr>
<tr>
<td>double readDouble()</td>
<td>读取一个double类型数据并返回</td>
</tr>
<tr>
<td>boolean  readBoolean()</td>
<td>读取一个boolean类型数据并返回</td>
</tr>
<tr>
<td>Object  readObject()</td>
<td>读取任意对象类型的数据并返回</td>
</tr>
</tbody></table>
<p>例：从a.dat文件中读取多种类型的数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建节点流</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;a.dat&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.封装过滤流</span></span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>( is );</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.读写数据</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ois.readInt();<span class="comment">//读取一个int类型的数据</span></span><br><span class="line">System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> ois.readDouble();<span class="comment">//读取一个double类型的数据</span></span><br><span class="line">System.out.println(<span class="string">&quot;d = &quot;</span> + d);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> ois.readBoolean();<span class="comment">//读取一个boolean类型的数据</span></span><br><span class="line">System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line"><span class="type">List</span> <span class="variable">li</span> <span class="operator">=</span> (List)ois.readObject();<span class="comment">//读取一个List类型的数据</span></span><br><span class="line">System.out.println(<span class="string">&quot;li = &quot;</span> + li);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.关闭流</span></span><br><span class="line">ois.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">i = <span class="number">100</span></span><br><span class="line">d = <span class="number">200.5</span></span><br><span class="line">b = <span class="type">true</span></span><br><span class="line"><span class="variable">li</span> <span class="operator">=</span> [yangdd, wangyx]</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：如果文件中的数据已读完，再次进行读取操作时会抛出EOFException表示已达到结尾</p>
<h3 id="I-O异常处理"><a href="#I-O异常处理" class="headerlink" title="I O异常处理"></a>I O异常处理</h3><h4 id="传统处理方式"><a href="#传统处理方式" class="headerlink" title="传统处理方式"></a>传统处理方式</h4><p>例如：在a.dat中读写数据并处理异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//由于需要在finally中使用oos关闭资源，所以要声明在try框外面</span></span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//由于需要在finally中使用ois关闭资源，所以要声明在try框外面</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//1.创建节点流</span></span><br><span class="line">      <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;a.dat&quot;</span>);</span><br><span class="line">      <span class="comment">//2.封装过滤流</span></span><br><span class="line">      oos = <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(os);</span><br><span class="line">      <span class="comment">//3.读写数据</span></span><br><span class="line">      oos.writeInt(<span class="number">100</span>);<span class="comment">//向外输出一个int类型数据</span></span><br><span class="line">      <span class="comment">//4.关闭流</span></span><br><span class="line">      oos.close();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//1.创建节点流</span></span><br><span class="line">      <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;a.dat&quot;</span>);</span><br><span class="line">      <span class="comment">//2.封装过滤流</span></span><br><span class="line">      ois = <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(is);</span><br><span class="line">      <span class="comment">//3.读写数据</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ois.readShort();<span class="comment">//读取一个int类型的数据</span></span><br><span class="line">      System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">      <span class="comment">//4.关闭流</span></span><br><span class="line">      ois.close();</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">      <span class="comment">//单独处理close方法出现的异常，避免关闭某个资源时出现异常导致另一个资源没有关闭</span></span><br><span class="line">      <span class="keyword">try</span>&#123;<span class="keyword">if</span>(oos!=<span class="literal">null</span>)oos.close();&#125;<span class="keyword">catch</span>(Exception e)&#123;e.printStackTrace();&#125;</span><br><span class="line">      <span class="keyword">try</span>&#123;<span class="keyword">if</span>(ois!=<span class="literal">null</span>)ois.close();&#125;<span class="keyword">catch</span>(Exception e)&#123;e.printStackTrace();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JDK7-try-with-resources处理异常并自动关闭资"><a href="#JDK7-try-with-resources处理异常并自动关闭资" class="headerlink" title="JDK7 try-with-resources处理异常并自动关闭资"></a>JDK7 try-with-resources处理异常并自动关闭资</h4><p>语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(</span><br><span class="line">  <span class="comment">//构建需要关闭资源的对象</span></span><br><span class="line">)&#123;</span><br><span class="line">  <span class="comment">//可能会出现异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">  <span class="comment">//处理异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例：在a.dat中写出数据并处理异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(<span class="comment">//1.创建节点流</span></span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;a.dat&quot;</span>);</span><br><span class="line">    <span class="comment">//2.封装过滤流</span></span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(os);</span><br><span class="line">)&#123;</span><br><span class="line">    <span class="comment">//3.读写数据</span></span><br><span class="line">    oos.writeInt(<span class="number">100</span>);<span class="comment">//向外输出一个int类型数据</span></span><br><span class="line">           </span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：try-with-resources机制只能用在实现了AotuCloseable的类</p>
<h2 id="CoreJavaDay23"><a href="#CoreJavaDay23" class="headerlink" title="CoreJavaDay23"></a>CoreJavaDay23</h2><h3 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h3><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p>对象序列化：将JVM中的对象转换成二进制字节的形式在流中传输</p>
<p><img src="/javaNote.assets/37.png" alt="image-20230421203035364"></p>
<p>对象反序列化：将程序外部以字节形式存在的对象，读取到JVM中，合成为一个对象</p>
<p><img src="/javaNote.assets/38.png" alt="image-20230421203123030"></p>
<h4 id="序列化授权"><a href="#序列化授权" class="headerlink" title="序列化授权"></a>序列化授权</h4><p>概念：在Java中为了出于安全的考虑，并不是所有的对象都可以在流中传输进行共享，如果需要在流中传输对象就必须进行授权</p>
<p>授权的方式：实现<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/Serializable.html">java.io.Serializable</a>接口</p>
<p>此接口的源码如下，是一种标识型接口，没有方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Serializable</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>授权的作用：告知JVM此类对象可以在流中传输</p>
<p>未授权的结果：在流中传输对象时会产生NotSerializableException （不可序列化异常）</p>
<p>例：将Student对象写到a.dat文件中再读取</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;<span class="comment">//实现Serializable接口，授权</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Double score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, Integer age, Double score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123; name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age +<span class="string">&quot;, score=&quot;</span> + score +<span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Object流将Student对象写到a.dat文件中（序列化）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建节点流</span></span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;a.dat&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.封装过滤流</span></span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>( os );</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.读写数据</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;wangyx&quot;</span>,<span class="number">12</span>,<span class="number">100.0</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">stu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;yangdd&quot;</span>,<span class="number">20</span>,<span class="number">95.5</span>);</span><br><span class="line">oos.writeObject(stu);<span class="comment">//将对象拆分为二进制字节的形式写到文件中 </span></span><br><span class="line">oos.writeObject(stu2);<span class="comment">//将对象拆分为二进制字节的形式写到文件中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.关闭流</span></span><br><span class="line">oos.close();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用Object流将a.dat文件中的内容读取到程序中合并成Student对象（反序列化）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建节点流</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;a.dat&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.封装过滤流</span></span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>( is );</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.读写数据</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">stu3</span> <span class="operator">=</span> (Student)ois.readObject();<span class="comment">//将a.dat文件中的二进制字节合并为一个对象</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">stu4</span> <span class="operator">=</span> (Student)ois.readObject();<span class="comment">//将a.dat文件中的二进制字节合并为一个对象</span></span><br><span class="line">System.out.println( stu3 );</span><br><span class="line">System.out.println( stu4 );</span><br><span class="line"></span><br><span class="line"> <span class="comment">//4.关闭流</span></span><br><span class="line">oos.close();</span><br></pre></td></tr></table></figure>

<p> 序列化相关补充</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. JDK中常用的类和接口很多已经实现了Serializable便于我们后续使用，例如：8种包装类、String、ArrayList、HashSet、HashMap等等</span><br><span class="line">2. 序列化对象时，必须保证其所有属性均可序列化,例如：如果希望将Student写到文件中，除了要保证Student可以被序列化也要保证其属性String name、Integer age、Double score 这些类也可以被序列化。</span><br><span class="line">3. 序列化对象为集合时，必须保证其所有元素都是可序列化的</span><br><span class="line">4. 使用transient修饰符修饰属性，可以让其不参与序列化过程，不会拆分为字节在流中传输</span><br></pre></td></tr></table></figure>

<h3 id="字符与乱码"><a href="#字符与乱码" class="headerlink" title="字符与乱码"></a>字符与乱码</h3><h4 id="字符的存储形式与传输形式"><a href="#字符的存储形式与传输形式" class="headerlink" title="字符的存储形式与传输形式"></a>字符的存储形式与传输形式</h4><p>​	在计算机中，任何数据都是以字节的形式存储的，字符也不例外，当我们在文件中存储一个字符时，实际存储的是一段“编码”，该编码会映射（对应）一个字符，在打开文件时，由打开文件的工具负责将此“编码”再转换为字符</p>
<p>例：</p>
<p><img src="/javaNote.assets/39.png" alt="image-20230421204038566"></p>
<h4 id="字符集与编码方式"><a href="#字符集与编码方式" class="headerlink" title="字符集与编码方式"></a>字符集与编码方式</h4><p>​	作用：明确字符与“编号”的映射（对应）关系与存储形式，一般情况下字符集只有一套存储形式，所以字符集与编码方式可以理解为“同义词</p>
<p>常见的字符集与编码方式</p>
<table>
<thead>
<tr>
<th>字符集</th>
<th>编码方式</th>
<th>字符容量</th>
<th>所占空间</th>
<th>所含字符</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/ASCII/309296?fr=aladdin"><strong>ASCII</strong></a></td>
<td>-</td>
<td>128</td>
<td>1b</td>
<td>英文字母+标点符号+控制字符</td>
</tr>
<tr>
<td><a href="EASCII"><strong>EASCII</strong></a></td>
<td>-</td>
<td>256</td>
<td>1b</td>
<td>兼容ASCII+额外符号+希腊字母</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%BF%A1%E6%81%AF%E4%BA%A4%E6%8D%A2%E7%94%A8%E6%B1%89%E5%AD%97%E7%BC%96%E7%A0%81%E5%AD%97%E7%AC%A6%E9%9B%86/8074272?fromtitle=GB2312&fromid=483170&fr=aladdin"><strong>GB2312</strong></a></td>
<td>-</td>
<td>7445</td>
<td>2b</td>
<td>兼容ASCII+简体中文+中文符号</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%A4%A7%E4%BA%94%E7%A0%81?fromtitle=Big5&fromid=1780793"><strong>BIG5</strong></a></td>
<td>-</td>
<td>13060</td>
<td>2b</td>
<td>兼容ASCII+繁体中文+中文符号</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/GBK%E5%AD%97%E5%BA%93?fromtitle=GBK&fromid=481954"><strong>GBK</strong></a></td>
<td>-</td>
<td>21886</td>
<td>1~2b</td>
<td>兼容ASCII+中文字符+特殊符号</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/gb18030/3204518?fr=aladdin"><strong>GB18030</strong></a></td>
<td>-</td>
<td>70244</td>
<td>1~4b</td>
<td>兼容ASCII+GB系列+BIG5+少数民族字符+扩展符号</td>
</tr>
<tr>
<td><strong>Unicode</strong></td>
<td><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/UTF-8/481798"><strong>UTF-8</strong></a><br><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/UTF-16"><strong>UTF-16</strong></a><br><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/UTF-32"><strong>UTF-32</strong></a></td>
<td>144697</td>
<td>1<del>4b<br>2</del>4b<br>4b</td>
<td>兼容ASCII+N国字符+特殊字符+表情符号</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. ASCII（Amarican Standard Code for Information Interchange）美国标准信息交换代码</span><br><span class="line">2. EASCII（Extended ASCII）扩展美国标准信息交换代码</span><br><span class="line">3. Unicode（USC）：统一编码、万国码</span><br><span class="line"></span><br><span class="line">编码与解码：</span><br><span class="line">1. ASCII（Amarican Standard Code for Information Interchange）美国标准信息交</span><br></pre></td></tr></table></figure>

<h4 id="乱码"><a href="#乱码" class="headerlink" title="乱码"></a>乱码</h4><p>1概念：字符在编解码过程中出现的问题，无法将字节转换成原来的文字</p>
<p>原因1：编解码方式不同</p>
<p>例：Linux 默认使用UTF-8，Windos默认使用GBK，传输数据时</p>
<p><img src="/javaNote.assets/40.png" alt="image-20230421204336603"></p>
<p>原因2：字符的完整性被破坏</p>
<p>​	计算机是以字节为单位处理数据的，由于字符可能占用多个字节，如果还是以单个字节的形式去处理字符，那么一个字符的完整性将得不到保证</p>
<p>例：使用字节流向文件中输出一个中文字符</p>
<h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><p> –在内部保证一个字符的完整性-用字节流write一个汉字</p>
<h4 id="字符流父类"><a href="#字符流父类" class="headerlink" title="字符流父类"></a>字符流父类</h4><p>Writer（输出流）–10224</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String str)</span> <span class="comment">//写入一个字符串 -1代表结束</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String str, <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="comment">//写入字符串的一部</span></span><br></pre></td></tr></table></figure>

<p>Writer（输出流）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span><span class="comment">//读一个字符</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">char</span>[] cbuf)</span><span class="comment">//读多个字符 保存到cbuf中</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">char</span>[] cbuf, <span class="type">int</span> off, <span class="type">int</span> len)</span></span><br></pre></td></tr></table></figure>

<p>使用案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向a.txt中输入一段中文</span></span><br><span class="line"><span class="type">Writer</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">w.write(<span class="string">&quot;床前明月光&quot;</span>);</span><br><span class="line">w.close();</span><br><span class="line">      </span><br><span class="line"><span class="comment">//读取a.txt文件中的内容</span></span><br><span class="line"><span class="type">Reader</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> r.read();</span><br><span class="line">  <span class="keyword">if</span>(a==-<span class="number">1</span>)<span class="keyword">break</span>;</span><br><span class="line">  System.out.println((<span class="type">char</span>)a);</span><br><span class="line">&#125;  </span><br><span class="line">r.close();</span><br></pre></td></tr></table></figure>

<h4 id="字符节点流【重点】"><a href="#字符节点流【重点】" class="headerlink" title="字符节点流【重点】"></a>字符节点流【重点】</h4><p>FileWriter： 字符文件输出流 </p>
<p>FileReader： 字符文件输入流</p>
<h4 id="字符过滤流"><a href="#字符过滤流" class="headerlink" title="字符过滤流"></a>字符过滤流</h4><p>BufferedWriter ：带缓冲8192的字符输出流，内部提供了一个newLine()方法根据平台的不同可以使用不同的换行符进行换行 </p>
<p>BufferedReader： 带缓冲8192的字符输入流，内部提供了一个readLine()方法一次读取一行文字，读取完毕后该方法返回null</p>
<p>使用案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向a.txt中输入一段中文</span></span><br><span class="line"><span class="type">Writer</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line"><span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>( w );</span><br><span class="line">bw.write(<span class="string">&quot;床前明月光&quot;</span>);<span class="comment">//\n表示newLine \r 表示return \r\n   \r  \n </span></span><br><span class="line">bw.newLine();<span class="comment">//换行</span></span><br><span class="line">bw.write(<span class="string">&quot;撒了一碗汤&quot;</span>);</span><br><span class="line">bw.close();</span><br><span class="line">        </span><br><span class="line"><span class="comment">//读取a.txt文件中的内容</span></span><br><span class="line"><span class="type">Reader</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>( r );</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> br.readLine();<span class="comment">//读取一行文字,达到文件结尾返回null  </span></span><br><span class="line">  <span class="keyword">if</span>(str==<span class="literal">null</span>)<span class="keyword">break</span>;</span><br><span class="line">  System.out.println( str );</span><br><span class="line">&#125;</span><br><span class="line">r.close();</span><br></pre></td></tr></table></figure>

<p>PrintWriter：带缓冲的可以将所有数据类型转换字符输出，支持换行，本身也是一个节点流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">pw.println(<span class="string">&quot;床前明月光&quot;</span>);</span><br><span class="line">pw.println(<span class="string">&quot;撒了一碗汤&quot;</span>);</span><br><span class="line">pw.println(<span class="string">&quot;举头拿毛巾&quot;</span>);</span><br><span class="line">pw.println(<span class="string">&quot;低头擦裤裆&quot;</span>);</span><br><span class="line">pw.close();</span><br></pre></td></tr></table></figure>

<h4 id="桥转换-OutputStreamWriter-InputStreamReader"><a href="#桥转换-OutputStreamWriter-InputStreamReader" class="headerlink" title="桥转换 OutputStreamWriter &#x2F;InputStreamReader"></a>桥转换 OutputStreamWriter &#x2F;InputStreamReader</h4><p>​	作用：将字节流转换为字符流，在转换过程中可以自己定义编码方式 默认字符流使用的编码与操作系统相关 windos系统默认 GBK</p>
<p>Bridge</p>
<p>–读取文件—字节—字符的过程–自动分配编码，手动分配编码</p>
<p>需求：1.设置编码格式、2.转换字符流–System.in</p>
<p>使用场景1：按照指定编码读取文本文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符流读取文件时默认编码方式与操作系统有关  GBK</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.txt&quot;</span>);<span class="comment">//字节流</span></span><br><span class="line"><span class="comment">//桥转换流 将字节流转换为字符流 转换时可以指定编码方式</span></span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is,<span class="string">&quot;UTF-8&quot;</span>);<span class="comment">//将读到的字节转换为字符</span></span><br><span class="line"><span class="comment">//过滤流</span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>( isr );</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">  <span class="keyword">if</span>(str==<span class="literal">null</span>)<span class="keyword">break</span>;</span><br><span class="line">  System.out.println( str );</span><br><span class="line">&#125;</span><br><span class="line">br.close();</span><br></pre></td></tr></table></figure>

<p>使用场景2：将字节流转换为字符流</p>
<p>案例：模仿Scanner从控制台中读取数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> System.in;<span class="comment">//由System提供，从控制台中读取数据，使用read方法时会阻塞 等待输入</span></span><br><span class="line"><span class="comment">//桥转换，将字节流转换为字符流</span></span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>( is );</span><br><span class="line"><span class="comment">//使用Buffered读取一行</span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>( isr );</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> br.readLine();<span class="comment">//读取一个字符</span></span><br><span class="line">System.out.println(str+<span class="string">&quot;------------&gt;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>File类</p>
<p>作用：表示一个目录或一个文件 可以作为节点的流参数，表示目标路径</p>
<p>方法：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>方法名</td>
<td>作用</td>
</tr>
<tr>
<td>createNewFile( )</td>
<td>创建一个文件，如果文件已存在不会覆盖</td>
</tr>
<tr>
<td>mkdir( )</td>
<td>创建一个新的目录（文件夹）</td>
</tr>
<tr>
<td>delete(  )</td>
<td>删除一个文件或空目录</td>
</tr>
<tr>
<td>exists( )</td>
<td>判断File对象表示的文件（目录）是否存在</td>
</tr>
<tr>
<td>getAbsolutePath( )</td>
<td>获得文件的绝对路径</td>
</tr>
<tr>
<td>getName()</td>
<td>获得文件名</td>
</tr>
<tr>
<td>getParent( )</td>
<td>获得文件所在目录</td>
</tr>
<tr>
<td>File[] listFiles()</td>
<td>如果File对象是目录，返回目中所有的File对象</td>
</tr>
<tr>
<td>File[] listFiles(FileFilter f )</td>
<td>获取满足 文件过滤器指定的文件</td>
</tr>
</tbody></table>
<p>递归删除文件目录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">deleteDir</span><span class="params">(File dir)</span>&#123;</span><br><span class="line">File[] fs = dir.listFiles();</span><br><span class="line">    <span class="keyword">for</span>(File f:fs)&#123;</span><br><span class="line">        <span class="keyword">if</span>(f.isDirectory())deleteDir(f);</span><br><span class="line">        f.delete();</span><br><span class="line">    &#125;</span><br><span class="line">    dir.delete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="过滤文件"><a href="#过滤文件" class="headerlink" title="过滤文件"></a>过滤文件</h4><p>查找目录所有.xml文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">findFiles</span><span class="params">(File f)</span>&#123;</span><br><span class="line">    File[] fs = f.listFiles(<span class="keyword">new</span> <span class="title class_">FileFilter</span>()&#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">accept</span><span class="params">(File file)</span> &#123;</span><br><span class="line">          <span class="keyword">if</span>(file.isDirectory())<span class="keyword">return</span>  <span class="literal">true</span>;</span><br><span class="line">           <span class="comment">//if(file.getName().endsWith(&quot;.xml&quot;))return true;</span></span><br><span class="line">            <span class="comment">//return false;</span></span><br><span class="line">            <span class="keyword">return</span> file.getName().endsWith(<span class="string">&quot;.xml&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (File file : fs) &#123;</span><br><span class="line">            <span class="keyword">if</span>(file.isFile()) System.out.println(file.getAbsolutePath());</span><br><span class="line">            <span class="keyword">if</span>(file.isDirectory())findFiles(file);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="I-O总结"><a href="#I-O总结" class="headerlink" title="I O总结"></a>I O总结</h3><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>类名</strong></td>
<td><strong>作用</strong></td>
</tr>
<tr>
<td>InputStream</td>
<td>字节输入流父类</td>
</tr>
<tr>
<td>OutputStream</td>
<td>字节输出流父类</td>
</tr>
<tr>
<td>FileInputStream</td>
<td>字节输入节点流</td>
</tr>
<tr>
<td>FileOutputStream</td>
<td>字节输出节点流</td>
</tr>
<tr>
<td>BufferedInputStream</td>
<td>字节输入缓冲过滤流（带缓冲）</td>
</tr>
<tr>
<td>BufferedOutputStream</td>
<td>字节输出缓冲过滤流（带缓冲）</td>
</tr>
<tr>
<td>ObjectInputStream</td>
<td>字节输入过滤流（带缓冲，读8中基本数据类型+对象）</td>
</tr>
<tr>
<td>ObjectOutputStream</td>
<td>字节输出过滤流（带缓冲，写8种基本数据类型+对象）</td>
</tr>
<tr>
<td>PrintStream</td>
<td>以字节为单位将8种基本数据类型与对象转换为字符串输出到目标路径</td>
</tr>
<tr>
<td>Reader</td>
<td>字符输入流父类</td>
</tr>
<tr>
<td>Writer</td>
<td>字符输出流父类</td>
</tr>
<tr>
<td>FileReader</td>
<td>字符输入节点流</td>
</tr>
<tr>
<td>FileWriter</td>
<td>字符输出节点流</td>
</tr>
<tr>
<td>BufferedReader</td>
<td>字符输入缓冲过滤流（内部提供了readLine() 方法读取一行文字）</td>
</tr>
<tr>
<td>BufferedWriter</td>
<td>字符输出缓冲过滤流</td>
</tr>
<tr>
<td>PrintWriter</td>
<td>以字符为单位将任意类型转换为字符串并输出</td>
</tr>
<tr>
<td>InputStreamReader</td>
<td>字符桥转换流（将字节输入流转换为字符输入流，可以自定义编码格式）</td>
</tr>
<tr>
<td>OutputStreamWriter</td>
<td>字符桥转换流（将字节输出流转换为字符输出流，可以自定义编码格式）</td>
</tr>
<tr>
<td>File</td>
<td>表示磁盘中的一个文件，可以通过File对象操作磁盘文件，也可以作为流对象的参数</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[<span class="comment">//1.创建节点流](//1.xn--5brr72ak7kqldo82a)</span></span><br><span class="line"></span><br><span class="line">  <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;a.dat&quot;</span>);</span><br><span class="line"></span><br><span class="line">  [<span class="comment">//2.封装过滤流](//2.xn--ket641b59ae30dklh)</span></span><br><span class="line"></span><br><span class="line">  <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>( is );</span><br><span class="line"></span><br><span class="line">  [<span class="comment">//3.读写数据](//3.xn--g7qq84bbobv67e)</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ois.readInt();<span class="comment">//读取一个int类型的数据</span></span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> ois.readDouble();<span class="comment">//读取一个double类型的数据</span></span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">&quot;d = &quot;</span> + d);</span><br><span class="line"></span><br><span class="line">  <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> ois.readBoolean();<span class="comment">//读取一个boolean类型的数据</span></span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line"></span><br><span class="line">  <span class="type">List</span> <span class="variable">li</span> <span class="operator">=</span> (List)ois.readObject();<span class="comment">//读取一个List类型的数据</span></span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">&quot;li = &quot;</span> + li);</span><br><span class="line"></span><br><span class="line">  [<span class="comment">//4.关闭流](//4.xn--d6qt19dp21a)</span></span><br><span class="line"></span><br><span class="line">  ois.close();</span><br></pre></td></tr></table></figure>

<h2 id="CoreJavaDay24"><a href="#CoreJavaDay24" class="headerlink" title="CoreJavaDay24"></a>CoreJavaDay24</h2><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>程序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  就是一个拥有特定功能的软件，本质上就是一堆可运行的文件的合集，程序运行前就是存储在磁盘中的文件，程序运行时 额外需要内存，CPU等其它硬件资源</span><br><span class="line">  内存：不同程序使用不同位置的内存</span><br><span class="line">  CPU资源：所有资资源共享，分时间片 微观上串行，宏观上并行的方式</span><br><span class="line">  进程：每一个运行的程序它的资源合集，运行时的程序因这些资源而存在，运行时的程序就是进程</span><br><span class="line">  线程：一个OS可以运行多个程序（多个进程），一个进程中还可以有多个线程</span><br><span class="line">  		多个进程在OS中分CPU时间片宏观上并行执行</span><br><span class="line">  		多个线程在进程中也是并行的，也可以并行的执行任务</span><br><span class="line">java程序：</span><br><span class="line">	在java中可以使用多线程的方法将多个需要并行的任务，并发的执行起来</span><br></pre></td></tr></table></figure>

<p>线程：是OS粒度最细的资源单位</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">是OS粒度最细的资源单位，用来执行一个进程中的子任务</span><br><span class="line">创建线程的目的是在一个程序中将多个子任务并行起来。</span><br></pre></td></tr></table></figure>

<h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>概念：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 程序是静态的概念，而进程是程序的实体，在CUP执行时，才被赋予生命，只有当程序真实执行时，被称为进程。</span><br><span class="line">2. CPU会将一段时间分为若干时间片，用于分配给进程，由操作系统负责选择将时间片分配给哪个进程，没有获得到时间片的进程将被暂停（阻塞，挂起）</span><br><span class="line">3. 在单核CPU中，任何时间点上，只能有一个进程在运行，由于切换速度很快，人类无法察觉，所以宏观并行，微观串行。</span><br></pre></td></tr></table></figure>

<p>例：CPU为应用程序分配时间片，操作系统分配时间片</p>
<p><img src="/javaNote.assets/41.png" alt="image-20230423163617913"></p>
<h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>概念：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 线程是轻量级进程，一个进程可以包含多个线程，多个线程完成不同的工作，交替并发执行，称为多线程。</span><br><span class="line">2. 线程是CPU调度时的基本单位</span><br></pre></td></tr></table></figure>

<p>线程的重要组成部分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. OS：操作系统（Operating System）分配时间片</span><br><span class="line">2. 要处理的数据：堆空间共享（对象），栈空间独立（局部变量）</span><br><span class="line">3. 线程要完成的任务：代码</span><br></pre></td></tr></table></figure>

<p>​	就目前而言，我们的虚拟机中只存在一个线程，main线程</p>
<h4 id="创建线程-启动线程"><a href="#创建线程-启动线程" class="headerlink" title="创建线程&amp;启动线程"></a>创建线程&amp;启动线程</h4><p>1.继承Thread类，覆盖run方法，将需要线程执行的任务写在run方法中</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承Thread类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="comment">//覆盖run方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//需要线程完成的任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建线程对象并启动线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">th</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();<span class="comment">//创建线程对象</span></span><br><span class="line">th.start();<span class="comment">//启动线程</span></span><br></pre></td></tr></table></figure>

<p>2.实现Runnable接口，实现run方法，将需要线程执行的任务写在run方法中</p>
<p>JDK提供的Runnable接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现Runnable接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="comment">//实现run方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//需要线程完成的任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建线程对象并启动线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、创建Runnable对象</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line"><span class="comment">//2、创建Thread对象，将task非配给线程</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>( task );</span><br><span class="line"><span class="comment">//3、启动线程</span></span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure>

<pre><code> Runnable接口通常表示任务，所以创建了Runanble任务对象后，需要将该对象分配给线程去执行，类似于向线程派发任务。
</code></pre>
<h4 id="多线程程序的执行效果"><a href="#多线程程序的执行效果" class="headerlink" title="多线程程序的执行效果"></a>多线程程序的执行效果</h4><p>单线程：程序只有一个执行流程，自顶向下一次运行</p>
<p>多线程：程序存在多个并行流程，互不等待，互不干扰</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread1</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main程序开始&quot;</span>);</span><br><span class="line">        <span class="comment">//创建t1线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="comment">//启动t1线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//main线程循环3000次打印MainThread+i</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MainThread &quot;</span> + i);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">         System.out.println(<span class="string">&quot;main程序结束&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;t1程序开始&quot;</span>);</span><br><span class="line">        <span class="comment">//循环3000次打印MyThread+i</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyThread &quot;</span> + i);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">         System.out.println(<span class="string">&quot;t1程序结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/javaNote.assets/42.png" alt="image-20230423164434755"></p>
<p><img src="/javaNote.assets/43.png" alt="image-20230423164527260"></p>
<h4 id="线程的执行状态"><a href="#线程的执行状态" class="headerlink" title="线程的执行状态"></a>线程的执行状态</h4><p>线程在执行时会经历的多种状态，便于我们理解线程，控制线程</p>
<p><img src="/javaNote.assets/44.png" alt="image-20230423165000545"></p>
<p>线程常用方法</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>void  start()</td>
<td>启动线程</td>
</tr>
<tr>
<td>static  void  sleep( long  millis )</td>
<td>当前线程休眠millis毫秒</td>
</tr>
<tr>
<td>void join()</td>
<td>在当前线程中调用其他线程的join()方法，让其他线程加入此线程</td>
</tr>
<tr>
<td>static Thread currentThread()</td>
<td>返回执行此方法的当前线程</td>
</tr>
<tr>
<td>long getId()</td>
<td>返回当前线程id</td>
</tr>
<tr>
<td>String getName()</td>
<td>返回线程名称</td>
</tr>
<tr>
<td>void setName(String name)</td>
<td>设置线程名称</td>
</tr>
</tbody></table>
<h2 id="CoreJavaDay25"><a href="#CoreJavaDay25" class="headerlink" title="CoreJavaDay25"></a>CoreJavaDay25</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">单线程的程序可以满足大部分的需求场景，多线程技术的好处：</span><br><span class="line">	1.使得程序中多个功能同时运行，满足不同用户同时访问的需求</span><br><span class="line">	2.充分的利用硬件资源</span><br><span class="line">多线程带来的问题：</span><br><span class="line">	大多数情况下，如果多个线程之间功能独立，互不干扰，那么可以说就不存在问题</span><br><span class="line">	问题的前提：多个线程不独立，在工作工程中有一些交互，最典型的就是访问相同的数据（集合），就可能会出现被访问的数据状态不一致的现象。</span><br></pre></td></tr></table></figure>

<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>概念：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 同步（synchronous）：单线程的默认执行方式，例如主函数调用其他方法时，必须等到其他方法执行完毕，主函数才能继续执行，是一种串行执行方式。</span><br><span class="line">2. 异步（asynchronous）：多线程环境下的默认执行方式，例如主函数启动新的线程，线程会执行run方法，而在run方法执行时主函数并不需要等待，可以继续执行;此时主函数与run方法就形成了异步执行，是一种并行执行方式。</span><br></pre></td></tr></table></figure>

<h4 id="线程同步实现思路与相关概念"><a href="#线程同步实现思路与相关概念" class="headerlink" title="线程同步实现思路与相关概念"></a>线程同步实现思路与相关概念</h4><p>线程同步的实现思路:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">锁住临界资源对象，只提供一把钥匙，第一个访问临界资源的线程可以获取钥匙，使用临街资源，其他线程进入等待状态。</span><br><span class="line">得到钥匙的线程可以执行原子操作，待原子操作结束后将钥匙还给临界资源对象</span><br></pre></td></tr></table></figure>

<p>相关概念:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">互斥锁标记：Java中任何对象都有一个互斥锁标记，用来分配给线程，争夺到锁标记的线程可以进行后续操作，其他线程进入锁池等待；当原子操作结束后，该线程会释放锁标记，其他线程再进行争夺，如此往复。</span><br><span class="line">锁池：Java中任何对象都具备的一个空间，用来存放等待争夺该对象锁标记的线程对象。</span><br></pre></td></tr></table></figure>

<h4 id="实现方式一：同步代码块"><a href="#实现方式一：同步代码块" class="headerlink" title="实现方式一：同步代码块"></a>实现方式一：同步代码块</h4><p>语法：同步代码块</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronized( 临界资源 )&#123;</span><br><span class="line">    //原子操作</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>特点：只有拥有临界资源对象锁标记的线程，才能进入相同的同步代码块，线程退出同步代码块时，会释放锁标记</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSynchronized2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//被多线程共享的对象（临界资源）</span></span><br><span class="line">        <span class="type">MyObject</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyObject</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用匿名内部类创建t1线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">              <span class="comment">//同步代码块，只有得到obj对象锁标记的线程，才能执行</span></span><br><span class="line">             <span class="keyword">synchronized</span> ( obj )  &#123;</span><br><span class="line">                   <span class="comment">//调用obj中的method方法（原子操作）</span></span><br><span class="line">                   obj.method( <span class="string">&quot;T1--------&quot;</span>);</span><br><span class="line">             &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用匿名内部类创建t2线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="comment">//同步代码块，只有得到obj对象锁标记的线程，才能执行</span></span><br><span class="line">                <span class="keyword">synchronized</span>( obj )&#123;</span><br><span class="line">                    <span class="comment">//调用obj中的method方法（原子操作）</span></span><br><span class="line">                    obj.method( <span class="string">&quot;T2--------&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">         <span class="comment">//使用匿名内部类创建t3线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="comment">//同步代码块，只有得到obj对象锁标记的线程，才能执行</span></span><br><span class="line">                <span class="keyword">synchronized</span>( obj )&#123;</span><br><span class="line">                    <span class="comment">//调用obj中的method方法（原子操作）</span></span><br><span class="line">                    obj.method( <span class="string">&quot;T3--------&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        t1.start();<span class="comment">//启动t1线程</span></span><br><span class="line">        t2.start();<span class="comment">//启动t2线程</span></span><br><span class="line">        t3.start();<span class="comment">//启动t3线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MyObject类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        <span class="comment">//打印1000次str</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">1000</span>; i++)</span><br><span class="line">            System.out.println( str + i );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：得到锁标记的线程可以执行，其他线程必须等待该线程出同步代码块（释放锁标记），才能继续争夺锁标记。</p>
<h4 id="实现方式二：同步方法"><a href="#实现方式二：同步方法" class="headerlink" title="实现方式二：同步方法"></a>实现方式二：同步方法</h4><p>语法：使用synchronized修饰方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">访问权限修饰符 ... <span class="keyword">synchronized</span> 返回值类型 方法名 (参数表)抛出的异常&#123;</span><br><span class="line">    <span class="comment">//默认对this加锁 当this成为临界资源时，只有一个线程能进入到该方法中执原子操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点</strong>：使用当前对象this作为临界资源，当前对象被多线程共享时，需要竞争锁标记，当该方法执行完毕后，线程会释放锁标记</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSynchronized2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//被多线程共享的对象（临界资源）</span></span><br><span class="line">        <span class="type">MyObject</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyObject</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用匿名内部类创建t1线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="comment">//调用obj中的method方法</span></span><br><span class="line">                obj.method( <span class="string">&quot;T1--------&quot;</span>);</span><br><span class="line">             &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用匿名内部类创建t2线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;              </span><br><span class="line">               <span class="comment">//调用obj中的method方法</span></span><br><span class="line">               obj.method( <span class="string">&quot;T2--------&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用匿名内部类创建t3线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;              </span><br><span class="line">               <span class="comment">//调用obj中的method方法</span></span><br><span class="line">               obj.method( <span class="string">&quot;T3--------&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        t1.start();<span class="comment">//启动t1线程</span></span><br><span class="line">        t2.start();<span class="comment">//启动t2线程</span></span><br><span class="line">        t3.start();<span class="comment">//启动t3线程</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MyObject类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span> &#123;</span><br><span class="line">    <span class="comment">//当此类的某个对象被多线程共享时，调用此方法会竞争此对象的锁标记</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(String str)</span>&#123;<span class="comment">//（原子操作）</span></span><br><span class="line">        <span class="comment">//打印10次str</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">1000</span>; i++)</span><br><span class="line">            System.out.println( str + i );</span><br><span class="line">    &#125;<span class="comment">//该方法结束后释放锁标记</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>等同于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span> &#123;</span><br><span class="line">    <span class="comment">//当此类的某个对象被多线程共享时，调用此方法会竞争此对象的锁标记</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(String str)</span>&#123;<span class="comment">//（原子操作）</span></span><br><span class="line">        <span class="comment">//同步代码块</span></span><br><span class="line">        <span class="keyword">synchronized</span>( <span class="built_in">this</span> )&#123;</span><br><span class="line">            <span class="comment">//打印10次str</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">1000</span>; i++)</span><br><span class="line">                System.out.println( str + i );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="锁池中的线程"><a href="#锁池中的线程" class="headerlink" title="锁池中的线程"></a>锁池中的线程</h4><p>​	处于对象锁池中的线程需要等待锁标记的释放，一旦释放一起参与竞争，具有随机性</p>
<p>​	处于锁池中的线程将进入阻塞状态（Blocked），等待锁标记的释放</p>
<p>线程状态图：</p>
<p><img src="/javaNote.assets/47.png" alt="image-20230425202909679"></p>
<h4 id="线程安全与性能"><a href="#线程安全与性能" class="headerlink" title="线程安全与性能"></a>线程安全与性能</h4><p>概念：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">线程安全是指在多线程并发环境下可以保证其原子性不被破坏，实现方式就是将线程由异步转换为同步</span><br><span class="line">同步线程后，线程将不能并发同时访问，影响并发环境下的执行效率，所以线程安全与性能是对立的</span><br><span class="line">在目前的应用环境系统中，可以保证线程安全的框架有很多而且性能也会较高，而JDK提供的synchronized机制比较落后，因此JDK提供的一些线程安全的类并没有太高的应用价值</span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder 线程不安全，在多线程环境应用中无法保证原子性，效率高</span><br><span class="line">StringBuffer  线程安全，可以保证多线程环境应用中不会出现破坏原子性的问题，效率低</span><br><span class="line">Vector    线程安全，效率低</span><br><span class="line">ArrayList 线程不安全，效率高</span><br><span class="line">Hashtable 线程安全，效率低</span><br><span class="line">HashMap   线程不安全 效率高</span><br></pre></td></tr></table></figure>

<p><img src="/javaNote.assets/45.png" alt="image-20230424150757588"></p>
<h2 id="CoreJavaDay26"><a href="#CoreJavaDay26" class="headerlink" title="CoreJavaDay26"></a>CoreJavaDay26</h2><p>反射</p>
<p><img src="/javaNote.assets/46.png" alt="image-20230425103540062"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">可以更加灵活的创建对象，访问属性和调用方法的途径</span><br><span class="line"></span><br><span class="line">面向对象：</span><br><span class="line">	1.定义类（对象的模版）</span><br><span class="line">	2.创建对象</span><br><span class="line">	3.访问属性</span><br><span class="line">	4.调用方法</span><br><span class="line">java中面向对象编程的标准语法</span><br><span class="line">	1.通过class关键字  2. new 构造方法  3. 通过 .属性  4. 通过 .方法</span><br><span class="line">反射的语法</span><br><span class="line">反射和标准创建对象的语法共性的前置条件：</span><br><span class="line">	1.</span><br><span class="line">	反射和标准创建对象语法不同点，就在于加载后的类型信息使用不是自动的，需要程序员手动使用类型信息完成后续对象的创建，属性的方法和方法的调用的。</span><br><span class="line">	反射就是学习如何手动使用一个类的类型信息，完成创建对象，访问属性和调用方法的操作!</span><br><span class="line">		1.如何获取类加载后的一个类的信息</span><br><span class="line">			一个类被类加载后在JVM中，以一个特殊的对象为形式存储起来，这个特殊的对象记录了被加载的类的所有信息，其可以用来创建对象（注意：这个特殊的对象也有类型，是Class类型）</span><br><span class="line">		2.如何通过反射创建对象</span><br><span class="line">		3.如何通过反射访问属性</span><br><span class="line">		4.如何通过反射调用方法</span><br><span class="line">		</span><br></pre></td></tr></table></figure>

<h3 id="类加载-1"><a href="#类加载-1" class="headerlink" title="类加载"></a>类加载</h3><p>类加载时机与过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1）当虚拟机第一次使用某个类时（new对象、调用静态成员、使用子类）某个类时，需要通过CLASSPATH查找该类的.class文件。</span><br><span class="line">2）将.class文件中保存的类的描述信息（属性、方法..等等）加载到内存中进行保存。</span><br><span class="line">3）加载时会初始化该类的必要信息，初始化静态属性、静态方法，调用静态初始化代码块等。</span><br><span class="line">4）类加载只会执行一次</span><br></pre></td></tr></table></figure>

<p>类加载时机：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、第一次创建一个类的对象</span><br><span class="line">2、第一次访问一个类的静态成员</span><br><span class="line">3、创建子类对象或加载子类时</span><br></pre></td></tr></table></figure>

<p>创建对象的过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、先加载父类</span><br><span class="line">2、加载子类</span><br><span class="line">3、初始化父类属性</span><br><span class="line">4、调用父类构造方法</span><br><span class="line">5、初始化子类属性</span><br><span class="line">6、调用子类构造方法</span><br></pre></td></tr></table></figure>

<p>注意：类加载只执行一次</p>
<p>虚拟机加载完一个类时会在元数据区形成一个类的对象Class 该对象就是类在内存中的体现，一个类只有一个Class对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">由于对象存在封装的特点，隐藏内部实现的细节，不暴露私有成员，外部无法访问</span><br><span class="line">反射编程（上帝模式）</span><br><span class="line">计算机---&gt;模板-------&gt;加载模板----&gt;获取类对象----&gt;获取属性/方法等----&gt;选择对象执行</span><br><span class="line">一个是创建对象，看你会干什么，再让你干</span><br><span class="line">另外一个是你不用告诉我，我知道你会干什么，直接让你去干</span><br></pre></td></tr></table></figure>

<h3 id="Class-对象"><a href="#Class-对象" class="headerlink" title="Class 对象"></a>Class 对象</h3><p>​	Class对象是JVM类加载的产物，该对象封装了一个.class文件中的所有信息 记录学生信息叫学生对象，记录一个类的信息叫类对象</p>
<h4 id="获取Class对象的方式"><a href="#获取Class对象的方式" class="headerlink" title="获取Class对象的方式"></a>获取Class对象的方式</h4><p>1.通过对象的getClass()方法获取</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> list.getClass();</span><br></pre></td></tr></table></figure>

<p>2.通过类名.class方式获取</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;ArrayList&gt; c = ArrayList.class;</span><br></pre></td></tr></table></figure>

<p>3.通过Class.forName(“全类名”);全类名：带包的类名</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.util.ArrayList&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="常用方法-3"><a href="#常用方法-3" class="headerlink" title="常用方法"></a>常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Sub&gt; sub = Sub.class;<span class="comment">//获取Sub类的Class对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sn</span> <span class="operator">=</span> sub.getSimpleName();<span class="comment">//获取类名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sn2</span> <span class="operator">=</span> sub.getName();<span class="comment">//获取全类名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">packName</span> <span class="operator">=</span> sub.getPackage().getName();<span class="comment">//获取包名</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">cl</span> <span class="operator">=</span> sub.getSuperclass();<span class="comment">//获取父类所对应Class对象</span></span><br><span class="line">System.out.println(sub.getInterfaces()[<span class="number">0</span>]);<span class="comment">//获取已实现的接口</span></span><br><span class="line"></span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span>  <span class="operator">=</span> sub.newInstance();<span class="comment">//通过Class对象创建Sub对象</span></span><br><span class="line"><span class="type">Sub</span> <span class="variable">s</span> <span class="operator">=</span> (Sub)o;</span><br><span class="line"></span><br><span class="line"><span class="type">Field</span> <span class="variable">fe</span> <span class="operator">=</span> sub.getField(<span class="string">&quot;e&quot;</span>);<span class="comment">//获得Sub类中访问公开的属性</span></span><br><span class="line">fe.set(s, <span class="number">100</span>);<span class="comment">//为e属性赋值</span></span><br><span class="line"></span><br><span class="line"><span class="type">Field</span> <span class="variable">fd</span> <span class="operator">=</span> sub.getDeclaredField(<span class="string">&quot;d&quot;</span>);<span class="comment">//获得Sub类中所有属性</span></span><br><span class="line">fd.setAccessible(<span class="literal">true</span>);<span class="comment">//设置访问权限为true才能操作私有成员</span></span><br><span class="line">fd.set(s, <span class="number">200</span>);<span class="comment">//为私有属</span></span><br><span class="line"></span><br><span class="line">Field[] fs = sub.getFields();<span class="comment">//获得一个类中可以访问到的所有公开属性</span></span><br><span class="line">Field[] fsd = sub.getDeclaredFields();<span class="comment">//获得本类中的所有属性（包括非公开属性）</span></span><br><span class="line"></span><br><span class="line">------------------------------获取方法--------------------------------------------------</span><br><span class="line">Class&lt;Sub&gt; cl = Sub.class;</span><br><span class="line"><span class="type">Method</span> <span class="variable">m1</span> <span class="operator">=</span> cl.getMethod(<span class="string">&quot;m1&quot;</span>, <span class="literal">null</span>);<span class="comment">//获取无参的m1方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">m2</span> <span class="operator">=</span> cl.getMethod(<span class="string">&quot;m1&quot;</span>, <span class="type">int</span>.class);<span class="comment">//获取有参的m1方法 参数类型为 int</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">m3</span> <span class="operator">=</span> cl.getMethod(<span class="string">&quot;m1&quot;</span>,String.class,<span class="type">double</span>.class,<span class="type">boolean</span>.class );<span class="comment">//获取有参的m1方法 参数类型为 String double boolean</span></span><br><span class="line"><span class="comment">//创建对象调用方法</span></span><br><span class="line"><span class="type">Sub</span> <span class="variable">sub</span> <span class="operator">=</span> cl.newInstance();</span><br><span class="line">m1.invoke( sub , <span class="literal">null</span>);<span class="comment">//使用sub对象调用m1方法 invoke(执行该方法的对象,实参) 无参传入null</span></span><br><span class="line">m2.invoke( sub, <span class="number">100</span>);<span class="comment">//使用sub对象调用m1(int ) 方法 传入实参</span></span><br><span class="line">m3.invoke( sub, <span class="string">&quot;ABC&quot;</span>,<span class="number">20.5</span>,<span class="literal">true</span>);</span><br><span class="line">    </span><br><span class="line">Method[] ms = cl.getMethods();<span class="comment">//获取该类可以访问到的所有公开方法</span></span><br><span class="line"></span><br><span class="line"><span class="type">Method</span> <span class="variable">mm</span>  <span class="operator">=</span> cl.getDeclaredMethod(<span class="string">&quot;m2&quot;</span>, <span class="literal">null</span>);<span class="comment">//获取本类中的某个方法</span></span><br><span class="line">mm.setAccessible(<span class="literal">true</span>);<span class="comment">//设置访问权限</span></span><br><span class="line">mm.invoke(sub, <span class="literal">null</span>);</span><br><span class="line">    </span><br><span class="line">Method[] ms2 = cl.getDeclaredMethods();<span class="comment">//获取本类中的所有方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Super</span>&#123;</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> b;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> c;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Super</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> d;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> e;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;m1(  )&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;m1 ( int )&quot;</span>+i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">(String a,<span class="type">double</span> b,<span class="type">boolean</span> c)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;m1(String double boolean)&quot;</span>+a+b+c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;m2(  )&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/11/06/javaNote/" data-id="clommlfmd0002nsauglnl3tdg" data-title="javaNote" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-面试题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/11/05/%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2023-11-05T13:05:36.647Z" itemprop="datePublished">2023-11-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="day01"><a href="#day01" class="headerlink" title="day01"></a>day01</h2><ol>
<li><p>Integer a &#x3D; 128;Integer b &#x3D; 128; a &#x3D;&#x3D; b 的结果是什么?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">结果：false</span><br><span class="line"># 常量池：</span><br><span class="line">1. jvm认为数字 -128 ~ 127之间的数字在java程序使用频率是最高。</span><br><span class="line">2. 每次使用数字， 都需在内存中开辟空间(占用空间)， 初始化数据(消耗时间)</span><br><span class="line">3. jvm启动时候，会在内存中先初始化一定数量的数字：-128~127之间。</span><br><span class="line">4. 后续java程序运行期间， 凡是需要使用-128~127之间数字的，都直接从常量池获取，减少</span><br><span class="line">数字重复占用内存， 减少数字创建等待时间。提升效率提升。</span><br><span class="line">==  ：比较基本类型比较的是变量保存的值，比较引用是比较是地址值是否相同，是否指向同一个对象</span><br><span class="line">equals ：用于比较对象的内容是否相等</span><br></pre></td></tr></table></figure>
</li>
<li><p>String，StringBuilder，StringBuffer 的区别?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># String不可变性</span><br><span class="line">1. 串池中的字符串, 是jvm级别, 多线程共享, 一旦某个线程修改字符串内容, 导致其他线程对</span><br><span class="line">于该字符串引用内容, 发生意外修改, 不安全.</span><br><span class="line">2. String对象,在做字符串拼接,修改字符串, 必须新创建一个新的字符串.---(字符串不可变</span><br><span class="line">性)</span><br><span class="line">总结: 字符串对象一旦创建, 内容是不会改变.</span><br><span class="line"># 题目答案：</span><br><span class="line">1. String不可变性导致拼接会产生大量中间对象, 浪费时间, 浪费空间 效率降低.</span><br><span class="line">2. StringBuilder可变字符串, 在拼接, 避免中间对象的产生,节省空间, 节省时间. 效率</span><br><span class="line">高.</span><br><span class="line"># 补充</span><br><span class="line">String 字符串常量 不可变 使用字符串拼接时是不同的2个空间</span><br><span class="line">StringBuffer 字符串变量 可变 字符串拼接直接在后面追加 线程安全</span><br><span class="line">StringBuilder 字符串变量 可变 字符串拼接直接在后面追加 非线程安全</span><br></pre></td></tr></table></figure>
</li>
<li><p>集合 List Set Map 特点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># List集合:</span><br><span class="line">有序号(从0开始)</span><br><span class="line">对象可以重复</span><br><span class="line">有顺序(维持了存入的顺序)</span><br><span class="line"># Set集合:</span><br><span class="line">无序号</span><br><span class="line">对象不可以重复</span><br><span class="line">注意：</span><br><span class="line">① 默认set认为对象的地址是一样的，才是重复对象。对象的属性值一样，不属于重复对象。</span><br><span class="line">② set对存入对象判定是否是同一对象的规则：</span><br><span class="line">先判断对象hashcode是否一样。(类似对象地址)。</span><br><span class="line">如果hashcode相同， 会继续调用对象equals方法，判定对象是否相同。</span><br><span class="line">如果希望set认为对象的属性值一样， 就是同一对象只保留1份。</span><br><span class="line">重写对象hashcode方法和equals</span><br><span class="line">重写规则： 尽量让相同对象的hashcode相同， 对象属性不一样的对象的equals返回false</span><br><span class="line">无顺序(对象存入set后,顺序混乱)</span><br><span class="line"></span><br><span class="line"># Map集合</span><br><span class="line">每个对象Entry，包含key-value</span><br><span class="line">key不可以重复</span><br><span class="line">value可以重复</span><br><span class="line">无顺序</span><br></pre></td></tr></table></figure>
</li>
<li><p>包装类和基本数据类型的区别</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 说明</span><br><span class="line">基本数据类型: byte short int long float double boolean char (8种)</span><br><span class="line">包装数据类型: Integer Long Byte Short Double Boolean Character</span><br><span class="line">区别:</span><br><span class="line">1. 包装类型属于对象类型</span><br><span class="line">2. 包装类型的默认值是null;</span><br><span class="line">例子:</span><br><span class="line">Double score = null;</span><br><span class="line">Double score = 0.0;</span><br><span class="line">在网上商城项目中，价格不要使用Double类型。</span><br><span class="line">BigDecimal b = new BigDecimal(&quot;130.08&quot;);</span><br><span class="line">BigDecimal result = b.multiply(new BigDecimal(&quot;100&quot;));</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure>
</li>
<li><p>什么是数据库的事务，什么是脏读，不可重复读，幻读</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">事务有四个特性 ACID：</span><br><span class="line">1.原⼦性: 原⼦性指的就是事务⾥⾯执⾏的增删改操作是⼀个原⼦操作，要么全部成功，要么全部失败。</span><br><span class="line">2.隔离性: 隔离性指的是两个事务之间同时操作数据库的时候有相应的隔离级别，可以限制事务与事务之间数据的影响。</span><br><span class="line">3.⼀致性: ⼀致性指的是事务操作前和事务操作后数据必须是正确的。</span><br><span class="line">4.持久性: 持久性指的是事务做完操作之后，数据就永久保存了，不会为⼀些原因导致数据丢失。事务的这些特性会保证我们项⽬中数据的安全，不会因为⼀些异常导致数据出问题。</span><br></pre></td></tr></table></figure>

<p>事务的隔离级别有四个：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.未提交读: 未提交读会引起脏读问题。脏读就是指⼀个事务插⼊数据后，还没有提交事务的情况下，其他的事务就可以读到该数据，这就是脏读问题。</span><br><span class="line">2.已提交读: 已提交读解决了脏读的问题，但是没有解决不可重复读的问题。不可重复读指的是⼀个事务读两次相同的数据，发现两次读到的数据是不⼀致的。因为中间有其他的事务修改这个数据。为了避免不可重复读的问题，我们可以把事务的隔离级别提⾼到可重复读的级别。</span><br><span class="line">3.可重复读: 可重复读解决了不可重复读的问题，但是有幻读的问题，幻读是指⼀个事务读到数据库⾥⾯没有⼀条数据，在他插⼊该数据的时候突然发现数据库⾥⾯已经有这个数据了。</span><br><span class="line">4.序列化 :数据库提供了序列化读的隔离级别，可以解决幻读问题。隔离级别越⾼，那么数据库的性能就会越低。</span><br></pre></td></tr></table></figure>


</li>
<li><p>过滤器和拦截器的区别</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、使用范围与规范不同：Filter是Servlet规范中定义的，依赖于Servlet容器。拦截器是SpringMvc的组件，只有springMVC框架可以使用。</span><br><span class="line">2、使用资源不同：拦截器可以使用Spring里的任何资源、对象，例如Service对象、数据源、事务管理等，通过IOC注入到拦截器即可；而Filter没有被spring管理，他不能注入spring的bean对象。</span><br><span class="line">3、作用范围不同：Filter在只在Servlet前后起作用。而拦截器对控制器请求起作用。过滤器可以拦截任意资源包括，servlet，静态资源html,css，js。拦截器只能拦截springMVC的控制器方法。</span><br><span class="line">4、实现机制不同：拦截器是基于java的反射机制的，而过滤器是基于函数回调。</span><br></pre></td></tr></table></figure>
</li>
<li><p>mybatis 中取值⽅式有⼏种？各⾃的区别是什么</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#&#123;&#125;和$&#123;&#125;的区别  占位符和字符串拼接</span><br><span class="line">1. #&#123;&#125;相当于sql语句的占位符，他的执行效率和安全性都比字符串拼接要好,可以防止SQL注入攻击。</span><br><span class="line">2. $&#123;&#125;相当于字符串拼接，更加灵活,但是容易被SQL注入攻击，可以应用在sql中的关键字。 select * from 表 order by ? 这个场景可以应用在$&#123;&#125;上。</span><br></pre></td></tr></table></figure>
</li>
<li><p>mybatis 的⼀级缓存和⼆级缓存</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. mybatis中默认带了一级缓存，自动就使用了一级缓存。一级缓存是跟sqlSession相关的缓</span><br><span class="line">存。当我们使用同样的sqlSession去执行相同的查询sql那么一级缓存就会生效。一级缓存应用</span><br><span class="line">场景不多，几乎用不到。</span><br><span class="line">2. mybatis的二级缓存不是默认打开的，需要我们手动设置开启二级缓存。二级缓存是跟SqlSe</span><br><span class="line">ssionFactory相关的缓存。只要是同一个sqlSessionFactory创建的sqlSession对象执行的</span><br><span class="line">sql语句都共用这个二级缓存。</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="day02"><a href="#day02" class="headerlink" title="day02"></a>day02</h2><ol>
<li><p>spring 常⻅的注解有哪些?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">组件注解：</span><br><span class="line">	@Controller @Service @Repository @Component @Bean @Configration @Scope</span><br><span class="line">装配注解：</span><br><span class="line">	@Autowire @Resource @Value</span><br><span class="line">aop注解：</span><br><span class="line">	@Aspect @Before @After @Pointcut @Transcational @Around</span><br><span class="line">Mvc注解：</span><br><span class="line">	@RestController @RequetMapping @PathVariable @RequestBody @RequestParam</span><br></pre></td></tr></table></figure>
</li>
<li><p>SpringMVC 处理请求的流程</p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230721214221992.png" alt="image-20230721214221992"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 客户端（浏览器）发送请求，直接请求到 DispatcherServlet（核心控制器）。</span><br><span class="line">2. DispatcherServlet 根据请求信息调用 HandlerMapping（映射器），解析请求对应的 Handler（控制器）。</span><br><span class="line">3. 解析到对应的 Handler（也就是我们平常说的 Controller 控制器）后，开始由 HandlerAdapter 适配器处理。</span><br><span class="line">4. HandlerAdapter 会根据 Handler来调用真正的处理器开处理请求，并处理相应的业务逻辑。</span><br><span class="line">5. 处理器处理完业务后，会返回一个 ModelAndView（模型和视图） 对象，Model 是返回的数据对象，View 是个逻辑上的 View。</span><br><span class="line">6. ViewResolver（视图解析器） 会根据逻辑 View 查找实际的 View。</span><br><span class="line">7. DispaterServlet 把返回的 Model 传给 View（视图渲染）。</span><br><span class="line">8. 把 View 返回给请求者（浏览器）</span><br></pre></td></tr></table></figure>
</li>
<li><p>springboot 的 starter 机制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">其他问法：1.springboot为什么可以简化配置。2.springboot的重要注解</span><br><span class="line"></span><br><span class="line">在springboot的入口类上面有一个注解@SpringbootApplication，被分解成了三个非常重要的注解。</span><br><span class="line">	@SpringBootConfigration（配置类）</span><br><span class="line">	@EnabledAutoConfigration（跟starter机制相关）</span><br><span class="line">	@ComponentScanner（扫描当前包以及子包中的所有注解）</span><br><span class="line">starter机制就是springboot在启动的时候会自动装配第三方依赖中的bean对象。</span><br><span class="line">starter机制的注解会自动扫描第三方依赖中META-INF,spring.factories配置文件。这个配置文件中有个配置项指向了第三方依赖的配置类@Configration，在这个配置类中，第三方依赖会把要管理的对象都配置成@Bean注解。</span><br></pre></td></tr></table></figure>
</li>
<li><p>spring 中 bean 对象的⽣命周期</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">对象的生命周期被分成了1.创建阶段 2.初始化 3.使用 4.销毁</span><br><span class="line">1. 单例对象在spring容器创建的时候就会被创建出来，而多例的对象会在ac.getBean()的时候创建出对象。</span><br><span class="line">2. spring会对对象的属性进行依赖的注入。</span><br><span class="line">3. 执行BeanPostProcessor的前置处理。</span><br><span class="line">4. 执行InitializingBean接口的初始化方法。</span><br><span class="line">5. 执行bean标签中配置的init-method的初始化方法。@PostConstruct这个注解key替代init-method配置</span><br><span class="line">6. 执行BeanPostProcessor的后置处理的方法。</span><br><span class="line">7. 到此整个bean对象创建完毕，我们就使用这个bean对象。</span><br><span class="line">8. 在spring容器要销毁对象的时候，bean会执行销毁操作，先执行DisposableBean接口的销毁方法。</span><br><span class="line">9. 执行配置在bean标签上面的destory-method的方法。 对应的注解是@PreDestroy</span><br></pre></td></tr></table></figure>
</li>
<li><p>Spring 中有哪⼏种⽅式把 bean 对象交给 IOC 容器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.Bean注解加上，Configuration</span><br><span class="line">2.使用Component注解。</span><br><span class="line">3.使用Import注解，可以导入一个普通的类，也可以导入一个ImportSelector</span><br><span class="line">4.可以实现FactoryBean接口。</span><br><span class="line">5.可以实现BeanDefinitionRegistryPostProcessor接口，手动向容器中注册BeanDefinition</span><br></pre></td></tr></table></figure>

<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230721214054880.png" alt="image-20230721214054880"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.从SpringApplication.run()开始</span><br><span class="line">2.获取，启动运行过程监听器。方便在各个阶段添加额外功能。</span><br><span class="line">3.环境变量的构建。读取配置文件中的内容转换成对象BeanDefinition</span><br><span class="line">4.创建ioc容器</span><br><span class="line">5.ioc容器的前置处理。从spring.factory里面读取信息。</span><br><span class="line">6.刷新容器，创建bean对象。</span><br><span class="line">7.ioc容器的后置处理，默认是一个空方法，如有需要可以重写该方法。</span><br><span class="line">8.发出结束执行事件。</span><br></pre></td></tr></table></figure>
</li>
<li><p>Spring 事务失效的⼏个场景</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. 抛出检查异常导致事务不能回滚</span><br><span class="line">	a. Spring 默认只能回滚运⾏时异常。</span><br><span class="line">	b. 解决办法就是配置 rollbackfor 属性</span><br><span class="line">2. 业务⽅法内⾃⼰处理了异常</span><br><span class="line">	a. 事务通知类中只有捕捉到异常后才有可能事务回滚，在业务类中⾃⼰把异常处理了就相当于没有异常发⽣。</span><br><span class="line">	b. 解决办法是捕捉到异常处理后再⼿动抛出⼀下。</span><br><span class="line">3. ⾮ public ⽅法导致事务失效</span><br><span class="line">	a. Spring 为⽅法添加代理，添加事务通知的前提是业务⽅式必须是 public</span><br><span class="line">	b. 解决办法就是把⽅法改为 public</span><br><span class="line">4. 调⽤本类中的其他⽅法会导致事务失效。</span><br><span class="line">	a. 本类中的其他⽅法调⽤时不会经过代理，因此⽆法增强。</span><br><span class="line">	b. 把⾃⼰通过注⼊的⽅式作为属性，然后调⽤⽅法。</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="MySQL篇"><a href="#MySQL篇" class="headerlink" title="MySQL篇"></a>MySQL篇</h2><p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230919235037091.png" alt="image-20230919235037091"></p>
<p><strong>如何定位慢查询</strong></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230820111557382.png" alt="image-20230820111557382"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230920000243372.png" alt="image-20230920000243372"></p>
<p><strong>一个SQL语句执行很慢，如何分析</strong>	explain，desc命令</p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230820112856976.png" alt="image-20230820112856976"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230820141136949.png" alt="image-20230820141136949"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230820141256019.png" alt="image-20230820141256019"></p>
<p><strong>索引</strong></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230820142508348.png" alt="image-20230820142508348"></p>
<p><strong>聚簇索引和非聚簇索引(二级索引)</strong></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230820143316384.png" alt="image-20230820143316384"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230820143347844.png" alt="image-20230820143347844"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230820143422622.png" alt="image-20230820143422622"></p>
<p><strong>覆盖索引</strong></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230820144440707.png" alt="image-20230820144440707"></p>
<p><strong>创建索引</strong></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230820145151852.png" alt="image-20230820145151852"></p>
<p><strong>索引失效</strong></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230820145910775.png" alt="image-20230820145910775"></p>
<p><strong>SQL优化</strong></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230820151625986.png" alt="image-20230820151625986"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230820152914144.png" alt="image-20230820152914144"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230920170431790.png" alt="image-20230920170431790"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230920170723108.png" alt="image-20230920170723108">	<img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230920170825437.png" alt="image-20230920170825437"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230820160356378.png" alt="image-20230820160356378"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230820163921790.png" alt="image-20230820163921790"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230920172405289.png" alt="image-20230920172405289"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230920172538192.png" alt="image-20230920172538192"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230920172618823.png" alt="image-20230920172618823"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230920172926392.png" alt="image-20230920172926392"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230920174005942.png" alt="image-20230920174005942"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230920173454089.png" alt="image-20230920173454089"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230920173926094.png" alt="image-20230920173926094"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230920173940735.png" alt="image-20230920173940735"></p>
<p><strong>主从同步原理</strong> </p>
<p>​	–分担访问压力</p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230820164150654.png" alt="image-20230820164150654"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230820164212408.png" alt="image-20230820164212408"></p>
<p><strong>分库分表</strong></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230920194503922.png" alt="image-20230920194503922"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230920194518700.png" alt="image-20230920194518700"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230920194918069.png" alt="image-20230920194918069"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230920195107307.png" alt="image-20230920195107307"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230920195158766.png" alt="image-20230920195158766">	</p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230820172526477.png" alt="image-20230820172526477"></p>
<h2 id="框架篇"><a href="#框架篇" class="headerlink" title="框架篇"></a>框架篇</h2><p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230920195748983.png" alt="image-20230920195748983"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230821093412944.png" alt="image-20230821093412944"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230821094546827.png" alt="image-20230821094546827"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20231016211445291.png" alt="image-20231016211445291"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230822091317846.png" alt="image-20230822091317846"></p>
<p><strong>Bean的生命周期</strong></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230921113341805.png" alt="image-20230921113341805"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230822091852570.png" alt="image-20230822091852570"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230822092518718.png" alt="image-20230822092518718"></p>
<p><strong>Spring的循环依赖</strong></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230822093725155.png" alt="image-20230822093725155"></p>
<p>Spring的一级缓存无法解决缓存依赖问题</p>
<p>Spring的二级缓存可以解决普通对象的缓存依赖问题，不能解决代理对象的缓存依赖问题</p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230822093655827.png" alt="image-20230822093655827"></p>
<p>Spring使用三级缓存可以解决普通对象和代理对象的循环依赖问题，无法解决构造方法产生的循环依赖问题(使用懒加载解决)</p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230822093410183.png" alt="image-20230822093410183"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230822094221865.png" alt="image-20230822094221865"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230822094333556.png" alt="image-20230822094333556"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/20200422090416398.png" alt="在这里插入图片描述"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230822211817400.png" alt="image-20230822211817400"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230822212145541.png" alt="image-20230822212145541"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230822212004277.png" alt="image-20230822212004277"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230822212218675.png" alt="image-20230822212218675"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230822212904594.png" alt="image-20230822212904594"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230822212932056.png" alt="image-20230822212932056"></p>
<p><strong>Spring框架常见注解</strong></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230822213128622.png" alt="image-20230822213128622"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230822213246366.png" alt="image-20230822213246366"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230822213315780.png" alt="image-20230822213315780"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230921154448097.png" alt="image-20230921154448097"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230822220103359.png" alt="image-20230822220103359"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230824213743057.png" alt="image-20230824213743057"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230824213901640.png" alt="image-20230824213901640">	</p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230824214712106.png" alt="image-20230824214712106"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230824214733916.png" alt="image-20230824214733916"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230824214659355.png" alt="image-20230824214659355"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230824214639523.png" alt="image-20230824214639523"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230824214841407.png" alt="image-20230824214841407"></p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230924095739194.png" alt="image-20230924095739194"></p>
<p><strong>数组</strong></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230924203616911.png" alt="image-20230924203616911"> </p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230826154726544.png" alt="image-20230826154726544"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230826155138576.png" alt="image-20230826155138576"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230826160636622.png" alt="image-20230826160636622"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230826160725462.png" alt="image-20230826160725462"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230826161338305.png" alt="image-20230826161338305"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230826161308749.png" alt="image-20230826161308749"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230826161815156.png" alt="image-20230826161815156"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230826162258013.png" alt="image-20230826162258013"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230826162222152.png" alt="image-20230826162222152"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230925105859270.png" alt="image-20230925105859270"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230826162836636.png" alt="image-20230826162836636"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230826163230077.png" alt="image-20230826163230077"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230925114343402.png" alt="image-20230925114343402"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230925114616447.png" alt="image-20230925114616447"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230826163555814.png" alt="image-20230826163555814"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230826163712489.png" alt="image-20230826163712489"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230826163758508.png" alt="image-20230826163758508"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230826163810667.png" alt="image-20230826163810667"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230827154759801.png" alt="image-20230827154759801"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230826164140910.png" alt="image-20230826164140910"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230827155334123.png" alt="image-20230827155334123"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230827155834080.png" alt="image-20230827155834080"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230827161306244.png" alt="image-20230827161306244"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230827161244480.png" alt="image-20230827161244480"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230827161929828.png" alt="image-20230827161929828"></p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230925174134760.png" alt="image-20230925174134760"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230827162647748.png" alt="image-20230827162647748"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230827163145402.png" alt="image-20230827163145402"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230827163558236.png" alt="image-20230827163558236"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230827163857554.png" alt="image-20230827163857554"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230827163915677.png" alt="image-20230827163915677"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230827163948640.png" alt="image-20230827163948640"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230925233731042.png" alt="image-20230925233731042"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230827164041540.png" alt="image-20230827164041540"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230827164835108.png" alt="image-20230827164835108"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230827165023542.png" alt="image-20230827165023542"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230828092949204.png" alt="image-20230828092949204"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230828093829284.png" alt="image-20230828093829284"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230828093803126.png" alt="image-20230828093803126"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230926105509621.png" alt="image-20230926105509621"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230926105528402.png" alt="image-20230926105528402"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230926105731800.png" alt="image-20230926105731800"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230926105906015.png" alt="image-20230926105906015"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20231017160617648.png" alt="image-20231017160617648"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20231017160352092.png" alt="image-20231017160352092"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20231017160550786.png" alt="image-20231017160550786"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230829094303752.png" alt="image-20230829094303752"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230829094611411.png" alt="image-20230829094611411"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230829094639444.png" alt="image-20230829094639444"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230926115056679.png" alt="image-20230926115056679"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230926115222025.png" alt="image-20230926115222025"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230926115010821.png" alt="image-20230926115010821"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230829144247785.png" alt="image-20230829144247785"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230829150834975.png" alt="image-20230829150834975"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230829150805928.png" alt="image-20230829150805928"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230926163535292.png" alt="image-20230926163535292"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230829152212357.png" alt="image-20230829152212357">	</p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230829161141575.png" alt="image-20230829161141575"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230926165820423.png" alt="image-20230926165820423"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230829161559250.png" alt="image-20230829161559250"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230926234309087.png" alt="image-20230926234309087"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230926234350180.png" alt="image-20230926234350180"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230829162101824.png" alt="image-20230829162101824"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230829162136216.png" alt="image-20230829162136216"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230829163405718.png" alt="image-20230829163405718"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230829164314272.png" alt="image-20230829164314272"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230829165503312.png" alt="image-20230829165503312"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230927110838561.png" alt="image-20230927110838561"> 		</p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230927110738425.png" alt="image-20230927110738425"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230927110715806.png" alt="image-20230927110715806"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230829174323658.png" alt="image-20230829174323658"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230829203534339.png" alt="image-20230829203534339"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230829205916527.png" alt="image-20230829205916527"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230829210140593.png" alt="image-20230829210140593"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230829210541901.png" alt="image-20230829210541901"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230829210700875.png" alt="image-20230829210700875"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230829212428496.png" alt="image-20230829212428496"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230829212444922.png" alt="image-20230829212444922"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230829212500361.png" alt="image-20230829212500361"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230927162615440.png" alt="image-20230927162615440"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230829212540249.png" alt="image-20230829212540249"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230927162837328.png" alt="image-20230927162837328"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230829213451995.png" alt="image-20230829213451995"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230829214052532.png" alt="image-20230829214052532"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230829214230396.png" alt="image-20230829214230396"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230927175147273.png" alt="image-20230927175147273"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230927180056897.png" alt="image-20230927180056897"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230927180408760.png" alt="image-20230927180408760"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20231019170824462.png" alt="image-20231019170824462"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230927181925863.png" alt="image-20230927181925863"></p>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230831093810380.png" alt="image-20230831093810380"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230831094805034.png" alt="image-20230831094805034"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230831094713647.png" alt="image-20230831094713647"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230831095650409.png" alt="image-20230831095650409"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230831100151262.png" alt="image-20230831100151262"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230831100204236.png" alt="image-20230831100204236"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230831160833830.png" alt="image-20230831160833830"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230831161711364.png" alt="image-20230831161711364"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230831163324950.png" alt="image-20230831163324950"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230831163357656.png" alt="image-20230831163357656"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230831163423318.png" alt="image-20230831163423318"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230831163243162.png" alt="image-20230831163243162"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20231019185816293.png" alt="image-20231019185816293"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230831170135664.png" alt="image-20230831170135664">	</p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230831170553560.png" alt="image-20230831170553560"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230831171116247.png" alt="image-20230831171116247"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230831171151431.png" alt="image-20230831171151431"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230831171018930.png" alt="image-20230831171018930"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230831171630535.png" alt="image-20230831171630535"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230918175935855.png" alt="image-20230918175935855"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230918180206461.png" alt="image-20230918180206461"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230831172211905.png" alt="image-20230831172211905"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230831172354633.png" alt="image-20230831172354633"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230831172404950.png" alt="image-20230831172404950"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230831192452078.png" alt="image-20230831192452078"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230831193209626.png" alt="image-20230831193209626"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230831193600748.png" alt="image-20230831193600748"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230831193847797.png" alt="image-20230831193847797"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230831194049333.png" alt="image-20230831194049333"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20231019223152263.png" alt="image-20231019223152263"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230831195038007.png" alt="image-20230831195038007"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230831200009428.png" alt="image-20230831200009428"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230831200346865.png" alt="image-20230831200346865"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230831200839394.png" alt="image-20230831200839394"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230831201041935.png" alt="image-20230831201041935"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230831201222394.png" alt="image-20230831201222394"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230831201432301.png" alt="image-20230831201432301"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230831203336184.png" alt="image-20230831203336184"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230831203355712.png" alt="image-20230831203355712"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230831203302143.png" alt="image-20230831203302143"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230831203810404.png" alt="image-20230831203810404"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230831204105593.png" alt="image-20230831204105593"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230831204126124.png" alt="image-20230831204126124"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230831204232549.png" alt="image-20230831204232549"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230831204447299.png" alt="image-20230831204447299"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230831204652947.png" alt="image-20230831204652947"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230831204959594.png" alt="image-20230831204959594"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230831205142891.png" alt="image-20230831205142891"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20231020144827297.png" alt="image-20231020144827297"></p>
<h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230831205552562.png" alt="image-20230831205552562"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230901100751982.png" alt="image-20230901100751982"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230901141422664.png" alt="image-20230901141422664">	</p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230901141620509.png" alt="image-20230901141620509"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230901141718104.png" alt="image-20230901141718104"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230901142344979.png" alt="image-20230901142344979"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230901142519659.png" alt="image-20230901142519659"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230901142637962.png" alt="image-20230901142637962"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230921193227925.png" alt="image-20230921193227925"> </p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230901143911202.png" alt="image-20230901143911202"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230901144034278.png" alt="image-20230901144034278"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230901201028185.png" alt="image-20230901201028185"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230901201141126.png" alt="image-20230901201141126"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230901201932858.png" alt="image-20230901201932858"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230901201901622.png" alt="image-20230901201901622"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230901201916611.png" alt="image-20230901201916611"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230901202335415.png" alt="image-20230901202335415"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230901202532605.png" alt="image-20230901202532605"></p>
<p>限流常见算法：漏桶算法，令牌桶算法</p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230901205901883.png" alt="image-20230901205901883"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230901210222183.png" alt="image-20230901210222183"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230901210826338.png" alt="image-20230901210826338"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230901210938224.png" alt="image-20230901210938224"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230901211416812.png" alt="image-20230901211416812"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230901211400200.png" alt="image-20230901211400200"></p>
<p>XA保证数据的强一致性，CP模式</p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230901211826404.png" alt="image-20230901211826404"></p>
<p>AT保证了高可用，AP模式</p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230901212127755.png" alt="image-20230901212127755"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230901212635972.png" alt="image-20230901212635972"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230901213018145.png" alt="image-20230901213018145"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230903092446143.png" alt="image-20230903092446143"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230903092945297.png" alt="image-20230903092945297"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230903093423661.png" alt="image-20230903093423661"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230903094805469.png" alt="image-20230903094805469"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230903095130048.png" alt="image-20230903095130048"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230903095155475.png" alt="image-20230903095155475"></p>
<h2 id="rabbitMQ"><a href="#rabbitMQ" class="headerlink" title="rabbitMQ"></a>rabbitMQ</h2><p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230903112647561.png" alt="image-20230903112647561"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230903161425885.png" alt="image-20230903161425885"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230903160555210.png" alt="image-20230903160555210"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230903160657069.png" alt="image-20230903160657069"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230903161318076.png" alt="image-20230903161318076"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230903162406637.png" alt="image-20230903162406637"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230903164212308.png" alt="image-20230903164212308"></p>
<p>延迟队列&#x3D;死信交换机+TTL</p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230903163612830.png" alt="image-20230903163612830"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230903163829616.png" alt="image-20230903163829616"></p>
<p>若消息和队列都设置了存活时间，以短的时间为准</p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230903164050820.png" alt="image-20230903164050820"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230903164948171.png" alt="image-20230903164948171"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230903165036940.png" alt="image-20230903165036940"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230903165118553.png" alt="image-20230903165118553"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230903170043190.png" alt="image-20230903170043190"></p>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230905201404677.png" alt="image-20230905201404677"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230905201439718.png" alt="image-20230905201439718"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230905202639656.png" alt="image-20230905202639656"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230905203400101.png" alt="image-20230905203400101"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230905203511279.png" alt="image-20230905203511279"></p>
<p>OOM：内存溢出</p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230905203556351.png" alt="image-20230905203556351"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230905203931866.png" alt="image-20230905203931866"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230905203945863.png" alt="image-20230905203945863"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230905204313065.png" alt="image-20230905204313065"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230905204331252.png" alt="image-20230905204331252"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230905204437010.png" alt="image-20230905204437010"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230905204525341.png" alt="image-20230905204525341"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230905204709831.png" alt="image-20230905204709831"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230905205432134.png" alt="image-20230905205432134"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230905205501870.png" alt="image-20230905205501870"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230905205551211.png" alt="image-20230905205551211"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230905210140814.png" alt="image-20230905210140814"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230905210227691.png" alt="image-20230905210227691"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230905210248630.png" alt="image-20230905210248630"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230905211316185.png" alt="image-20230905211316185"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230905211403842.png" alt="image-20230905211403842"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230905211629152.png" alt="image-20230905211629152"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230905211735643.png" alt="image-20230905211735643"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230905211906711.png" alt="image-20230905211906711"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230905213057755.png" alt="image-20230905213057755"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230905213131473.png" alt="image-20230905213131473"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230905213146266.png" alt="image-20230905213146266"></p>
<p>​		<img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230905213205030.png" alt="image-20230905213205030"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230905213250975.png" alt="image-20230905213250975"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230905213301657.png" alt="image-20230905213301657"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230905213324919.png" alt="image-20230905213324919"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230906174400900.png" alt="image-20230906174400900"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230906174432274.png" alt="image-20230906174432274"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230906212255775.png" alt="image-20230906212255775"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230906212309997.png" alt="image-20230906212309997"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230906212412272.png" alt="image-20230906212412272"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230906212516012.png" alt="image-20230906212516012"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230906212635226.png" alt="image-20230906212635226"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230906212836580.png" alt="image-20230906212836580"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230906212959362.png" alt="image-20230906212959362"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230906213111688.png" alt="image-20230906213111688"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230906213601389.png" alt="image-20230906213601389"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230906213240869.png" alt="image-20230906213240869"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230906213310240.png" alt="image-20230906213310240"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230906213522473.png" alt="image-20230906213522473"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230907170233254.png" alt="image-20230907170233254"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230907171731637.png" alt="image-20230907171731637"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230907171800984.png" alt="image-20230907171800984"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20231008232925539.png" alt="image-20231008232925539"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230907171844743.png" alt="image-20230907171844743"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230907171914330.png" alt="image-20230907171914330"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230907171630507.png" alt="image-20230907171630507"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230907172134863.png" alt="image-20230907172134863"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230907172228365.png" alt="image-20230907172228365"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230907172712510.png" alt="image-20230907172712510"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230907172756274.png" alt="image-20230907172756274"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230907192336149.png" alt="image-20230907192336149"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230907192559270.png" alt="image-20230907192559270"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230907192653419.png" alt="image-20230907192653419"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230907192830343.png" alt="image-20230907192830343"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230907192859534.png" alt="image-20230907192859534"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230907193045320.png" alt="image-20230907193045320"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230907193646952.png" alt="image-20230907193646952"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230907200538753.png" alt="image-20230907200538753"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230907200617013.png" alt="image-20230907200617013"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230907200909354.png" alt="image-20230907200909354"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230907200954111.png" alt="image-20230907200954111"> </p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230907202757708.png" alt="image-20230907202757708"></p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230907205634342.png" alt="image-20230907205634342"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230907211318029.png" alt="image-20230907211318029"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230907211854561.png" alt="image-20230907211854561"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230907211910920.png" alt="image-20230907211910920"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230908211325012.png" alt="image-20230908211325012"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20231009203524738.png" alt="image-20231009203524738"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230908211710132.png" alt="image-20230908211710132"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230908212654218.png" alt="image-20230908212654218"></p>
<h2 id="技术场景"><a href="#技术场景" class="headerlink" title="技术场景"></a>技术场景</h2><p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230908212955574.png" alt="image-20230908212955574"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230908213440306.png" alt="image-20230908213440306"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230908213705206.png" alt="image-20230908213705206"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230908213805593.png" alt="image-20230908213805593"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230908214240885.png" alt="image-20230908214240885"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230908214102558.png" alt="image-20230908214102558"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230908214214650.png" alt="image-20230908214214650"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230908214800718.png" alt="image-20230908214800718"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230908215210002.png" alt="image-20230908215210002">	</p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230908215418612.png" alt="image-20230908215418612"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230908215816277.png" alt="image-20230908215816277"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230908220147511.png" alt="image-20230908220147511"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230908220835967.png" alt="image-20230908220835967"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230908220947930.png" alt="image-20230908220947930"></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230908221233908.png" alt="image-20230908221233908"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/11/05/%E9%9D%A2%E8%AF%95%E9%A2%98/" data-id="clommlfmf0003nsau0re79cd8" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-胡苏航的第一篇博客" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/11/05/%E8%83%A1%E8%8B%8F%E8%88%AA%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/" class="article-date">
  <time class="dt-published" datetime="2023-11-05T12:30:18.000Z" itemprop="datePublished">2023-11-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/11/05/%E8%83%A1%E8%8B%8F%E8%88%AA%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/">胡苏航的第一篇博客</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>欢迎赵一麟的来到</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/11/05/%E8%83%A1%E8%8B%8F%E8%88%AA%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/" data-id="clommlfma0001nsau8ixm1szl" data-title="胡苏航的第一篇博客" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/11/05/hello-world/" class="article-date">
  <time class="dt-published" datetime="2023-11-05T11:56:05.547Z" itemprop="datePublished">2023-11-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/11/05/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/11/05/hello-world/" data-id="clommlfm40000nsaucey99imo" data-title="Hello World" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">November 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/11/06/javaNote/">javaNote</a>
          </li>
        
          <li>
            <a href="/2023/11/05/%E9%9D%A2%E8%AF%95%E9%A2%98/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/11/05/%E8%83%A1%E8%8B%8F%E8%88%AA%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/">胡苏航的第一篇博客</a>
          </li>
        
          <li>
            <a href="/2023/11/05/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>